# Control Structures

## Module Objectives {#module-5-objectives .unnumbered}

-   Use foundational mathematical logic to write conditional statements
-   Create program flow diagrams for different control structures
-   Determine which iterative structure is more appropriate for a task
-   Identify the arguments, return statement, and body of a function
-   Write functions to perform simple tasks and use them appropriately

## Mathematical Logic

Before we start talking about data structures and control structures, though, we're going to take a minute to review some concepts from mathematical logic. This will be useful for both data structures and control structures, so stick with me for a few minutes.

### And, Or, and Not

We can combine logical statements using and, or, and not.

-   (X AND Y) requires that both X and Y are true.
-   (X OR Y) requires that one of X or Y is true.
-   (NOT X) is true if X is false, and false if X is true. Sometimes called **negation**.

In R, we use `!` to symbolize NOT, in Python, we use `~` for vector-wise negation (NOT).

Order of operations dictates that NOT is applied before other operations. So `NOT X AND Y` is read as `(NOT X) AND (Y)`. You must use parentheses to change the way this is interpreted.

::: panel-tabset
#### R

```{r}
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE, FALSE)

x & y # AND
x | y # OR
!x & y # NOT X AND Y
x & !y # X AND NOT Y
```

#### Python

```{python}
import numpy as np
x = np.array([True, False, True, False])
y = np.array([True, True, False, False])

x & y
x | y
~x & y
x & ~y
```
:::

### De Morgan's Laws

[De Morgan's Laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws) are a set of rules for how to combine logical statements. You can represent them in a number of ways:

-   NOT(A or B) is equivalent to NOT(A) and NOT(B)
-   NOT(A and B) is equivalent to NOT(A) or NOT(B)

::: panel-tabset
We can also represent them with Venn Diagrams.

#### Definitions

![Venn Diagram of Set A and Set B](images/control-structures/SetA%20and%20SetB.png) Suppose that we set the convention that ![Shaded regions are TRUE, unshaded regions are FALSE](images/control-structures/TrueFalse.png).

#### DeMorgan's First Law

![A venn diagram illustration of De Morgan's laws showing that the region that is outside of the union of A OR B (aka NOT (A OR B)) is the same as the region that is outside of (NOT A) and (NOT B)](images/control-structures/DeMorgan1.png)

#### DeMorgan's Second Law

![A venn diagram illustration of De Morgan's laws showing that the region that is outside of the union of A AND B (aka NOT (A AND B)) is the same as the region that is outside of (NOT A) OR (NOT B)](images/control-structures/DeMorgan2.png)
:::

DeMorgan's laws become very useful when you are writing complex conditional statements. They're basically the distributive rule of conditional statements and can help you simplify complex conditions.


## Conditional (If) Statements

Conditional statements determine if code is evaluated.

They look like this:

    if (condition)
      then
        (thing to do)
      else
        (other thing to do)

The else (other thing to do) part may be omitted.

When this statement is read by the computer, the computer checks to see if condition is true or false. If the condition is true, then (thing to do) is also run. If the condition is false, then (other thing to do) is run instead.

Let's try this out:

::: panel-tabset
### R {.unnumbered}

```{r}
x <- 3
y <- 1

if (x > 2) { 
  y <- 8
} else {
  y <- 4
}

print(paste("x =", x, "; y =", y))
```

In R, the logical condition after `if` must be in parentheses. It is common to then enclose the statement to be run if the condition is true in `{}` so that it is clear what code matches the if statement. You can technically put the condition on the line after the `if (x > 2)` line, and everything will still work, but then it gets hard to figure out what to do with the else statement - it technically would also go on the same line, and that gets hard to read.

```{r}
x <- 3
y <- 1

if (x > 2) y <- 8 else y <- 4

print(paste("x =", x, "; y =", y))
```

So while the 2nd version of the code technically works, the first version with the brackets is much easier to read and understand. Please try to emulate the first version!

### Python {.unnumbered}

```{python}
x = 3
y = 1

if x > 2:
  y = 8
else:
  y = 4

print("x =", x, "; y =", y)
```

In python, all code grouping is accomplished with spaces instead of with brackets. So in python, we write our if statement as `if x > 2:` with the colon indicating that what follows is the code to evaluate. The next line is indented with 2 spaces to show that the code on those lines belongs to that if statement. Then, we use the else: statement to provide an alternative set of code to run if the logical condition in the if statement is false. Again, we indent the code under the else statement to show where it "belongs".

Python will throw errors if you mess up the spacing. This is one thing that is very annoying about Python... but it's a consequence of trying to make the code more readable.

<!-- https://www.py4e.com/html3/03-conditional -->
:::

### Representing Conditional Statements as Diagrams

A common way to represent conditional logic is to draw a flow chart diagram.

In a flow chart, conditional statements are represented as diamonds, and other code is represented as a rectangle. Yes/no or True/False branches are labeled. Typically, after a conditional statement, the program flow returns to a single point.

![Program flow diagram outline of a simple if/else statement](images/control-structures/flow-chart1.png)

::: {.callout-tip}

### Try it out! {.unnumbered}

::: panel-tabset
#### Problem {.unnumbered}

The US Tax code has brackets, such that the first \$10,275 of your income is taxed at 10%, anything between \$10,275 and \$41,775 is taxed at 12%, and so on.

Here is the table of tax brackets for single filers in 2022:

| rate | Income                 |
|------|------------------------|
| 10%  | \$0 to \$10,275        |
| 12%  | \$10,275 to \$41,775   |
| 22%  | \$41,775 to \$89,075   |
| 24%  | \$89,075 to \$170,050  |
| 32%  | \$170,050 to \$215,950 |
| 35%  | \$215,950 to \$539,900 |
| 37%  | \$539,900 or more      |

Note: For the purposes of this problem, we're ignoring the personal exemption and the standard deduction, so we're already simplifying the tax code.

Write a set of if statements that assess someone's income and determine what their overall tax rate is.

Hint: You may want to keep track of how much of the income has already been taxed in a variable and what the total tax accumulation is in another variable.

#### R Solution {.unnumbered}

```{r}
# Start with total income
income <- 200000

# x will hold income that hasn't been taxed yet
x <- income
# y will hold taxes paid
y <- 0

if (x <= 10275) {
  y <- x*.1 # tax paid
  x <- 0 # All money has been taxed
} else {
  y <- y + 10275 * .1
  x <- x - 10275 # Money remaining that hasn't been taxed
}

if (x <= (41775 - 10275)) {
  y <- y + x * .12
  x <- 0
} else {
  y <- y + (41775 - 10275) * .12
  x <- x - (41775 - 10275) 
}

if (x <= (89075 - 41775)) {
  y <- y + x * .22
  x <- 0
} else {
  y <- y + (89075 - 41775) * .22
  x <- x - (89075 - 41775)
}

if (x <= (170050 - 89075)) {
  y <- y + x * .24
  x <- 0
} else {
  y <- y + (170050 - 89075) * .24
  x <- x - (170050 - 89075)
}

if (x <= (215950 - 170050)) {
  y <- y + x * .32
  x <- 0
} else {
  y <- y + (215950 - 170050) * .32
  x <- x - (215950 - 170050)
}

if (x <= (539900 - 215950)) {
  y <- y + x * .35
  x <- 0
} else {
  y <- y + (539900 - 215950) * .35
  x <- x - (539900 - 215950)
}

if (x > 0) {
  y <- y + x * .37
}


print(paste("Total Tax Rate on $", income, " in income = ", round(y/income, 4)*100, "%"))
```

#### Python Solution {.unnumbered}

```{python}
# Start with total income
income = 200000

# untaxed will hold income that hasn't been taxed yet
untaxed = income
# taxed will hold taxes paid
taxes = 0

if untaxed <= 10275:
  taxes = untaxed*.1 # tax paid
  untaxed = 0 # All money has been taxed
else:
  taxes = taxes + 10275 * .1
  untaxed = untaxed - 10275 # money remaining that hasn't been taxed

if untaxed <= (41775 - 10275):
  taxes = taxes + untaxed * .12
  untaxed = 0
else:
  taxes = taxes + (41775 - 10275) * .12
  untaxed = untaxed - (41775 - 10275) 


if untaxed <= (89075 - 41775):
  taxes = taxes + untaxed * .22
  untaxed = 0
else: 
  taxes = taxes + (89075 - 41775) * .22
  untaxed = untaxed - (89075 - 41775)

if untaxed <= (170050 - 89075):
  taxes = taxes + untaxed * .24
  untaxed = 0
else: 
  taxes = taxes + (170050 - 89075) * .24
  untaxed = untaxed - (170050 - 89075)

if untaxed <= (215950 - 170050):
  taxes = taxes + untaxed * .32
  untaxed = 0
else:
  taxes = taxes + (215950 - 170050) * .32
  untaxed = untaxed - (215950 - 170050)

if untaxed <= (539900 - 215950):
  taxes = taxes + untaxed * .35
  untaxed = 0
else: 
  taxes = taxes + (539900 - 215950) * .35
  untaxed = untaxed - (539900 - 215950)


if untaxed > 0:
  taxes = taxes + untaxed * .37



print("Total Tauntaxed Rate on $", income, " in income = ", round(taxes/income, 4)*100, "%")
```

We will find a better way to represent this calculation once we discuss loops - we can store each bracket's start and end point in a vector and loop through them. Any time you find yourself copy-pasting code and changing values, you should consider using a loop (or eventually a function) instead.


#### Program Flow Chart

Let's explore using program flow maps for a slightly more complicated problem: The tax bracket example that we just used to try out if statement syntax.

<!-- First, let's start by looking at a graph of the practical implication of taxing things using brackets. This graph shows the amount in each bracket as well as the amount of taxes paid. -->

```{r tax-data, echo = F, eval = F, fig.width = 5, fig.height = 4, out.width = "60%", fig.cap = "Marginal tax brackets for an income of \\$200k"}
library(tidyverse)


x <- 200000

df <- tribble(
~rate, ~LB, ~UB,
.1, 0, 10275	,
.12, 10275, 41775,
.22, 41775, 89075,
.24, 89075, 170050,
.32, 170050, 215950,
.35, 215950, 539900,
.37, 539900, Inf
)  %>% 
  mutate(bracket = 1:n()) %>%
  mutate(bracket_lab = factor(bracket, labels = sprintf("~%0.0fK - ~%0.0fK", LB/1000, UB/1000) %>% str_remove(" - ~InfK") %>% str_replace("~0K", "0"))) %>%
  mutate(
  taxable_amount = pmax(pmin((x - LB),0), pmax(0,pmin(UB, x) - LB)),
  taxes = taxable_amount * rate,
  untaxed_amount = taxable_amount - taxes
)

df2 <- df %>%
  pivot_longer(taxable_amount:taxes, names_to = "type", values_to = "amount") %>%
  mutate(type = str_replace_all(type, c("taxes" = "Taxes", "taxable_amount" = "Taxable Amount")))

df2 %>% 
  ggplot(aes(ymin = bracket -.4, ymax = bracket + .4, xmin = 0, xmax = amount, fill = type)) + 
  geom_rect(alpha = .5, color = "black") +
  scale_fill_manual(values = c("Taxes" = "black", "Taxable Amount" = "white")) + 
  scale_y_continuous("Tax Bracket", breaks = df$bracket, labels = df$bracket_lab) + 
  scale_x_continuous("Marginal Amount", expand = expansion(mult = c(0.025, .1), add = c(0, .1))) + 
  geom_text(data = filter(df2, df2$type == "Taxable Amount"), aes(x = amount, y = bracket, label = sprintf("%.0f%%", rate*100), color = "Marginal rate"), hjust = -.1) + 
  scale_color_manual("", values = c("Marginal rate" = "red")) + 
  theme_bw() + 
  theme(legend.position = "bottom", legend.title = element_blank()) + 
  ggtitle("Breaking down Taxation (Single Bracket, 2022, for 200K)")

```

![The control flow diagram for the code in the previous example](images/control-structures/tax-brackets.png)

Control flow diagrams can be extremely helpful when figuring out how programs work (and where gaps in your logic are when you're debugging). It can be very helpful to map out your program flow as you're untangling a problem.

:::

:::

### Chaining Conditional Statements: Else-If

In many cases, it can be helpful to have a long chain of conditional statements describing a sequence of alternative statements.

::: {.callout-caution}
#### Example: Age Brackets
For instance, suppose I want to determine what categorical age bracket someone falls into based on their numerical age. All of the bins are mutually exclusive - you can't be in the 25-40 bracket and the 41-55 bracket.

::: panel-tabset
##### Program Flow Map {.unnumbered}

![Program flow map for a series of mutually exclusive categories. If our goal is to take a numeric age variable and create a categorical set of age brackets, such as \<18, 18-25, 26-40, 41-55, 56-65, and \>65, we can do this with a series of if-else statements chained together. Only one of the bracket assignments is evaluated, so it is important to place the most restrictive condition first.](images/control-structures/age-category-prog-flow.png)

The important thing to realize when examining this program flow map is that if `age <= 18` is true, then **none of the other conditional statements even get evaluated**. That is, once a statement is true, none of the other statements matter. Because of this, it is important to place the most restrictive statement first.

![Program flow map for a series of mutually exclusive categories, emphasizing that only some statements are evaluated. When age = 40, only (age \<= 18), (age \<= 25), and (age \<= 40) are evaluated conditionally. Of the assignment statements, only bracket = '26-40' is evaluated when age = 40.](images/control-structures/age-category-prog-flow2.png)

If for some reason you wrote your conditional statements in the wrong order, the wrong label would get assigned:

![Program flow map for a series of mutually exclusive categories, with category labels in the wrong order - \<40 is evaluated first, and so \<= 25 and \<= 18 will never be evaluated and the wrong label will be assigned for anything in those categories.](images/control-structures/age-category-prog-flow3.png)

In code, we would write this statement using `else-if` (or `elif`) statements.

##### R {.unnumbered}

```{r else-if-statements}
age <- 40 # change this as you will to see how the code works

if (age < 18) {
  bracket <- "<18"
} else if (age <= 25) {
  bracket <- "18-25"
} else if (age <= 40) {
  bracket <- "26-40"
} else if (age <= 55) {
  bracket <- "41-55" 
} else if (age <= 65) {
  bracket <- "56-65"
} else {
  bracket <- ">65"
}

bracket
```

##### Python {.unnumbered}

Python uses `elif` as a shorthand for `else if` statements. As always, indentation/white space in python matters. If you put an extra blank line between two elif statements, then the interpreter will complain. If you don't indent properly, the interpreter will complain.

```{python elif-statements}
age = 40 # change this to see how the code works

if age < 18:
  bracket = "<18"
elif age <= 25:
  bracket = "18-25"
elif age <= 40:
  bracket = "26-40"
elif age <= 55:
  bracket = "41-55"
elif age <= 65:
  bracket = "56-65"
else:
  bracket = ">65"
  
bracket
```
:::
:::

## Loops

<!-- https://www.py4e.com/html3/05-iterations -->

Often, we write programs which update a variable in a way that the new value of the variable depends on the old value:

    x = x + 1

This means that we add one to the current value of `x`.

Before we write a statement like this, we have to **initialize** the value of `x` because otherwise, we don't know what value to add one to.

    x = 0
    x = x + 1

We sometimes use the word **increment** to talk about adding one to the value of `x`; **decrement** means subtracting one from the value of `x`.

A particularly powerful tool for making these types of repetitive changes in programming is the **loop**, which executes statements a certain number of times. Loops can be written in several different ways, but all loops allow for executing a block of code a variable number of times.

### While Loops

In the previous section, we discussed conditional statements, where a block of code is only executed *if* a logical statement is true.

The simplest type of loop is the **while** loop, which executes a block of code until a statement is no longer true.

![Flow map showing while-loop pseudocode (while x \<= N) { \# code that changes x in some way} and the program flow map expansion where we check if x \> N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then change x and start over.](images/control-structures/while-loop-flow.png)

::: panel-tabset
##### R {.unnumbered}

```{r while-loop-r}
x <- 0

while (x < 10) { 
  # Everything in here is executed 
  # during each iteration of the loop
  print(x)
  x <- x + 1
}
```

##### Python {.unnumbered}

```{python while-loop-py}
x = 0

while x < 10:
  print(x)
  x = x + 1

```
:::

::: {.callout-tip}
#### While Loops: Try it Out! {.unnumbered}

::: panel-tabset
##### Problem {.unnumbered}

Write a while loop that verifies that $$\lim_{N \rightarrow \infty} \prod_{k=1}^N \left(1 + \frac{1}{k^2}\right) = \frac{e^\pi - e^{-\pi}}{2\pi}.$$

Terminate your loop when you get within 0.0001 of $\frac{e^\pi - e^{-\pi}}{2\pi}$. At what value of $k$ is this point reached?

##### Math Notation {.unnumbered}

Breaking down math notation for code:

-   If you are unfamiliar with the notation $\prod_{k=1}^N f(k)$, this is the product of $f(k)$ for $k = 1, 2, ..., N$, $$f(1)\cdot f(2)\cdot ... \cdot f(N)$$

-   To evaluate a limit, we just keep increasing $N$ until we get arbitrarily close to the right hand side of the equation.

In this problem, we can just keep increasing $k$ and keep track of the cumulative product. So we define `k=1`, `prod = 1`, and `ans` before the loop starts. Then, we loop over `k`, multiplying `prod` by $(1 + 1/k^2)$ and then incrementing $k$ by one each time. At each iteration, we test whether `prod` is close enough to `ans` to stop the loop.

##### R Solution {.unnumbered}

In R, you will use `pi` and `exp()` - these are available by default without any additional libraries or packages.

```{r}
k <- 1
prod <- 1
ans <- (exp(pi) - exp(-pi))/(2*pi)
delta <- 0.0001

while (abs(prod - ans) >= 0.0001) {
  prod <- prod * (1 + 1/k^2)
  k <- k + 1
}

k
prod
ans
```

##### Python solution {.unnumbered}

Note that in python, you will have to import the math library to get the values of pi and the `exp` function. You can refer to these as `math.pi` and `math.exp()` respectively.

```{python}
import math

k = 1
prod = 1
ans = (math.exp(math.pi) - math.exp(-math.pi))/(2*math.pi)
delta = 0.0001

while abs(prod - ans) >= 0.0001:
  prod = prod * (1 + k**-2)
  k = k + 1
  if k > 500000:
    break


print("At ", k, " iterations, the product is ", prod, "compared to the limit ", ans,".")
```
:::

:::

### For Loops

Another common type of loop is a **for** loop. In a for loop, we run the block of code, iterating through a series of values (commonly, one to N, but not always). Generally speaking, for loops are known as **definite** loops because the code inside a for loop is executed a specific number of times. While loops are known as **indefinite** loops because the code within a while loop is evaluated until the condition is falsified, which is not always a known number of times.

::: panel-tabset
##### Flow Map {.unnumbered}

![Flow map showing for-loop pseudocode (for j in 1 to N) { \# code} and the program flow map expansion where j starts at 1 and we check if j \> N (exiting the loop if true); otherwise, we continue into the loop, execute the main body of #code and then increment j and start over.](images/control-structures/for-loop-flow.png)

##### R {.unnumbered}

```{r}
for (i in 1:5 ) {
  print(i)
}

```

##### Python {.unnumbered}

```{python}
for i in range(5):
  print(i)

```

By default `range`(5) goes from 0 to 5, the upper bound. When `i = 5` the loop exits. This is because `range(5)` creates a vector `[0, 1, 2, 3, 4]`.
:::

For loops are often run from 1 to N (or 0 to N-1 in python) but in essence, a for loop is run for every value of a vector (which is why loops are included in the same chapter as vectors).

::: {.callout-caution}
#### Example: For Loops {.unnumbered}

::: panel-tabset
##### R {.unnumbered}

For instance, in R, there is a built-in variable called `month.name`. Type `month.name` into your R console to see what it looks like. If we want to iterate along the values of month.name, we can:

```{r}
for (i in month.name)
  print(i)
```

##### Python {.unnumbered}

In python, we have to define our vector or list to start out with, but that's easy enough:

```{python}
futurama_crew = ['Fry', 'Leela', 'Bender', 'Amy', 'the Professor', 'Hermes', 'Zoidberg', 'Nibbler']
for i in futurama_crew:
  print(i)

```
:::
:::

::: {.callout-important}
### Avoiding Infinite Loops

It is very easy to create an **infinite** loop when you are working with while loops. Infinite loops never exit, because the condition is always true. If in the while loop example we decrement x instead of incrementing x, the loop will run forever.

You want to try very hard to avoid ever creating an infinite loop - it can cause your session to crash.

One common way to avoid infinite loops is to create a second variable that just counts how many times the loop has run. If that variable gets over a certain threshold, you exit the loop.

::: panel-tabset
#### R {.unnumbered}

This while loop runs until either x \< 10 or n \> 50 - so it will run an indeterminate number of times and depends on the random values added to x. Since this process (a 'random walk') could theoretically continue forever, we add the n\>50 check to the loop so that we don't tie up the computer for eternity.

```{r infinite-loop-exit-r}
x <- 0
n <- 0 # count the number of times the loop runs

while (x < 10) { 
  print(x)
  x <- x + rnorm(1) # add a random normal (0, 1) draw each time
  n <- n + 1
  if (n > 50) 
    break # this stops the loop if n > 50
}
```

#### Python {.unnumbered}

```{python infinite-loop-exit-py}
import numpy as np; # for the random normal draw

x = 0
n = 0 # count the number of times the loop runs

while x < 10:
  print(x)
  x = x + np.random.normal(0, 1, 1) # add a random normal (0, 1) draw each time
  n = n + 1
  if n > 50:
    break # this stops the loop if n > 50

```
:::

In both of the examples above, there are more efficient ways to write a random walk, but we will get to that later. The important thing here is that we want to make sure that our loops don't run for all eternity.

:::

### Controlling Loops

<!-- https://www.py4e.com/html3/05-iterations -->

<!-- https://www.datamentor.io/r-programming/break-next/ -->

Sometimes it is useful to control the statements in a loop with a bit more precision. You may want to skip over code and proceed directly to the next iteration, or, as demonstrated in the previous section with the `break` statement, it may be useful to exit the loop prematurely.

::: panel-tabset
#### Break Statement {.unnumbered}

![A break statement is used to exit a loop prematurely](images/control-structures/break-statement.png)

#### Next/Continue Statement {.unnumbered}

![A next (or continue) statement is used to skip the body of the loop and continue to the next iteration](images/control-structures/next-statement-flow.png)
:::

:::{.callout-caution}
#### Example: Next/Continue statements {.unnumbered}
Let's demonstrate the details of next/continue and break statements.

We can do different things based on whether i is evenly divisible by 3, 5, or both 3 and 5 (thus divisible by 15)

::: panel-tabset
##### R {.unnumbered}

```{r}
for (i in 1:20) {
  if (i %% 15 == 0) {
    print("Exiting now")
    break
  } else if (i %% 3 == 0) {    
    print("Divisible by 3")
    next
    print("After the next statement") # this should never execute
  } else if (i %% 5 == 0) {
    print("Divisible by 5")
  } else {
    print(i)
  }
}
```

##### Python {.unnumbered}

```{python}
for i in range(1, 20):
  if i%15 == 0:
    print("Exiting now")
    break
  elif i%3 == 0:
    print("Divisible by 3")
    continue
    print("After the next statement") # this should never execute
  elif i%5 == 0:
    print("Divisible by 5")
  else: 
    print(i)

```
:::

:::

To be quite honest, I haven't really ever needed to use next/continue statements when I'm programming, and I rarely use break statements. However, it's useful to know they exist just in case you come across a problem where you could put either one to use.


## Functions

A **function** is a set of actions that we group together and name. Throughout this course, you've used a bunch of different functions in R and python that are built into the language or added through packages: `mean`, `ggplot`, `length`, `print`. In this chapter, we'll be writing our own functions.

### When to write a function?

If you've written the same code (with a few minor changes, like variable names) more than twice, you should probably write a function instead. There are a few benefits to this rule:

1. Your code stays neater (and shorter), so it is easier to read, understand, and maintain.

2. If you need to fix the code because of errors, you only have to do it in one place.

3. You can re-use code in other files by keeping functions you need regularly in a file (or if you're really awesome, in your own package!)

4. If you name your functions well, your code becomes easier to understand thanks to grouping a set of actions under a descriptive function name.


::: {.callout-note}
#### Learn more about functions

There is some extensive material on this subject in R for Data Science [@r4ds] on [functions](https://r4ds.had.co.nz/functions.html). If you want to really understand how functions work in R, that is a good place to go.

:::

<br/>

:::{.callout-caution}
#### Example: Turning Code into Functions

This example is modified from R for Data Science [@advr, Chapter 19]. 

What does this code do? Does it work as intended?

::: {.panel-tabset}

#### R {-}

```{r function-copy-paste-error}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
```

#### Python

```{python}
import pandas as pd
import numpy as np

df = pd.DataFrame({
  'a': np.random.randn(10), 
  'b': np.random.randn(10), 
  'c': np.random.randn(10), 
  'd': np.random.randn(10)})

df.a = (df.a - min(df.a))/(max(df.a) - min(df.a))
df.b = (df.b - min(df.b))/(max(df.b) - min(df.a))
df.c = (df.c - min(df.c))/(max(df.c) - min(df.c))
df.d = (df.d - min(df.d))/(max(df.d) - min(df.d))
```

:::

The code rescales a set of variables to have a range from 0 to 1. But, because of the copy-pasting, the code's author made a mistake and forgot to change an `a` to `b`. 

Writing a function to rescale a variable would prevent this type of copy-paste error.

To write a function, we first analyze the code to determine how many inputs it has

::: {.panel-tabset}

#### R {-}

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

This code has only one input: `df$a`. 

#### Python {-}

```{python}

df.a = (df.a - min(df.a))/(max(df.a) - min(df.a))

```


This code has only one input: `df.a` 

:::


To convert the code into a function, we start by rewriting it using general names

::: {.panel-tabset}

#### R {-}

In this case, it might help to replace `df$a` with `x`.

```{r}
x <- df$a 

(x - min(x, na.rm = TRUE)) / 
  (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

#### Python {-}

In this case, it might help to replace `df.a` with `x`.

```{python}
x = df.a

(x - min(x))/(max(x) - min(x))

```

:::

Then, we make it a bit easier to read, removing duplicate computations if possible (for instance, computing `min` two times).


::: {.panel-tabset}

#### R {-}

In R, we can use the `range` function, which computes the maximum and minimum at the same time and returns the result as `c(min, max)`

```{r}
rng <- range(x, na.rm = T)

(x - rng[1])/(rng[2] - rng[1])
```

#### Python {-}

In python, `range` is the equivalent of `seq()` in R, so we are better off just using `min` and `max`. 

```{python}
x = df.a


xmin, xmax = [x.min(), x.max()]
(x - xmin)/(xmax - xmin)

```

:::

Finally, we turn this code into a function

::: {.panel-tabset}

#### R {-}

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = T)
  (x - rng[1])/(rng[2] - rng[1])
}

rescale01(df$a)
```

- The name of the function, `rescale01`, describes what the function does - it rescales the data to between 0 and 1. 
- The function takes one **argument**, named `x`; any references to this value within the function will use `x` as the name. This allows us to use the function on `df$a`, `df$b`, `df$c`, and so on, with `x` as a placeholder name for the data we're working on at the moment.
- The code that actually does what your function is supposed to do goes in the **body** of the function, between `{` and `}` (this is true in R, in python, there are different conventions, but the same principle applies)
- The function **returns** the last value computed: in this case, `(x - rng[1])/(rng[2]-rng[1])`. You can make this explicit by adding a `return()` statement around that calculation.

#### Python {-}

```{python}
def rescale01(x):
  xmin, xmax = [x.min(), x.max()]
  return (x - xmin)/(xmax - xmin)

rescale01(df.a)
```

- The name of the function, `rescale01`, describes what the function does - it rescales the data to between 0 and 1. 
- The function takes one **argument**, named `x`; any references to this value within the function will use `x` as the name. This allows us to use the function on `df.a`, `df.b`, `df.c`, and so on, with `x` as a placeholder name for the data we're working on at the moment.
- The code that actually does what your function is supposed to do goes in the **body** of the function, indented relative to the line with `def: function_name():`. At the end of the function, you should have a blank line with no spaces or tabs.

- The function **returns** the value it is told to `return`: in this case, `(x - xmin)/(xmax - xmin)`. In Python, you must `return` a value if you want the function to perform a computation. ^[This is not strictly true, you can of course use pass-by-reference, but we will not be covering that in this class as we are strictly dealing with the bare minimum of learning how to write a function here.]

:::

The process for creating a function is important: first, you figure out how to do the thing you want to do. Then, you simplify the code as much as possible. Only at the end of that process do you create an actual function.

:::


### Syntax

![R and python syntax for defining functions. Portions of the command that indicate the function name, function scope, and return statement are highlighted in each block.](images/control-structures/Annotating_function_syntax.png)

In R, functions are defined as other variables, using `<-`, but we specify the arguments a function takes by using the `function()` statement. The contents of the function are contained within `{` and `}`. If the function returns a value, a `return()` statement can be used; alternately, if there is no return statement, the last computation in the function will be returned.

In python, functions are defined using the `def` command, with the function name, parentheses, and the function arguments to follow. The first line of the function definition ends with a `:`, and all subsequent lines of the function are indented (this is how python knows where the end of the function is). A python function return statement is `return <value>`, with no parentheses needed.

Note that in python, the `return` statement is not optional. It is not uncommon to have python functions that don't return anything; in R, this is a bit less common, for reasons we won't get into here.

### Arguments and Parameters

An **argument** is the name for the object you pass into a function.

A **parameter** is the name for the object once it is inside the function (or the name of the thing as defined in the function).

::: {.callout-caution}
#### Example: Parts of a Function

Let's examine the difference between arguments and parameters by writing a function that takes a puppy's name and returns "<name> is a good pup!".

:::: {.panel-tabset}

#### R {-}

```{r}
dog <- "Eddie"

goodpup <- function(name) {
  paste(name, "is a good pup!")
}

goodpup(dog)
```

In this example R function, when we call `goodpup(dog)`, `dog` is the argument. `name` is the parameter. 

#### Python {-}

```{python}
dog = "Eddie"

def goodpup(name):
  return name + " is a good pup!"

goodpup(dog)
```

In this example python function, when we call `goodpup(dog)`, `dog` is the argument. `name` is the parameter. 

::::

What is happening inside the computer's memory as `goodpup` runs?

![A sketch of the execution of the program `goodpup`, showing that `name` is only defined within the local environment that is created while `goodpup` is running. We can never access `name` in our global environment.](images/control-structures/function_argument_parameters.png)

:::

This is why the distinction between **arguments** and **parameters** matters. Parameters are only accessible while inside of the function - and in that local environment, we need to call the object by the parameter name, not the name we use outside the function (the argument name). 

We can even call a function with an argument that isn't defined outside of the function call: `goodpup("Tesla")` produces "`r goodpup("Tesla")`". Here, I do not have a variable storing the string "Tesla", but I can make the function run anyways. So "Tesla" here is an argument to `goodpup` but it is not a variable in my environment.

This is a confusing set of concepts and it's ok if you only just sort of get what I'm trying to explain here. Hopefully it will become more clear as you write more code.

::: {.callout-tip}
### Try it out: Function Parts {-}

For each of the following blocks of code, identify the function name, function arguments, parameter names, and return statements. When the function is called, see if you can predict what the output will be. Also determine whether the function output is stored in memory or just printed to the command line.

::: {.panel-tabset}

#### Function 1 {-}
```{python function-predict-1}

def hello_world():
  print("Hello World")

```

```{python function-predict-1-call, eval = F}
hello_world()
```

#### Answer {-}

- Function name: `hello_world`
- Function parameters: none
- Function arguments: none
- Function output: 

```{python function-predict1-results}
hello_world()
```

- Function output is not stored in memory and is printed to the command line.

:::


::: {.panel-tabset}

#### Function 2 {-}

```{r function-predict-2}

my_mean <- function(x) {
  censor_x <- sample(x, size = length(x) - 2, replace = F)
  mean(censor_x)
}

```

```{r function-predict-2-call, eval = F}
set.seed(3420523)
x = my_mean(1:10)
x
```

#### Answer {-}

- Function name: `my_mean`
- Function parameters: x
- Function arguments: 1:10
- Function output: (varies each time the function is run unless you set the seed)

```{r function-predict2-results}
set.seed(3420523)
x = my_mean(1:10)
x
```

- Function output is saved to memory (`x`) and printed to the command line

:::

:::

### Named Arguments and Parameter Order

In the examples above, you didn't have to worry about what order parameters were passed into the function, because there were 0 and 1 parameters, respectively. But what happens when we have a function with multiple parameters?

::: {.panel-tabset}

#### R  {-}

```{r}

divide <- function(x, y) {
  x / y
}

```

#### Python {-}
```{python}

def divide(x, y):
  return x / y

```

:::

In this function, the order of the parameters matters! `divide(3, 6)` does not produce the same result as `divide(6, 3)`. As you might imagine, this can quickly get confusing as the number of parameters in the function increases.

In this case, it can be simpler to use the parameter names when you pass in arguments.

::: {.panel-tabset}

#### R  {-}

```{r}
divide(3, 6)

divide(x = 3, y = 6)

divide(y = 6, x = 3)

divide(6, 3)

divide(x = 6, y = 3)

divide(y = 3, x = 6)

```

#### Python {-}

```{python}
divide(3, 6)

divide(x = 3, y = 6)

divide(y = 6, x = 3)

divide(6, 3)

divide(x = 6, y = 3)

divide(y = 3, x = 6)

```

:::

As you can see, the order of the arguments doesn't much matter, as long as you use named arguments, but if you don't name your arguments, the order very much matters.

### Input Validation

When you write a function, you often assume that your parameters will be of a certain type. But you can't guarantee that the person using your function knows that they need a certain type of input. In these cases, it's best to **validate** your function input.

::: {.callout-caution}

#### Input Validation Example {-}

::: panel-tabset

##### R {-}

In R, you can use `stopifnot()` to check for certain essential conditions. If you want to provide a more illuminating error message, you can check your conditions using `if()` and then use `stop("better error message")` in the body of the if statement. 

```{r, error = T}
add <- function(x, y) {
  x + y
}

add("tmp", 3)

add <- function(x, y) {
  stopifnot(is.numeric(x))
  stopifnot(is.numeric(y))
  x + y
}

add("tmp", 3)
add(3, 4)
```

##### Python {-}

In Python, the easiest way to handle errors is to use a try statement, which operates rather like an if statement: if the statement executes, then we're good to go; if not, we can use `except` to handle different types of errors. The `else` clause is there to handle anything that needs to happen if the statement in the `try` clause executes without any errors.

```{python, error = T}

def add(x, y):
  x + y

add("tmp", 3)

def add(x, y):
  try:
    return x + y
  except TypeError:
    print("x and y must be add-able")
  else:
    # We should never get here, because the try clause has a return statement
    print("Else clause?")
  return

add("tmp", 3)
add(3, 4)

```

You can read more about error handling in Python [here](https://docs.python.org/3/tutorial/errors.html)

:::

:::

Input validation is one aspect of **defensive programming** - programming in such a way that you try to ensure that your programs don't error out due to unexpected bugs by anticipating ways your programs might be misunderstood or misused [@DefensiveProgramming2022].


### Scope

When talking about functions, for the first time we start to confront a critical concept in programming, which is scope. **Scope** is the part of the program where the name you've given a variable is valid - that is, where you can use a variable.

> A variable is only available from inside the region it is created.

What do I mean by the part of a program? The **lexical scope** is the portion of the code (the set of lines of code) where the name is valid.

The concept of scope is best demonstrated through a series of examples, so in the rest of this section, I'll show you some examples of how scope works and the concepts that help you figure out what "scope" actually means in practice.


#### Name Masking

Scope is most clearly demonstrated when we use the same variable name inside and outside a function. Note that this is 1) bad programming practice, and 2) fairly easily avoided if you can make your names even slightly more creative than `a`, `b`, and so on. But, for the purposes of demonstration, I hope you'll forgive my lack of creativity in this area so that you can see how name masking works.

::: {.callout-caution}

What does this function return, 10 or 20? 

::: panel-tabset

##### Pseudocode {-}

```
a = 10

myfun = function() {
  a = 20
  return a
}

myfun()
```

##### Sketch {-}

![A sketch of the global environment as well as the environment within `myfun()`. Because `a=20` inside `myfun()`, when we call `myfun()`, we get the value of `a` within that environment, instead of within the global environment.](images/control-structures/function-scope.png)

##### R {-}

```{r}
a <- 10

myfun <- function() {
  a <- 20
  a
}

myfun()

```

##### Python {-}

```{python}

a = 10

def myfun():
  a = 20
  return a

myfun()
```

:::

:::

The lexical scope of the function is the area that is between the braces (in R) or the indented region (in python). Outside the function, `a` has the value of 10, but inside the function, `a` has the value of 20. So when we call `myfun()`, we get 20, because the scope of `myfun` is the **local context** where `a` is evaluated, and the value of `a` in that environment dominates.

This is an example of **name masking**, where names defined inside of a function mask names defined outside of a function.


#### Environments and Scope

Another principle of scoping is that if you call a function and then call the same function again, the function's environment is re-created each time. Each function call is unrelated to the next function call when the function is defined using local variables.

::: {.callout-caution}

::: panel-tabset

##### Pseudocode {-}

```
myfun = function() {
  if a is not defined
    a = 1
  else
    a = a + 1
}

myfun()
myfun()

```

What does this output?

##### Sketch {-}

![When we define myfun, we create a template for an environment with variables and code to excecute. Each time `myfun()` is called, that template is used to create a new environment. This prevents successive calls to `myfun()` from affecting each other -- which means `a = 1` every time.](images/control-structures/function-scope-environment.png)


##### R {-}

```{r}
myfun <- function() {
  if (!exists("aa")) {
    aa <- 1
  } else {
    aa <- aa + 1
  }
  return(aa)
}

myfun()
myfun()
```

##### Python {-}

```{python}
def myfun():
  try: aa
  except NameError: aa = 1
  else: aa = aa + 1
  return aa

myfun()
myfun()
```

Note that the `try` command here is used to handle the case where a doesn't exist. If there is a NameError (which will happen if `aa` is not defined) then we define `aa = 1`, if there is not a NameError, then `aa = aa + 1`. 

This is necessary because [Python does not have a built-in way to test if a variable exists before it is used](https://www.oreilly.com/library/view/python-cookbook/0596001673/ch17s02.html) [@martelliPythonCookbook2002, Ch 17].

:::

:::

#### Dynamic Lookup

Scoping determines where to look for values -- when, however, is determined by the sequence of steps in the code. When a function is called, the **calling environment** (the global environment or set of environments at the time the function is called) determines what values are used. 

If an object doesn't exist in the function's environment, the global environment will be searched next; if there is no object in the global environment, the program will error out. This behavior, combined with changes in the calling environment over time, can mean that the output of a function can change based on objects outside of the function.

::: {.callout-caution}

::: panel-tabset

##### Pseudocode {-}

```
myfun = function() x + 1

x = 14

myfun()

x = 20

myfun()

```

What will the output be of this code?

##### Sketch {-}

![The state of the global environment at the time the function is called (that is, the state of the calling environment) can change the results of the function](images/control-structures/function-scope-calling-environment.png)


##### R {-}

```{r}
myfun <- function() {
  x + 1
}

x <- 14

myfun()

x <- 20

myfun()
```

##### Python {-}

```{python}

def myfun():
  return x + 1


x = 14

myfun()

x = 20

myfun()

```

:::
:::

:::{.callout-tip}
#### Try It Out: Function Scope {-}

What does the following function return? Make a prediction, then run the code yourself. 
(Taken from [@advr, Chapter 6])

::: panel-tabset

###### R code {-}

```{r, eval = F}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)
```

###### R solution {-}

```{r}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)
```

###### Python code {-}

```{python, eval = F}
def f(x):
  def f(x):
    def f():
      return x ^ 2
    return f() + 1
  return f(x) * 2

f(10)
```

###### Python solution {-}


```{python}
def f(x):
  def f(x):
    def f():
      return x ** 2
    return f() + 1
  return f(x) * 2

f(10)
```

:::

:::

## References
