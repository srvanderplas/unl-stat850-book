```{r, include = F}
.reset()
```
# Introduction to Data Visualization {#data-vis-intro}

## Module Objectives {-}

- Create statistical charts in SAS and R
- Use the grammar of graphics to describe different types of charts and graphs
- Use the grammar of graphics to create layered graphics and highlight different features of a data set
- Modify or construct alternate charts showing the same material with better readability and accessibility


There are a lot of different types of charts, and equally many ways  to categorize and describe the different types of charts. 

![](https://imgs.xkcd.com/comics/alignment_chart_alignment_chart.png)

Hopefully by the end of this, you will be able to at least make the charts which are most commonly used to show data and statistical concepts. 

This is going to be a fairly extensive chapter (in terms of content) because I want you to have a resource to access later, if you need it. But, this is also the chapter where we really start to focus on R instead of SAS. Even the hardcore SAS users I know (in this department and others) go into R when they want to make a publication-quality chart. 

Visualization and statistical graphics are also my research area, so I'm probably going to be a bit more passionate about this chapter, which means there's probably going to be more to read. Sorry about that in advance. I'll do my best to indicate which content is actually mission-critical and which content you can skip if you're not that interested.

## Why do we create graphics?

> The greatest possibilities of visual display lie in vividness and inescapability of the intended message. A visual display can stop your mental flow in its tracks and make you think. A visual display can force you to notice what you never expected to see. ("Why, that scatter diagram has a hole in the middle!") -- John Tukey, [Data Based Graphics: Visual Display in the Decades to Come](https://projecteuclid.org/euclid.ss/1177012101)

<details><summary>Charts are easier to understand than raw data. (more details inside) </summary>
When you think about it, data is a pretty artificial thing. We exist in a world of tangible objects, but data are an abstraction - even when the data record information about the tangible world, the measurements are a way of removing the physical and transforming the "real world" into a virtual thing. As an artificial entity, it can be hard to wrap our heads around what our data contain. The solution to this is to transform our data back into something that is "tangible" in some way -- if not physical and literally touch-able, at least something we can view and "wrap our heads around". 

Consider this thought experiment: You have a simple dataset - 2 variables, 500 observations. You want to get a sense of how the variables relate to each other. You can do one of the following options:

1. Print out the dataset
2. Create some summary statistics of each variable and perhaps the covariance between the two variables
3. Draw a scatterplot of the two variables

Which one would you rather use? Why?

Our brains are very good at processing large amounts of visual information quickly - it's important to be able to e.g. survey a field and pick out the tiger that might eat you. When we present information visually, in a format that can leverage our visual processing abilities, we offload some of the work of understanding the data to a chart that organizes it for us. You could argue that printing out the data is a visual presentation, but it requires that you read that data in as text, which we're not nearly as equipped to process quickly (and in parallel). 

In addition, I've found that it's a lot easier to talk to non-experts about complicated statistics using visualizations. Moving the discussion from abstract concepts to concrete shapes and lines keeps people who are potentially already math or stat phobic from completely panicking and tuning out.
</details>

## General approaches to creating graphics

There are two general approaches to generating statistical graphics computationally: 

1. Manually specify the plot that you want, doing the preprocessing and summarizing before you create the plot.

2. Describe the relationship between the plot and the data, using sensible defaults that can be customized for common operations.

In the introduction to [The Grammar of Graphics](https://www.springer.com/gp/book/9780387245447), Leland Wilkinson suggests that the first approach is what we would call "charts" - pie charts, line charts, bar charts - objects that are "instances of much more general objects". He's arguing for the virtues of the 2nd approach -- the grammar of graphics, so his opinion is hardly unbiased, but it is an interesting distinction. His argument is that elegant graphical design means we have to think about an underlying theory of graphics, rather than how to create specific charts.

Base R graphics and the original SAS graphics engine fall firmly into the first camp. `ggplot2` was designed using the philosophy of the grammar of graphics, and is still the primary place that people learn about the grammar of graphics in statistics. The SAS ODS Graphics Engine^[I'll fully admit my bias here - I think ODS graphics are better than the default SAS graphics, but I still prefer the syntax and logic behind ggplot2. But, if you prefer SAS Graphics, you do you. Better you than me, is all I'm saying.] falls somewhere in between the two approaches - it provides some sensible defaults, but its design isn't rooted in the philosophy of the grammar of graphics, so if (as some SAS manuals have claimed) there is a similarity between the two, it's functional (in my opinion) and not because of an underlying similarity in the design strategy.

::: note
In either case, you're going to learn how to make graphics by finding sample code, changing that code to match your dataset, and tweaking things as you go. That's the best way to learn this, and while option 2 does have a structure and some syntax to learn, once you're familiar with the principles, you'll still want to learn graphics by doing it. 
:::

There are other graphics systems in R (namely, `lattice`, plus some web-based rendering engines) that you could explore, but it's far more important that you know how to functionally create plots in R and/or SAS. I don't recommend you try to become proficient in all of them. Pick one (two at most) and get to know that, then google for the rest.


Before we delve into the grammar of graphics, let's motivate the philosophy using a simple task. Suppose we want to create a pie chart using some data. [Pie charts are terrible, and we've known it for 100 years](http://www.jstor.org/stable/2276829), so in the interests of showing that we know that pie charts are awful, we'll also create a stacked bar chart, which is the most commonly promoted alternative to a pie chart. We'll talk about what makes pie charts terrible at the end of this module. 

<details><summary>R base graphics example</summary>
```{r, message = F}
# Setup the data
library(tidyverse)
poke <- read_csv("data/pokemon_ascii.csv", na = '.') %>%
  mutate(generation = factor(generation))
```

Let's start with what we want: for each generation, we want the total number of pokemon. 

To get a pie chart, we want that information mapped to a circle, with each generation represented by an angle whose size is proportional to the number of pokemon in that generation.

```{r}
# Create summary of pokemon by type
tmp <- poke %>%
  group_by(generation) %>%
  count() 

pie(tmp$n, labels = tmp$generation)

# with(., <base command>) let you use the pipe easily with a base R command
# that is otherwise not pipe friendly, e.g. 
# with(tmp, pie(n, labels = generation))
```

We could alternately make a bar chart and stack the bars on top of each other. This also shows proportion (section vs. total) but does so in a linear fashion.

```{r}
# Create summary of pokemon by type
tmp <- poke %>%
  group_by(generation) %>%
  count() 

# Matrix is necessary for a stacked bar chart
matrix(tmp$n, nrow = 8, ncol = 1, dimnames = list(tmp$generation)) %>%
barplot(beside = F, legend.text = T, main = "Generations of Pokemon")
```
</details>

<details><summary>R ggplot2 graphics</summary>
In ggplot2, we start by specifying which variables we want to be mapped to which features of the data. 

In a pie or stacked bar chart, we don't care about the x coordinate - the whole chart is centered at (0,0) or is contained in a single "stack". So it's easiest to specify our x variable as a constant, "". We care about the fill of the slices, though - we want each generation to have a different fill color, so we specify generation as our fill variable. 

Then, we want to summarize our data by the number of objects in each category - this is basically a stacked bar chart. Any variables specified in the plot statement are used to implicitly calculate the statistical summary we want -- that is, to count the rows (so if we had multiple x variables, the summary would be computed for both the x and fill variables). ggplot is smart enough to know that when we use `geom_bar`, we generally want the y variable to be the count, so we can get away with leaving that part out. We just have to specify that we want the bars to be stacked on top of one another (instead of next to each other, "dodge").

```{r}
ggplot(aes(x = "", fill = generation), data = poke) + 
  geom_bar(position = "stack") 
```

If we want a pie chart, we can get one very easily - we transform the coordinate plane from cartesian coordinates to polar coordinates. We specify that we want angle to correspond to the "y" coordinate, and that we want to start at $\theta = 0$. 

```{r, message = F}
ggplot(aes(x = "", fill = generation), data = poke) + 
  geom_bar(position = "stack") + 
  coord_polar("y", start = 0)
```

Notice how the syntax and arguments to the functions didn't change much between the bar chart and the pie chart? That's because the `ggplot` package uses what's called the **grammar of graphics**, which is a way to describe plots based on the underlying mathematical relationships between data and plotted objects. In base R and SAS, different types of plots will have different syntax, arguments, etc., but in ggplot2, the arguments are consistently named, and for plots which require similar transformations and summary observations, it's very easy to switch between plot types by changing one word or adding one transformation.
</details>

<details><summary>SAS Examples</summary>
Original SAS graphics engine
```{sashtml gchart-pie, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

/* This step creates a constant variable in the data frame, 
so that all generations can be stacked in one bar */
DATA poketmp;
SET classdat.poke;
i = 1;
RUN;

PROC GCHART data=poketmp;
pie generation / other = 0;
RUN;
  
PROC GCHART data=poketmp;
VBAR i / SUBGROUP = generation;
RUN;

QUIT; 
/* Note that if you forget the quit statement using SASMarkdown, things dont work well */
```

ODS Graphics    
Note: This is a terrible example in SAS because there isn't an easy way to create a pie chart^[It's not often you'll find me approving of SAS graphics, but making it hard to make pie charts is definitely a point in SAS's favor]. We have to resort to using SAS Graph Template Language. 

```{sashtml ods-pie, error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

DATA poketmp;
SET classdat.poke;
i = 1;
RUN;

/* Define a pie chart template */
PROC TEMPLATE;
DEFINE STATGRAPH WORK.simplepie;
  BEGINGRAPH;
    LAYOUT REGION;
      PIECHART category=generation;
    ENDLAYOUT;
  ENDGRAPH;
END;
RUN;

/* Make the pie chart */ 
PROC SGRENDER data=classdat.poke template=WORK.simplepie;
RUN;

/* Use SGPLOT to make a stacked bar chart */
PROC SGPLOT data=poketmp;
VBAR i / GROUP = generation;
RUN;
```
As in base R, the syntax between the two types of charts is different, even though the underlying operations required to make the plots are very similar.  This is one example of why I don't agree with the assertion that ODS graphics is like ggplot2 syntax - the functionality may be similar, but the structure is not. 
</details>

If only because it provides us with a place to start (because otherwise, we would just work through a graph gallery or two, and that's boring), we'll talk first about the general idea behind the grammar of graphics. For each concept, I'll provide you first with the ggplot grammar of graphics code, and then, where it is possible to replicate the chart easily in base R or SAS ODS graphics, I will provide code for that as well - so that you can compare the approaches, but also so that you get a sense for what is easy and what is possible in each plotting system. 


## The Grammar of Graphics

<!-- A basic sentence has a subject and a predicate (usually, this contains a verb), but of course, there are infinintely many ways to combine and expand on a single sentence. The structure of the sentence describes how the subject relates to the predicate, with clauses and so on that modify the original meaning.  -->

<!-- The grammar of graphics is designed as an object-oriented graphics system. That is, the idea is that there are certain objects that communicate with each other. Each object does a few things well, and the intelligence is in the system, not in the objects themselves. This design principle means that objects can be repurposed for many things (because each object is relatively simple and modular).  -->

In the grammar of graphics, a plot consists of several mostly independent specifications:

1. **aesthetics** - links between data variables and graphical features (position, color, shape, size)
2. **layers** - geometric elements (points, lines, rectangles, text, ...) 
3. **transformations** - transformations specify a functional link between the data and the displayed information (identity, count, bins, density, regression). Transformations act on the variables. 
4. **scales** - scales map values in data space to values in the aesthetic space. Scales change the coordinate space of an aesthetic, but don't change the underlying value (so the change is at the visual level, not the mathematical level). 
5. **coordinate system** - e.g. polar or cartesian
6. **facetting** - facets allow you to split plots by other variables to produce many sub-plots.
7. **theme** - formatting items, such as background color, fonts, margins...

We can contrast this with other plotting systems (e.g. Base R), where transformations and scales must be handled manually, there may be separate plotting systems for different coordinate systems, etc. 

Functionally, the biggest difference between the two systems is that in the grammar of graphics system (as implemented in ggplot2), we work with a full tabular dataset. So like the rest of the tidyverse, ggplot2 will allow you to reference bare column names as if they were variables, so long as you've passed in the data set to the `data =` argument.^[This can sometimes be a pain, though, depending on the set up, because you may end up with labels that are repeated many, many times. As with any system, you just have to make sure you're formatting your data consistent with the underlying philosophy.] 

<details><summary>Let's get the data set up in both SAS and R</summary>
```{r}
if (!"classdata" %in% installed.packages()) devtools::install_github("heike/classdata") 
# A package of data sets which are useful for class demonstrations
library(classdata)
data(happy) # you'll use this for try it out sections
data(fbi)

fbiwide <- fbi %>%
  select(-Violent.crime) %>%
  pivot_wider(names_from = Type, values_from = Count) %>%
  # Rename variables
  rename(Murder = Murder.and.nonnegligent.Manslaughter, 
         Assault = Aggravated.assault, 
         Larceny = Larceny.theft, 
         Auto.theft = Motor.vehicle.theft) %>%
  mutate(Rape = as.numeric(Rape))

# Write a csv out to a file to read into sas
write_csv(happy, "data/happy.csv", na = ".")
write_csv(fbi, "data/fbi.csv", na = ".")
write_csv(fbiwide, "data/fbiwide.csv", na = ".")
```

```{sas happydata, error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

PROC IMPORT datafile = "data/happy.csv" out=classdat.happy
    DBMS = CSV 
    REPLACE; 
    GETNAMES = YES;
    GUESSINGROWS = 5000;
RUN;

PROC IMPORT datafile = "data/fbi.csv" out=classdat.fbi
    DBMS = CSV 
    REPLACE; 
    GETNAMES = YES;
    GUESSINGROWS = 5000;
RUN;

PROC IMPORT datafile = "data/fbiwide.csv" out=classdat.fbiwide
    DBMS = CSV 
    REPLACE; 
    GETNAMES = YES;
    GUESSINGROWS = 2000;
RUN;
```
</details>

### Demonstration: Aesthetic Mappings and Basic Plots

A basic scatterplot is a combination of an aesthetic mapping for x and y (position), combined with the specification that the geometric object to be displayed is a point. Without any of the components (x, y, geom_point) you don't have a scatterplot. 
```{r}
ggplot(fbiwide, aes(x = Burglary, y = Murder)) + geom_point()
```

<details><summary>Base R</summary>
```{r, error = T}
plot(x = Burglary, y = Murder, data = fbiwide) # this doesn't work

plot(x = fbiwide$Burglary, y = fbiwide$Murder) # you can use numeric vector arguments


# another option is to use formula notation, that is, y ~ x. 
# If you use formula notation, you can pass in a data frame using the 
# data argument and R will interpret things correctly
plot(Murder ~ Assault, data = fbiwide) 
```
</details>

<details><summary>SAS ODS Graphics</summary>
The workhorse of the ODS graphics engine is SGPLOT. 
```{sashtml basic-sgplot-scatterplot, error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

PROC SGPLOT data=classdat.fbiwide;
SCATTER x = Burglary y = Murder;
RUN;
```
</details>

We can add a title to the plot
```{r}
ggplot(fbiwide, aes(x = Murder, y = Assault)) + geom_point() + 
  ggtitle("Murders and Assaults")
```
You can also add labels using `xlab()` and `ylab()`. We'll talk more about how to make fine-grained modifications of axis scales later, but the shorthand commands for changing the title and labels are convenient.

<details><summary>Base R</summary>
```{r}
plot(Murder ~ Assault, data = fbiwide) 
title("Murders and Assaults")
```
</details>
<details><summary>SAS ODS Graphics</summary>
```{sashtml, error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

PROC SGPLOT data=classdat.fbiwide;
TITLE "Murders and Assaults";
SCATTER x = Assault y = Murder;
RUN;
```
</details>

We can also modify the appearance of the plotted objects
```{r}
ggplot(fbiwide, aes(x = Population, y = Assault)) +
  geom_point(color = "blue", alpha = .5)
```
Alpha blending, or transparency, allows us to see the structure in over-plotted (crowded) charts. Here, I've specified that the points should have 50% opacity.

Another point to note: inside the `aes()` function, variables are mapped to geometric object characteristics, but outside, those same parameters can be mapped to **constant values**. If something is inside aes(), it should be a variable. 

<details><summary>Base R</summary>
Base R doesn't support alpha blending by default, so we have to load the `scales` package in order to get that functionality.
```{r}
library(scales)
# Using constant alpha:
plot(Assault ~ Population, 
     col = alpha("blue", .5),
     pch = 16,
     data = fbiwide) 
```
</details>
<details><summary>SAS ODS Graphics</summary>
```{sashtml, error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

PROC SGPLOT data=classdat.fbiwide;
SCATTER x = Population y = Assault /
  markerattrs=(size=8pt symbol=circlefilled color="blue") 
  transparency=0.5;
RUN;
```
</details>

If we want to get fancy, we can map other **variables** to aesthetics like color, size, etc. We could explore the relationship between Population and Assault, but we'd expect that over time, observations from each state would be closely related. We could explore that by coloring each point by state (note, this doesn't allow us to really see which states belong to which points so much as it visually associates connected points.)

```{r}
ggplot(fbiwide, aes(x = Population, y = Assault, color = Abb)) + geom_point()
```

<details><summary>Base R variable mapping</summary>
In base R, you can also create scatterplots that have different plot aesthetics, but we have to get a bit more hands-on than we did with ggplot2.
```{r, error = T}
# This doesn't work because the values in Abb aren't actually colors
# and plot() doesn't handle the mapping between color and abbreviation for us
plot(Assault ~ Population, col = Abb, data = fbiwide) 
```

We have to specify the values of color manually for each point that we want to plot - essentially, where ggplot2 handled the scale for us, now we have to manually specify it ourselves. We could specify a legend, but in this particular case it's unlikely to be that useful to us because the colors aren't allowing us to identify the lines, they're just differentiating the lines from other lines.

```{r}
# We need a vector of colors equal to the number of abbreviations we have
state_colors <- rainbow(length(unique(fbiwide$Abb)))

# then we have to figure out which color goes with which abbreviation
fbiwide$Abb_factor <- factor(fbiwide$Abb)
fbiwide$state_color <- state_colors[fbiwide$Abb_factor]

plot(Assault ~ Population, col = state_color, data = fbiwide)
```
You can use `?points` to get information on all of the graphical parameters for points.
</details>
<details><summary>SAS ODS Graphics variable mapping</summary>
```{sashtml, error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

PROC SGPLOT data=classdat.fbiwide;
SCATTER x = Population y = Assault /
  markerattrs=(size=8pt symbol=circlefilled) 
  group = Abb; /* maps to point color by default */
RUN;
  
PROC SGPLOT data=classdat.fbiwide NOAUTOLEGEND; /* dont generate a legend */
SCATTER x = Population y = Assault /
  markercharattrs=(size=8) 
  markerchar = Abb /* specify marker character variable */
    group = Abb
  ; 
RUN;
  
```
</details>

A better way to graphically examine this hypothesis (the patterns in the data are clusters of each state's points) might be to change the geometric object - we could use lines instead of points to show this data. In that case, we'd want to show separate lines (groups) for each state.

```{r}
ggplot(fbiwide, aes(x = Population, y = Assault, group = Abb)) + geom_line()
```

Or, we could be lazy and leave color specified; which will have the same effect. Color and most other aesthetics implicitly group the data.

```{r}
ggplot(fbiwide, aes(x = Population, y = Assault, color = Abb)) + geom_line()
```

One of the best parts of ggplot is that you can get away with only changing one or two things and end up with a totally different plot. 


<details><summary>Base R line plots</summary>

If we want to make a line plot, we can do it one of two ways: we can use a for loop to plot each state's line separately, subsetting the data each time, or, we can transform the data to wide format and plot that using the `matplot` function

```{r}
# For loop method
plot(Assault ~ Population, pch = NA, data = fbiwide) # generate a blank plot
for (i in unique(fbiwide$Abb)) {
  subdata <- filter(fbiwide, Abb == i)
  lines(Assault ~ Population, data = subdata) # add the line to the plot
}
```

```{r}
# ggplot2 code
# ggplot(fbiwide, aes(x = Population, y = Assault, group = Abb)) + geom_line()

# matplot method
subdata <- fbiwide %>% 
  select(Assault, Population, Year, Abb) # get cols we need

# Matrix of x values - Population
popdat <- pivot_wider(subdata, id_cols = Year, names_from = Abb, values_from = Population) %>%
  arrange(Year) %>%
  select(-Year)
# Matrix of y values - Assaults
assaultdat <- pivot_wider(subdata, id_cols = Year, names_from = Abb, values_from = Assault) %>%
  arrange(Year) %>%
  select(-Year)

matplot(popdat, assaultdat, type = "l") 
# by default, matplot uses 5 different colors and linetypes
# so that you can differentiate the lines in different columns
```

If we want to add color in and have it mean something specific, it's relatively straightforward because we already defined a new column in fbiwide that has state colors.

```{r}
plot(Assault ~ Population, pch = NA, data = fbiwide) # generate a blank plot
for (i in unique(fbiwide$Abb)) {
  subdata <- filter(fbiwide, Abb == i)
  lines(Assault ~ Population, col = state_color, data = subdata) # add the line to the plot
}
```
</details>
<details><summary>SAS ODS line plots</summary>
```{sashtml, error = T, collectcode = T}

libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";
PROC SGPLOT data=classdat.fbiwide NOAUTOLEGEND;
SERIES x = Population y = Assault /
  lineattrs=(pattern=solid)
  group = Abb; /* maps to color by default */
RUN;

```
[SAS Line attributes and patterns options](https://documentation.sas.com/?docsetId=grstatproc&docsetTarget=p0er4dg9tojp05n1sf7maeqdz1d8.htm&docsetVersion=9.4&locale=en)
</details>

So we can color our points (or lines) by a categorical variable, but that's not all! We can also map numeric variables to aesthetics!

There are perhaps too many data points in the FBI data to effectively show size variation, so let's temporarily switch to pokemon and examine the relationship between attack and special attack points. Let's also map alpha to weight, so that lighter points correspond to lighter pokemon.

```{r}
poke %>% 
  ggplot(aes(x = attack, y = sp_attack, alpha = weight_kg)) + 
  geom_point()
```

<details><summary>See more numeric scales</summary>
We could get fancier still and map the pokemon's height to size. 

```{r}
poke %>% 
  ggplot(aes(x = attack, y = sp_attack, size = height_m, alpha = weight_kg)) + 
  geom_point()
```
Note that ggplot2 will create separate legends for size and height by default. If we map size and alpha to the same variable, however, it will automatically combine the legends. 

```{r}
poke %>% 
  ggplot(aes(x = attack, y = sp_attack, size = weight_kg, alpha = weight_kg)) + 
  geom_point()
```
</details>

<details><summary>Base R legends, numeric variables, and aesthetics</summary>
If we use `?points` and find out that the size parameter is `cex` in base R, we might think something like this would work:
```{r}
plot(sp_attack ~ attack, cex = weight_kg, data = poke) 
# cex controls the point size argument
# note the lack of a legend
# Also, we have points that are *way* too big.
```

But, remember, in base graphics, we have to do the transformations ourselves. After some tinkering, I came up with this.
```{r}
plot(sp_attack ~ attack, cex = 0.5 + weight_kg/1000*3, data = poke) 
# we have to do the scale transformation ourselves
# but there's no legend...
```

We also have to make the legend ourselves. Sigh.

```{r}
plot(sp_attack ~ attack, cex = 0.5 + weight_kg/1000*3, data = poke) 
legend("topleft", 
       legend = c(250, 500, 750, 1000), # labels
       pch = 1, # must specify point shape (pch = point character)
       pt.cex = 0.5 + c(250, 500, 750, 1000)/1000 * 3) # must specify cex value 
                                                       # for points specifically
```


If we want to map a value to alpha, we have to make our own scale again... but it may be easier to just make a transformation function that we can pass stuff into. That way we can create the legend and the data transformation using the same function (and if we want to change the transformation, it will be much easier to do so if we only have to change things in one place). 
```{r}
library(scales)

# Define the transformation
wt_trans_alpha <- function(x) {
  # rescale function is from the scales package
  trans_x <- rescale(
    x = x, 
    to = c(.2, 1), # don't go to 0 because then we can't see the points
    from = range(poke$weight_kg, na.rm = T) # input domain
  ) 
  
  # alpha values have to be between 0 and 1, so we need to make sure to 
  # truncate the scale
  trans_x %>%
    pmin(., 1) %>% # don't go any higher than 1
    pmax(., 0)     # don't go any lower than 0
}
  
range(poke$weight_kg, na.rm = T) # get the range

# Make the legend variables
leg_label <- seq(0, 1000, length.out = 5) # cut weight range into 5 
leg_value <- alpha("black", alpha = wt_trans_alpha(leg_label))

select(poke, attack, sp_attack, weight_kg) %>% 
  mutate(alpha = wt_trans_alpha(weight_kg),
         color = alpha("black", alpha = alpha)) %>%
  plot(sp_attack ~ attack, col = color, pch = 16, data = .)

legend("topleft", 
       title = "Weight (kg)", 
       legend = leg_label, # labels
       pch = 16, # must specify point shape (pch = point character)
       col = leg_value) # must specify point color using alpha() function
```

If we want to do color and size simultaneously, we have to define another transformation, but we can re-use the same legend.

```{r}
wt_trans_size <- function(x) {
  trans_x <- rescale(
    x = x, 
    to = c(0.5, 3), 
    from = range(poke$weight_kg, na.rm = T) # input domain
  ) 
  
  # cex values have to be >0, so we need to make sure to truncate the scale
  trans_x %>%
    pmax(., 0)     # don't go any lower than 0
}
  
range(poke$weight_kg, na.rm = T) # get the range

# Make the legend variables
leg_label <- seq(0, 1000, length.out = 5) # cut weight range into 5 
leg_color <- alpha("black", alpha = wt_trans_alpha(leg_label))
leg_size <- wt_trans_size(leg_label)

select(poke, attack, sp_attack, weight_kg) %>% 
  mutate(alpha = wt_trans_alpha(weight_kg),
         color = alpha("black", alpha = alpha),
         size = wt_trans_size(weight_kg)) %>%
  plot(sp_attack ~ attack, col = color, cex = size, pch = 16, data = .)

legend("topleft", 
       title = "Weight (kg)", 
       legend = leg_label, # labels
       pch = 16, # must specify point shape (pch = point character)
       col = leg_color,
       pt.cex = leg_size)
```
</details>

<details><summary>SAS ODS graphics and numeric variable transformations</summary>
In order to change point size to show a different variable value, we have to use BUBBLE instead of SCATTER.

```{sashtml, error = T, collectcode = T}

libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";
PROC SGPLOT data=classdat.poke;
BUBBLE x = attack y = sp_attack size = weight_kg /
  BRADIUSMAX=10 BRADIUSMIN =2
  transparency=0.5;
RUN;

```

As best as I can tell, there's no similar plot option that would let us map a variable to transparency. There are attribute maps, but the options are discrete (which weight is not) or range (which would let us define ranges to map to a single value), and they don't appear to support transparency. In theory, I think we could go to SAS Template graph language, but ... ugh. To be honest, at this point, I'd move the data into R and graph things there.
</details>

#### Try it out {.tryitout}

Explore the happy dataset, which is a selection of variables from the general social survey (`?happy`) related to happiness. What associations can you find between the variables? Can you use what you know about the graphics help resources to figure out how to create new plot types?

### Syntax and General Structure: Layers

One of the main advantages of ggplot2 is that the syntax is basically consistent across very different types of plots. In base R and SAS, this is not the case - you have to look up the available options for each different plot type. In ggplot2, I might have to look up what the aesthetic names are for a specific geom, but I can guess most of the time. So let's look a bit more into what ggplot2's approach to graph specification is and what it allows us to do.

You're fairly used to the syntax of the pipe by now; but ggplot works on a slightly different (but similar) concept that we've used implicitly up until this point. There is the intial plot statement, `ggplot()`, and successive layers are added using `+`. 

You can specify a dataset and aesthetic variables in the `ggplot()` statement (which is what we'll usually do), but you can also have a completely blank `ggplot()` statement and specify your aesthetic mappings and datasets for each layer separately. This approach is more useful when you start creating complex plots, because you may need to plot summary information and raw data, or e.g. separate tables with city information, geographic boundaries, and rivers, all of which need to be represented in the same map.

Let's play with maps for a little bit, because they provide a good example of how ggplot layers work. This is likely to be an extended, meandering example. 

```{r dataprep08, include = F, eval = F}

worship <- read_csv("data/All_Places_Of_Worship.csv", guess_max = 5000) %>%
  select(EIN, NAME, STREET, CITY, STATE, ZIP, AFFILIATION, FOUNDATION, long = X, lat = Y)

write_csv(worship, "data/Places_of_Worship.csv", na = '.')
```
```{r, eval = F}
pkgs <- installed.packages()
# Install any of the packages that you don't have
install.packages(setdiff(c("ggthemes", "mapdata", "maps"), pkgs))
```
<details><summary>Initial data set up and exploration</summary>
```{r}
library(ggplot2)
library(maps)
library(mapdata)
library(ggthemes) # theme_map

# Create a data frame of the outline of the US
us_map <- map_data("usa")
states <- map_data("state")

# Read in some data about places of worship in the US (compiled from IRS filings)
worship <- read_csv("data/Places_of_Worship.csv", guess_max = 5000)
```

Let's look at the map data first:
```{r}
head(us_map)
```
It looks like we have longitude and latitude, group, and point order. What does group mean? 
```{r}
select(us_map, group, region) %>% unique()
```
The regions are all islands, and group is a number that corresponds to each region. This is important because if we plot polygons, we have to worry about what to do when we jump from one "island" to another (sometimes, regions might be contiguous areas, such as states or zip codes). As long as we pass in a group argument (so `group = group`) we should avoid most of the complications of plotting spatial data. 

The state data is similarly structured:
```{r}
head(states)
```

Now, let's look at our worship place data. The full dataset was more extensive (and much larger), so I've reduced the number of columns so that I'm able to put it on GitHub. 
```{r}
head(worship)
```

We have tax numbers, entity names, mailing address, affiliation, foundation, and latitude/longitude. [A codebook for the affiliation and foundation information is available from the IRS](https://www.irs.gov/pub/irs-soi/eo_info.pdf). 

While I'm tempted to play around with the names of the organizations a bit (for instance, how many different "First XXX Church" exist in the country?) it's probably for the best that we keep moving.
</details>

<details><summary>Basic map geoms</summary>
Let's try plotting this out. Maybe we can start with just plotting the outline using `geom_line`?
```{r}
ggplot() + 
  geom_line(aes(x = long, y = lat, group = group), data = us_map)
```

A line geom is plotted sequentially w.r.t. the magnitude of x. That doesn't really work for us - we want x and y to be plotted in order of the observations. To do that, we need `geom_path`. 
```{r}
ggplot() + 
  geom_path(aes(x = long, y = lat, group = group), data = us_map)
```
Not too bad. What if we want to fill in the country, so that it looks different from the background? To do that, we'll need `geom_polygon`

```{r}
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = us_map)

# Let's make the fill white.
ggplot() + geom_polygon(aes(x = long, y = lat, group = group), data = us_map,
                        fill = "white", color = "black")

# What happens if we get rid of group?
ggplot() + geom_polygon(aes(x = long, y = lat), data = us_map,
                        fill = "white", color = "black")
```
</details>

<details><summary>Let's spice this up and add more layers!</summary>
Let's plot points for the location of every place of worship (according to the IRS) in the US. First, we can plot the points by themselves:

```{r}
ggplot() + geom_point(aes(x = long, y = lat), data = worship)
```

Wow. One problem we're going to have is Alaska. Let's go ahead and remove those points now - we could make the map more complicated, but it won't add much to the overall value of the example. 

```{r}
worship_full <- worship
worship <- filter(worship, STATE != "AK")

ggplot() + geom_point(aes(x = long, y = lat), data = worship, size = .1, alpha = .1)
```

At this point it's worth remembering the [population density issue](https://xkcd.com/1138/), but let's keep moving.

Suppose we want to add our church data to our national map. We can plot our US map first, then add the points on top of it. 
```{r}
ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = us_map,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), data = worship, size = .1, alpha = .1)
```

It might help to add some state information in too. We could plot states on top of the full US map, but (hopefully) the states tile the national map, so it's better just to plot the states. 

```{r}
ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), data = worship, size = .1, alpha = .1)
```

It might be helpful to figure out where there are major cities - some of them are obvious, but I suspect there are certain areas where there are more churches per capita - I've driven through enough small towns in the South, and I have relatives in NW Iowa.

The `us.cities` database has all US cities over 40k people, plus state capitals of any size. 


```{r}
large_cities <- us.cities %>%
  filter(country.etc != "AK") %>%
  filter(country.etc != "HI") %>%
  filter(pop > 100000 | capital == 2) %>%
  mutate(type = ifelse(capital == 2, "State Capital", "City"))


layer_map <- ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), data = worship, size = .1, alpha = .1) + 
  geom_point(aes(x = long, y = lat, color = type, size = pop), data = large_cities,
             shape = 1) + 
  # put legend below the map
  theme(legend.position = "bottom")
layer_map
```

Just to examine the South in a little more depth... I wanted to know a bit more about where my grandma lives (because there are churches everywhere, or so it seems). 
```{r}
layer_map + 
  # coord_fixed maintains the proper aspect ratio
  coord_fixed(xlim = c(-83.5, -78.5), ylim = c(31, 36))
```
Just for context, the northwest corner of South Carolina ("upstate" to the locals) isn't that dense, population wise, but it is certainly rich in churches. It's nice to confirm my childhood memories with data.
</details>

#### Try it out {- .tryitout}

Pick a few denominations or religious organizations (or even just a more generic pattern, like names starting with ST) and do some rough string matching. What spatial patterns do you detect? (This won't be totally accurate, and doesn't need to be, in order to paint a picture of the country's religious affiliations and congregations)

<details><summary>One solution</summary>
First, let's do a bit of string processing.
```{r}
common_words <- worship %>% 
  pull(NAME) %>%
  str_split("[- &/%]", simplify = T) %>% 
  as.character() %>%
  table() %>%
  sort(decreasing = TRUE)
common_words[1:40]
```
Let's work with the following denominations: BAPTIST, LUTHERAN, METHODIST, PRESBYTERIAN, EPISCOPAL - I've left out CHRISTIAN, ASSEMBLY (because it could be ASSEMBLY OF GOD or a more generic term for a congreggation), and TEMPLE because it could refer to any number of religions - Jewish, Hindu, etc. This will give us a very rough categorization (e.g. there are Methodist Episcopal churches which will be counted as one and not the other, and UMC is a common abbreviation for United Methodist Church but won't be counted as one this way). 

```{r}
worship <- worship %>%
  mutate(type = str_extract(NAME, "(BAPTIST|LUTHERAN|METHODIST|PRESBYTERIAN|EPISCOPAL)"))

denom_churches = worship %>% 
  filter(!is.na(type))

ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat, color = type), 
             data = denom_churches, size = .1, alpha = .1) + 
  # We want to see the legend, so we have to tell ggplot to override the aesthetics
  guides(color = guide_legend(override.aes = list(size = 2, alpha = 1))) + 
  theme(legend.position = "bottom") + 
  theme_map()
```

We could also look for other keywords: 
```{r}
bahai <- worship %>% filter(str_detect(NAME, "BAHAI"))

ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), 
             data = bahai, alpha = .1) + 
  theme_map() + 
  ggtitle("Baha'i Organizations")
```

```{r}
zen <- worship %>% filter(str_detect(NAME, "ZEN"))

ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), 
             data = zen, alpha = .1) + 
  theme_map() + 
  ggtitle("Zen Organizations")
```


```{r}
friends <- worship %>% filter(str_detect(NAME, "(MEETING OF FRIENDS)|(FRIENDS MEETING)"))

ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), 
             data = friends, alpha = .1) + 
  theme_map() + 
  ggtitle("Quaker Religious Organizations")
```

```{r, include = F}
umc <- worship %>% filter(str_detect(NAME, "( UMC )|(UNITED METHODIST)|(WESLEY FOUNDATION)"))

ggplot()  + 
  geom_polygon(aes(x = long, y = lat, group = group), data = states,
               fill = "white", color = "grey") + 
  geom_point(aes(x = long, y = lat), 
             data = umc, alpha = .1) + 
  theme_map() + 
  ggtitle("United Methodist Organizations")
```

<details>


```{r, include = F, message = F, error = T}
# Clean up a bit
objs <- ls()
rm_objs <- setdiff(objs, c("fbi", "fbiwide", "happy", "poke", "worship_full"))
rm(list = rm_objs)
rm(list = c("objs", "rm_objs"))
```


### Statistics and Different Types of Plots

At this point, we've primarily looked at charts which have two continuous variables - scatter plots, and line plots. There are a number of situations where these types of charts are inadequate. For one thing, we might want to only look at the distribution of a single variable. Or, we might want to look at how a continuous response variable changes when the level of a categorical variable changes. In this section, we'll hit the most common types of plots, but there are almost infinite variations. Sites like [the Data Viz Catalogue](https://datavizcatalogue.com/search.html) can be useful if you're trying to accomplish a specific task and want to know what type of plot to use. 

#### Box Plots
Let's look at the relative frequency of different types of crimes, putting all states on an equal scale of 100k residents so that the numbers are comparable and also meaningful. 

```{r}
fbi %>%
  filter(Year == max(Year)) %>%
  mutate(per_100k = Count/Population*100000) %>%
  # make nicer names
  mutate(crime = str_replace_all(Type, c("Murder.*" = "Murder", 
                                         ".*[Rr]ape" = "Rape", 
                                         ".*vehicle.theft" = "Vehicle Theft",
                                         "Larceny.theft" = "Theft",
                                         ".*assault" = "Assault"))) %>%
  ggplot(aes(x = crime, y = per_100k)) + 
  geom_boxplot() + 
  ggtitle(paste("Crimes per 100k people,", max(fbi$Year)))
```

We might want to sort crimes by incidence level, because it makes the plot prettier and also gives us an ordered list of crimes in descending frequency.

```{r}
tmp <- fbi %>%
  filter(Year == max(Year)) %>%
  mutate(per_100k = Count/Population*100000) %>%
  # make nicer names
  mutate(crime = str_replace_all(as.character(Type), 
                                 c("Murder.*" = "Murder", 
                                   ".*[Rr]ape" = "Rape", 
                                   ".*vehicle.theft" = "GTA",
                                   "Larceny.theft" = "Theft",
                                   ".*assault" = "Assault")))
tmpsum <- tmp %>%
  group_by(crime) %>%
  summarize(ref = mean(per_100k, na.rm = T)) %>%
  ungroup() %>%
  arrange(desc(ref))

tmp <- tmp %>%
  mutate(crime = factor(crime, levels = tmpsum$crime))

tmp %>%
  ggplot(aes(x = crime, y = per_100k, color = Violent.crime)) + 
  geom_boxplot() + 
  ggtitle(paste("Crimes per 100k people,", max(fbi$Year)))
```
<details><summary>Boxplots in base R</summary>
```{r}
boxplot(per_100k~crime, data = tmp)
```
</details>
<details><summary>Boxplots in SAS</summary>
```{sashtml error = T, collectcode = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

DATA WORK.fbitmp;
SET classdat.fbi;
per_100k = Count/Population*100000;
RUN;

PROC SGPLOT data=fbitmp;
hbox per_100k / group = Type;
RUN;
```
</details>

#### Bar Charts

A bar chart is a plot with a categorical variable on one axis and a summary statistic on the other (usually, this is a count). Note that a bar chart is NOT the same as a histogram (a histogram looks very similar, but has a binned numeric variable on one axis and counts on the other). Geometrically, bar charts are rectangles; typically each rectangle will have equal width and variable height.

```{r}
ggplot(poke, aes(x = generation)) + geom_bar()
```

As with other types of charts, we can add more information by adding aesthetic mappings:
```{r}
poke %>%
  mutate(status = factor(
    status, 
    levels = c("Normal", "Mythical", 
               "Sub Legendary", "Legendary") %>%
      rev() # ggplot orders things backwards of how you'd want them 
  )) %>%
ggplot(aes(x = generation, fill = status)) + 
  geom_bar() + 
  # The default colors are awful for colorblind people (like me), so lets fix it
  scale_fill_brewer(palette = "Paired")
```
We can get different visual information from the same data, if we switch which variable is on the axis and which is the fill variable
```{r}
poke %>%
  mutate(status = factor(
    status, 
    levels = c("Normal", "Mythical", 
               "Sub Legendary", "Legendary") %>%
      rev() # ggplot orders things backwards of how you'd want them 
  )) %>%
ggplot(aes(x = status, fill = generation)) + 
  geom_bar(position = "dodge")
```

We can also get useful information by changing the statistic: what if we use the proportion of responses in each category instead of the raw count? To do this, as far as I know, we have to do at least a little bit of preprocessing. 

```{r}
poke %>%
  mutate(status = factor(
    status, 
    levels = c("Normal", "Mythical", 
               "Sub Legendary", "Legendary") %>%
      rev() # ggplot orders things backwards of how you'd want them 
  )) %>%
  group_by()
ggplot(aes(x = status, fill = generation)) + 
  stat_count(aes(y = ..count..)) + 
  # geom_bar(aes(y = ..prop.., fill = generation)) + 
  # The default colors are awful for colorblind people (like me), so lets fix it
  scale_fill_brewer(palette = "Paired")
```


### Small Multiples Plots

Sometimes, you want to show separate plots for each level of a factor (or a combination of factors). Often, this happens when you expect the plot's gross shape to change - something relatively obvious. Other times, though, you might just have too much data and need to break it down somehow. 

These sub-plots within a plot are called small multiples, or facets, or panel plots, depending on the software or discipline. 




## Good charts

![Good charts are important](https://imgs.xkcd.com/comics/coronavirus_charts.png)



## References

### R graphics

- [ggplot2 cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)
- [ggplot2 reference guide](https://ggplot2.tidyverse.org/reference/)

- [R graph cookbook](https://r-graphics.org/)

- [Data Visualization in R](https://ramnathv.github.io/pycon2014-r/visualize/base_graphics.html) (\@ramnathv)

### SAS graphics
- [SGPLOT cheat sheet](https://support.sas.com/rnd/app/ODSGraphics/TipSheet_SGPLOT.pdf)
- [Replicating ggplot2 in SAS SGPLOT](https://blogs.sas.com/content/graphicallyspeaking/2013/12/01/r-u-graphing-with-sas/)

- [ODS Graphics in SAS](https://support.sas.com/resources/papers/76822_ODSGraph2011.pdf)

- [Periodic Table of SAS ODS graphics](https://blogs.sas.com/content/sastraining/2018/04/19/a-periodic-table-of-sas-ods-graphics/) [(code and actual graphic)](http://robslink.com/SAS/democd97/periodic_table_ods_graphs_info.htm)

- [Data Visualization Style Guidelines](https://medium.com/nightingale/style-guidelines-92ebe166addc)

### Types of Charts

- The [Data Vis Project](https://datavizproject.com/)
- [Data Visualization Catalogue](https://datavizcatalogue.com/)
- [The pros and cons of chart taxonomies](https://medium.com/nightingale/the-pros-and-cons-of-chart-taxonomies-5c8e094578c4)

### Other Graphics packages

- 

- [plotnine](https://plotnine.readthedocs.io/en/stable/index.html) in python (ggplot2 clone)
- [matplotlib](https://matplotlib.org/) in python

- [Tableau](https://www.tableau.com/) - student licenses are free

- [d3](https://www.d3-graph-gallery.com/) - javascript graphics

### Cool examples
- [Holiday Graphics in SAS](http://www.scsug.org/wp-content/uploads/2018/10/Conway-Oh-There%E2%80%99s-No-Place-Like-SAS-ODS-Graphics-for-the-Holidays.pdf), and, on that same theme, [Captain America](https://communities.sas.com/t5/Graphics-Programming/Fun-with-SAS-ODS-Graphics-3-Cheers-for-the-Red-White-and-Blue/m-p/666607/highlight/true#M20162) in SAS


