{
  "hash": "a36da9e8ba42c69dd943a0d8fadb4fdc",
  "result": {
    "markdown": "# SAS\n\n## Setting up SAS {#setting-up-sas}\n\nIn this class, you have several options for how to use SAS:\n\n1. Install SAS on your machine\n    - <i class=\"fab fa-windows\"></i> See Steve Westerholt, pay a small fee, and he will install SAS on your machine.\n    - <i class=\"fab fa-apple\"></i> Steve Westerholt will help you acquire Parallels desktop (to emulate Windows) and SAS. You'll pay license fees for both products. \n    - <i class=\"fab fa-linux\"></i> Talk with me and I'll help you interface with Steve to get SAS for Linux installed on your system. Steve doesn't support Linux installs, but I can help you get SAS set up if you're using a common distribution like Ubuntu or RedHat/Fedora.\n    \n2. Use SAS University Edition/SAS OnDemand for Academics. Get more information [here](https://www.sas.com/en_us/software/on-demand-for-academics/references/getting-started-with-sas-ondemand-for-academics-studio.html). \n    - Pros - this is free\n    - Cons - limited storage, may cause issues with paths and file upload/download (so it may be hard to ensure your homework assignments are reproducible).\n\n3. ~~Use the Guacamole environment I've set up for the class via HCC. More information will be provided outside the textbook for this option.~~ (This is not an option in Fall 2022)\n    - Pros - free, allows you access to SAS and Rstudio on the same machine (so you can use SASmarkdown seamlessly for homework). You can also use this to test the reproducibility of your assignment.\n    - Cons - This interface is only available for Stat850 - it will not be available after the class concludes. \n\n## Finding Your Way around in SAS {#looking-around-sas}\n\nSAS is another extensively used statistical programming language. It is primarily used for mixed models and in the biostatistics community (for e.g. drug trials). \n\n### Note {- .note}\nSAS looks different on different machines. On Linux, SAS looks like you took a time machine back to the early 1990s. Screenshots from SAS will likely look *very* different on your machine than on mine. I will try to integrate screenshots from other OS's where it matters.^[As I write this in late July 2020, I do not yet have access to a Windows or Mac machine. Sigh. XXX TODO: Get Windows/Mac screenshots XXX. \n\nI still don't have access to a Windows or Mac machine, and it's now April 2021. Sigh.]\n\n### SAS Windows/Panes\n\n![The SAS toolbox has options to create new files, submit code, and more (but I mostly use keyboard shortcuts in the individual windows). This is probably one of the biggest things that's different on Linux...](images/sas/sas_toolbox.png)\n\n![The SAS Log gives you lots of detailed information about how your code ran -- look here for errors and warnings.](images/sas/sas_log_window.png)\n\n![The SAS program editor is where you'll be writing your code. If you want, you can write code in a more advanced text editor and copy/paste it into the log when you're ready to run it.](images/sas/sas_program_editor.png)\n\nThere are two different places your output may end up: if you're using the old output system, you'll get text output in the output pane.\n\n![The old output system output pane.](images/sas/sas_output_old.png)\n\n![The new output system uses HTML and will output to your browser.](images/sas/sas_modern_output.png)\n\n![You can navigate through your results using the results window](images/sas/sas_results_window.png)\n\n![The explorer window lets you access documentation, data, and more](images/sas/sas_explorer_1.png)\n\nIf you click on libraries, you get to this list:\n\n![This area of the SAS explorer shows all of the libraries you have access to.](images/sas/sas_explorer_2.png)\n\n![Clicking on any one library will show you a list of datasets in that library](images/sas/sas_explorer_3.png)\n\n\nYou can then click on a dataset and you will get a spreadsheet-like view. \n\n\n### SAS Modules\n\nSAS is a very large set of programs. In this class, we're primarily working with base SAS (the underlying language and interpreter), SAS/STAT (the statistical procedures, like PROC GLM), and SAS/IML, which is SAS's version of a scripting language. IML allows you to implement your own procedures \"from scratch\". \n\nInitially, we'll primarily focus on SAS/IML, because it contains information parallel to what you need to know to start programming in R. It's easier to teach general programming concepts at the same time, even if your typical SAS course would probably introduce you to the DATA step and simple PROC statements first. \n\n## SAS computer basics\n\nIn SAS, you can set your working directory in the Program Editor, Log, or Explorer windows by clicking on Tools > Options > Change Directory, navigating to your preferred directory, and clicking ok.\n\n![](images/sas/sas-screenshot-setwd.gif)\n\nIn SAS, you'll want to store your .sas code file in the RStudio project folder as well, and I believe that should be sufficient to set your working directory for any SAS code you may write as part of e.g. a homework assignment.\n\n## Introduction to SAS Programming\n\nA few notes on programming concepts and R vs. SAS\n\n- <details><summary>Historical view</summary>\nBoth [R](https://bookdown.org/rdpeng/rprogdatascience/history-and-overview-of-r.html) and [SAS](https://en.wikipedia.org/wiki/SAS_(software)#History) have long histories. SAS in particular dates back to the 1960s, and has syntax which is unique compared to more modern languages such as C, python, Java, and R. R's predecessor, S, dates back to 1976 and was designed for internal use at Bell Labs. The histories of both languages are useful in understanding why they are optimized for their respective tasks, but are not essential for this course (so read them at your leisure).</details>\n\n- <details><summary>Difference between R and SAS</summary><p>\nThe biggest difference between R and SAS (at a fundamental level) is that R is a [**functional** language](http://adv-r.had.co.nz/Functional-programming.html) - it consists mainly of functions, which can (and do) manipulate objects, including other functions. SAS, on the other hand, is a procedural language - most SAS programs follow a specific series of steps, known as \"proc\"s. Procs are essentially functions (or compositions of multiple functions), but in SAS, it is simpler to think of an analysis as a series of procedural steps; in R, there are steps, but they may be implemented in a more flexible way (depending on the analysis). </p><p>\nAnother interesting feature of SAS is that it's really several languages - some commands work in PROC IML (interactive matrix language) but not in a DATA step. When looking for help in SAS, make sure you're referencing the correct part of the language documentation.</p>\n</details>\n\n- <details><summary>I'm teaching SAS very differently</summary>\n<p>I'm definitely teaching SAS differently than it is normally taught. This is so that we don't have to do half the semester in SAS and half in R - I'd rather teach the concepts and show you how they're implemented than split them up by language. BUT, this means that some of the things we're doing first in SAS are things you wouldn't normally do until you were already proficient in SAS. It also means that SAS is probably going to seem even more oddly organized when taught this way than it actually is (and it is oddly organized, in my opinion).</p><p>\nWe're going to start with SAS IML (programming concepts) and then talk about the DATA step. We'll use some procedures implicitly along the way, but hopefully that will make sense in context. Then, we'll work on the PROCs (SQL, Transpose, and graphing) - in greater detail. </p>\n</details>\n\n### Variable Types in SAS\n\nIn SAS, there are two basic variable types: numeric and character variables. SAS does not differentiate between integers and floats and doubles. Functionally, though, the same basic operations can be performed in SAS. As with R, SAS does attempt to implicitly convert variable types, and will notify you that the conversion has taken place in the log file.\n\n#### Type Conversions {-}\n\nSAS will attempt to implicitly convert variables when:\n\n- a character value is assigned to a previously defined numeric variable\n- a character value is used in arithmetic operations\n- a character value is compared to a numeric value using a comparison operator (<, >, <=, >=)\n- a character value is specified in a function that takes numeric arguments\n\n::: note\nImplicit conversion does not occur in WHERE statements. (This will make more sense later, but is here for reference)\n:::\n\n<details><summary>Manual type conversions</summary>\nIf you want to manually convert a value, use the INPUT statement. Unlike in R, the INPUT statement has the ability to read numbers which are formatted differently. For instance\n\n```\ndata set1;\n  x = 3;\n  y = '3.1415';\n  z = x * y;\n  put z;\nrun;\n```\n\n```\ndata set2;\n  x = 3;\n  y = '3.1415';\n  z = x * y;\n  put z; /* print to log */\n\n  x = '3.14159';\n  /* x previously had a number in it, \n     so it will be converted to a number here */\n  put x; /* print to log */\n\n  zz = y <= 2;\n  /* comparison operator: y will be converted */\n  put zz; /* print to log */\n  \nrun;\n```\n\n\nNotice that in SAS, `zz`, which is the result of the logical statement `y<=2`, is a numeric variable. The value 0 signifies that the comparison was false. SAS does not have a logical data type, it uses the numeric variable with 0:=FALSE, 1:=TRUE.\n\n</details>\n\n\n#### Try it out {- .tryitout}\n\n1. Create variables `string1` and `string2` that each have text/character values. \"Bob\" and \"Jane\" might be good options. How does logical operation work with actual character values?\n\n2. What happens if you use `string1` and add 3 to it? \n\n<details><summary>Solutions</summary>\n```\ndata set1; \n  string1 = 'Bob';\n  string2 = 'Jane';\n  x = string1 < string2;\n  put x=; /* This prints the result to the log */\nrun;\n\n```\n\nSAS will actually compare strings based on the first letter: Bob comes before Jane, so Bob < Jane. \n\n\n```\ndata set2;\n  string1 = 'Bob';\n  y = string1 + 3;\n  put y=;\nrun;\n```\n\nThe `.` in SAS is a missing value (like `NA` in R). So SAS is behaving basically like R does: it complains about the fact that you asked it to add a string to a number, and then it stores the result as a missing value. \n\n</details>\n\n###  Basic List Syntax in SAS {-}\nThere are also [lists in SAS IML](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_langref_sect040.htm&docsetVersion=15.1&locale=en) which function similarly to lists in R. To create a named object in a list, precede the name with `#`. In SAS, the `$` operator can be used to get items from a list, using either name or numeric references. \n\n```\n\nproc iml;\n  grocery_list = [\n    #dairy  = [\"asiago\", \"fontina\", \"mozzarella\", \"blue cheese\"], \n    #baking = [\"flour\", \"yeast\", \"salt\"], \n    #canned = [\"pepperoni\", \"pizza sauce\", \"olives\"], \n    #meat   = [\"bacon\", \"sausage\", \"anchovies\"], \n    #veggies= [\"bell pepper\", \"onion\", \"scallions\", \"tomatoes\", \"basil\"]\n  ];\n\n  /* print only works on matrices and vectors */\n  /* so we'll cheat and load another library to print lists */\n  \n  package load ListUtil;\n  \n  /* run ListPrint(grocery_list); */ \n  /* This would print the thing, but it's long */\n  \n  ick = [grocery_list$\"canned\"$3, grocery_list$4$2, grocery_list$4$3];\n  crust = grocery_list$\"baking\";\n  call ListAddItem(crust, \"water\"); /* add an item to a list */\n  essential_toppings = [grocery_list$\"dairy\"$3, grocery_list$\"canned\"$2];\n  yummy_toppings = [grocery_list$\"dairy\"$1, grocery_list$\"dairy\"$2, \n    grocery_list$\"dairy\"$4, grocery_list$\"meat\"$1, grocery_list$5$3] ;\n  /* The || is a concatenation operator, like c(). */\n  /* It is inefficient for large data sets */\n  \n  run ListPrint(ick);\n  run ListPrint(crust);\n  run ListPrint(yummy_toppings);\nquit;\n\n```\n\n### Data Sets (SAS) {-}\n\nThe SAS data set structure is similar to a R data frame.\n\n![This is a schematic of a data set as taken from the SAS documentation](images/sas/02_sas_dataset.png)\n<!-- https://documentation.sas.com/api/docsets/basess/9.4/content/images/data-fit.png original source for the image -->\n\nIn SAS, missing values are indicated with `.`\n\nSAS datasets also come with a description which is attached to the table. The descriptor portion of the data set records names of variables (and attributes), numbers of observations, and date/time stamps of creation and updates.\n\n<details class=\"ex\"><summary> Creating a SAS data set </summary>\nIn the next code chunk, we'll create a data set using a SAS Data step. We'll talk more about the anatomy of a SAS command later, but for now, notice that I'm specifying some metadata (the title), telling SAS what the variable names are (Drugs, Score), and then providing some data (indicated by the datalines statement).\n\n```\ndata mathLSD;\ntitle 'Average math test scores under the influence of LSD';\ninput Drugs\tScore;\ndatalines;\n1.17 78.93\n2.97 58.20\n3.26 67.47\n4.69 37.47\n5.83 45.65\n6.00 32.92\n6.41 29.97\n;\n\n/* Describe the dataset */\nproc datasets;\n  contents data = mathLSD;\nrun;\n\nproc print data = mathLSD;\nrun;\n```\n\nThe last two blocks are SAS procedures (PROCs). In the first block, I'm asking SAS to describe the contents of the mathMJ dataset. In the second block, I'm telling SAS to print the whole mathMJ dataset out. \n</details>\n\n\n### Indexing in SAS\n\nIn SAS, the same basic code works (though matrix definition is a bit more manual). \n\n```\nproc iml; /* Interactive Matrix Language */\n  x = {1 2 3 4 5, 6 7 8 9 10, 11 12 13 14 15, 16 17 18 19 20};\n  y = x[3:4, 1:2];\n  print x; /* Here, print is used instead of put */\n  print y;\nquit; /* exit proc IML */\n```\n\n\n\n#### Try it out {- .tryitout}\n(From project Euler)\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5,\n   we get 3, 5, 6 and 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below 1000.\n\n\nHint: The modulo operator, `%%`, gives the integer remainder of one number\n      divided by another. So `a %% b` gives the integer remainder when\n      dividing `a` by `b`. Modular division is often used to find multiples\n      of a number.\n\n<details><summary>SAS solution</summary>\n```\ndata tmp;\n  do x = 1 to 999;\n  output;\n  end;\nrun;\n\nproc summary data=tmp; /* Summarize data */\n  where (mod(x, 3) = 0) | (mod(x, 5) = 0); \n  /* Keep only obs where x is divisible by 3 or 5 */\n  \n  var x; /* what variable we want the summary for */\n  \n  output out=sum_x sum=; /* output sum_x to a new dataset */\nrun;\n\nproc print data = sum_x; /* print our sum_x dataset */\nrun;\n```\n\nNote on the SAS code: where statements allow you to select part of the data for further processing. There was a note earlier about the fact that type conversion doesn't happen in where clauses... this is one of those clauses. We'll get into where clauses in more detail later, in module 5. \n</details>\n\n### If Statements\n\n<details><summary>In SAS</summary>\nIn a data step:\n```\ndata santa;\n  input name $ status $;\n  datalines;\n  Edison nice\n  Alex naughty\n  Susan .\n  Ryan neutral\n;\n\n/* Modify santa_list and make a new dataset, present_list */\ndata presents;\n  set santa;\n  if status = \"naughty\" then present = \"coal\";\n  else present = \"toy\";\nrun; /* must end with run if no datalines option */\n\nproc print data=presents;\nrun;\n```\n\nNote that `.`, or missing data is handled the same as 'nice'. That might not be what we wanted... this is the natural thing to do, right?\n\n```\ndata santa;\n  input name $ status $;\n  datalines;\n  Edison nice\n  Alex naughty\n  Susan .\n  Ryan neutral\n;\n\n/* Modify santa_list and make a new dataset, present_list */\ndata presents;\n  set santa;\n  if status = \"naughty\" then present = \"coal\";\n  else (if status = \"nice\" then present = \"toy\" else present = .);\nrun; /* must end with run if no datalines option */\n\nproc print data=presents;\nrun;\n```\n\n\nSAS doesn't handle nested if statements very well - they can be ambiguous. Instead, [SAS documentation suggests using `do;` and `end;` to denote the start and end points of each if statement](https://documentation.sas.com/?docsetId=basess&docsetTarget=p0pcj5ajwyngron1wlsq0tet0hce.htm&docsetVersion=9.4&locale=en) (like the `{}` in R). \n\n```\ndata santa;\n  input name $ status $;\n  datalines;\n  Edison nice\n  Alex naughty\n  Susan .\n  Ryan neutral\n;\n  \ndata presents;\n  set santa;\n  if status = \"naughty\" then \n    do;\n      present = \"coal\";\n    end;\n  else if status = \"nice\" then\n    do;\n      present = \"toy\";\n    end;\n  else \n    do;\n      present = .;\n    end;\nrun;\n          \nproc print data=presents;\nrun;\n```\n\n\nInterestingly, if you set a character variable to be missing, SAS converts it to '.'. So, if we actually want to have the value be missing, we can set it to an empty string.\n\n```\ndata santa;\n  input name $ status $;\n  datalines;\n  Edison nice\n  Alex naughty\n  Susan .\n  Ryan neutral\n;\ndata presents; \n  set santa;\n  if status = \"naughty\" then \n    do;\n      present = \"coal\";\n    end;\n  else if status = \"nice\" then\n    do;\n      present = \"toy\";\n    end;\n  else \n    do;\n      present = '';\n    end;\nrun;\n          \nproc print data=presents;\nrun;\n```\n\nNow things work the way we expected them to work.\n</details>\n\n- Switch statments: [SAS case statement documentation](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=n0a85s0ijz65irn1h3jtariooea5.htm&docsetVersion=9.4&locale=en)\n\n\n#### Try it out {- .tryitout}\nThe `sample()` function selects a random sample of entries from a vector. Suppose we sample a random vector $x$ with 10 entries. Write one or more if statements to fulfill the following conditions\n\n- if $x$ is divisible by 2, $y$ should be positive; otherwise, it should be negative.\n- if $x$ is divisible by 3, $y$ should have a magnitude of 2; otherwise, it should have a magnitude of 1.\n\nIt may be helpful to define separate variables `y_mag` and `y_sign` and then multiply them afterwards. Once you have found the value of $y$ compute $\\text{sum}(x * y)$.\n\nYou may use the following code skeletons to set the problem up.\n\n````\nproc iml;\n  call randseed(342502837);\n  x = sample(1:50, 20)`;\n  create sampledata from x [colname = \"x\"];\n  append from x;\n  close;\nquit;\n\ndata xy;\n  set sampledata;\n\n\n  /* Conditional statements go here */\n  \n  \n  /* Leave this so that the code below works */\n  res = x * y;\nrun;\n\nproc summary data=xy; /* Summarize data */\n  var res; /* what variable we want the summary for */\n  \n  output out=tmpsum sum=; /* output tmpsum to a new dataset */\nrun;\n\nproc print data = xy; /* print our original dataset to check result */\n  var x y res;\n  sum res;\nrun;\n\nproc print data = tmpsum; /* print our tmpsum dataset */\nrun;\n````\n\n<details><summary>SAS Solution</summary>\n\n```\nproc iml;\n  call randseed(342502837);\n  x = sample(1:50, 20)`; \n  create sampledata from x [colname = \"x\"];\n  append from x;\n  close;\nquit;\n\ndata xy;\n  set sampledata;\n\n  y_sign = 0 * x;\n  y_mag = 0 * x;\n\n  /* Conditional statements go here */\n  if MOD(x, 2) = 0 then y_sign = 1; \n    else y_sign = -1;\n  if MOD(x, 3) = 0 then y_mag = 2; \n    else y_mag = 1;\n\n  y = y_sign * y_mag;\n  res = x * y;\nrun;\n\nproc summary data=xy; /* Summarize data */\n  var res; /* what variable we want the summary for */\n  \n  output out=tmpsum sum=; /* output tmpsum to a new dataset */\nrun;\n\n\nproc print data = xy; /* print our original dataset to check result */\n  var x y res;\n  sum res;\nrun;\n\nproc print data = tmpsum; /* print our tmpsum dataset */\nrun;\n```\n\nSee [this](https://www.oreilly.com/library/view/sas-certification-prep/9781607649243/p12osnn9d1s4hgn12yf8ffocxhw7.htm) to understand how the print statement works and how to add column summary values. \n</details>\n\n\n### For Loops\n\n\n<details class=\"ex\"><summary>\"For loops\" in SAS IML (using `do`)</summary>\n```\n/* SAS IML example loop */\nproc iml;\n  do i = 1 to 10;\n    print i; \n  end; /* This ends the loop definition */\nquit;\n```\n</details>\n\n<details class=\"ex\"><summary>\"For loops\" in a SAS DATA step</summary>\n```\ndata A;\n  do i = 1 to 10; \n    put i=;\n  end; /* This ends the loop definition */\nrun;\n```\n\n</details>\n\n<details><summary>Other sequence structures in SAS for loops</summary>\nWe can iterate by non-integer values:\n```\ndata A;\ny = 0;\ndo i = 5 to 0 by -0.5;\n    put i=; \n  end;\nrun;\n```\n\nWe can even add additional conditions:\n\n```\ndata A;\ny = 0;\ndo i = 5 to 0 by -0.5 while (i**2 > 1);\n    put i=;\n  end; \nrun;\n```\n</details>\n\n##### Try it out (in SAS) {- .tryitout}\n\nWrite a for loop which will output the first 30 [fibbonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number). You can use the following code as a starting point:\n\n```\n/* SAS IML example loop */\nproc iml;\n  current = 1; \n  prev = 0;\n\nquit;\n\n````\n\n<details><summary>Solution</summary>\n\n```\n/* SAS IML example loop */\nproc iml;\n  current = 1;\n  prev = 0;\n\n  do i = 1 to 30;\n    new = current + prev;\n    prev = current;\n    current = new;\n    print current; \n  end; /* This ends the loop definition */\nquit;\n\n```\n</details>\n\n\n### Condition-controlled loops (WHILE, DO WHILE)\n\n##### Example: The Basel Problem {- .ex}\nLet's solve the [Basel problem](https://en.wikipedia.org/wiki/Basel_problem) in SAS using WHILE loops - we'll repeat the calculation until the value changes by less than 0.000001. The Basel problem is the problem of calculating the precise infinite summation $$\\sum_{n=1}^\\infty \\frac{1}{n^2}$$\n\nWe'll stick to calculating it computationally.\n\n<details><summary>In SAS</summary>\n```\nproc iml;\n  i = 1;\n  basel = 0;\n  prev = -1;\n  do while((basel - prev) > 1e-6);\n    prev = basel;\n    basel = basel + 1/i**2; /* ** is the exponent operator */\n    i = i + 1;\n    \n    if i > 1e6 then\n      do;\n        leave;\n    end;\n      \n    if MOD(i, 200) = 0 then\n      do;\n        print i, prev, basel;\n    end; \n  end;\n  \n  print i, basel;\nquit;\n  \n```\n\n</details>\n\n\n##### Try it out {- .tryitout}\n\nWrite a while loop in in SAS to calculate $\\displaystyle \\lim_{x \\rightarrow 4} \\frac{2 - \\sqrt{x}}{4-x}$ by starting at 3 and halving the distance to 4 with each iteration. Exit the loop when you are within 1e-6 of the value computed on the previous iteration, or when you are within 1e-6 from 4. Which exit condition did you hit first? How do you know?\n\n<details><summary>Solution</summary>\n\n```\nproc iml;\n  x = 3;\n  dist = 4 - x;\n  fx = 0;\n  prev_fx = 1;\n  dfx = abs(fx - prev_fx);\n  do while(dfx > 1e-6 & dist > 1e-6);\n    prev_fx = fx;\n    dist = dist/2; \n    x = 4 - dist; \n    fx = (2 - sqrt(x))/(4 - x);\n    dfx = abs(fx - prev_fx);\n  end;\n  \n  print x, dist, fx, dfx;\nquit;\n\n```\n</details>\n\n## EDA in SAS\n\n1. [Proc Freq](https://go.documentation.sas.com/?docsetId=procstat&docsetTarget=procstat_freq_toc.htm&docsetVersion=9.4&locale=en) generates frequency tables for variables or interactions of variables.    \n    \n<details class=\"ex\"><summary>PROC FREQ demo</summary>\nThis can help you to see whether there is missing information. Using those frequency tables, you can create frequency plots and set up chi squared tests.\n\n```\nlibname classdat \"sas/\";\n\nODS GRAPHICS ON;\nPROC FREQ DATA=classdat.poke ORDER=FORMATTED;\n  TABLES generation / CHISQ PLOTS=freqplot(type=dotplot);\nRUN;\nPROC FREQ DATA=classdat.poke ORDER=FREQ;\n  TABLES type_1 status / MAXLEVELS=10 PLOTS=freqplot(type=dotplot scale=percent);\nRUN;\nODS GRAPHICS OFF;\n```\n\n</details>\n\n2. Proc Means can be used to get more useful summary statistics for numeric variables.     \n    \n<details class=\"ex\"><summary> PROC MEANS demo</summary>Note that the Class statement identifies a categorical variable; the summary statistics are computed for each level of this variable. \n\n```\nODS HTML style= HTMLBlue; \nlibname classdat \"sas/\";\n\nPROC MEANS DATA = classdat.poke;\nrun;\n\nproc means data = classdat.poke;\nclass status;\nrun;\n```\n</details>\n\n3. For even higher levels of detail, [Proc Univariate](https://go.documentation.sas.com/?docsetId=procstat&docsetTarget=procstat_univariate_toc.htm&docsetVersion=9.4&locale=en) will provide variability, tests for location, quantiles, skewness, and will identify the extreme observations for you.     \n    \n<details class=\"ex\"><summary>PROC UNIVARIATE demo</summary>\nYou can also get histograms for variables, even specifying distributions you'd like to be fit to the data (if that's something you want). \n```\nODS HTML style= HTMLBlue; \nlibname classdat \"sas/\";\n\nODS GRAPHICS ON;\nPROC UNIVARIATE DATA = classdat.poke;\nVAR attack defense sp_attack sp_defense speed;\nHISTOGRAM attack defense sp_attack sp_defense speed;\nRUN;\nODS GRAPHICS OFF;\n```\n</details>\n\n4. Proc Corr allows you to examine the relationship between two quantitative variables.     \n    \n<details class=\"ex\"><summary>PROC CORR demo</summary>\n\n```\nlibname classdat \"sas/\";\n\nODS GRAPHICS ON;\nPROC CORR DATA = classdat.poke PLOTS( MAXPOINTS=200000)=MATRIX(HISTOGRAM);\nVAR attack defense sp_attack sp_defense speed ;\nRUN;\nODS GRAPHICS OFF;\n```\n\nThe plot here is called a scatterplot matrix. It contains histograms on the diagonal, and pairwise scatterplots on off-diagonals. It can be useful for spotting strong correlations among multiple variables which may affect the way you build a model. \n</details>\n\n### Try it out {- .tryitout #police-violence-eda-sas}\n\nOne of the datasets we read in above records incidents of police violence around the country. Explore the variables present in [this dataset](data/police_violence.xlsx) (see code in the spreadsheets section to read it in). Note that some variables may be too messy to handle with the things that you have seen thus far - that is ok. As you find irregularities, document them - these are things you may need to clean up in the dataset before you conduct a formal analysis.\n\nIt is useful to memorize the SAS PROC options you use most frequently, but it's also a good idea to reference the SAS documentation - it provides a list of all viable options for each procedure, and generally has decent examples to show how those options are used.\n\n<details><summary>Solution</summary>\n```\nODS HTML style= HTMLBlue; \n\nlibname classdat \"sas/\";\n\nODS GRAPHICS ON;\nPROC CONTENTS DATA = classdat.police; /* see what's in the dataset */\nRUN;\n\nPROC FREQ DATA = classdat.police ORDER=FREQ; /* Examine Freq of common vars */\nTABLES Victim_s_gender Victim_s_race State Cause_of_death \n        Unarmed Geography__via_Trulia_methodolog / MAXLEVELS = 10;\nRUN;\n\nPROC FREQ DATA = classdat.police ORDER=FREQ; /* Combinations of vars */\nTABLES Unarmed * Criminal_Charges_ / NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;\nRUN;\n\nPROC MEANS DATA = classdat.police; /* Numeric variable exploration */\nVAR num_age; /* Only numeric variable in this set */\nRUN;\n\nPROC UNIVARIATE DATA = classdat.police; /* Investigating age/date info */\nHISTOGRAM num_age date;\nRUN;\nODS GRAPHICS OFF;\n```\n\nOddities to note:\n\n- Gender - Unknown should be recoded as missing (' ')\n- Victim\\_s\\_race - Unknown race and Unknown Race should be recoded as missing\n- State - might need to check to make sure all states are valid (but top 10 are, at least)\n- Cause of death - sometimes, there are multiple causes. Also, varying capitalizations...\n- Geography - #N/A should be recoded as missing \n- Criminal_Charges_ - What does No/NO mean? (would need to look up in the codebook)\n- Age - the maximum age recorded is 107, which bears some investigation... other extreme observations between 89 and 95 are also fairly interesting and could be investigated further. There are also several infants/young children included, which is horribly sad, but believable.\n- Date - PROC UNIVARIATE doesn't display date results with a meaningful format, even though format is specified.\n\n\nConclusions (ok, probably obvious before this analysis):\n\n- It's much more likely for charges to be filed if the suspect was unarmed (but still very rare)\n- Data is relatively evenly distributed between 2013 and 2019.\n- It's fairly rare for police to kill female or transgender individuals - around 5% of all victims\n- California, Texas, and Florida, while populous, seem to have a disproportionate number of killings, especially compared to e.g. NY, which is also a high population state. To really make the state numbers meaningful, though, we'd need to know population counts. There's also an issue of accurate comparisons - some states may not report police killings with the same standards as other states. \n</details>\n\n## Data Cleaning in SAS\n\n\n\nIn SAS, as in SQL, the `filter()` operation is accomplished using a `where` clause. Multiple clauses can be connected using `and`, and compound statements can be grouped with parentheses. \n\n### Demonstration of `where` in SAS\nRather than output the whole data table (which would take up a lot of space), I've linked the log file from each chunk below the chunk. If you are running this code in SAS, you should NOT copy the `proc printto` line. \n\n```\nlibname classdat \"sas/\";\n\n/* SAS limits dataset names to 8 characters, which is super annoying. */\n/* Sorry the names aren't descriptive... */\n\nDATA tmp1; /* this is the out dataset */\n/* By not having a library attached, SAS places this in WORK */\n/* It's a temporary dataset */\n  set classdat.starwars;\n  where (species = 'Human');\n  run;\n```\nSee the log file [here](other/05-filter-1.log)\n\n```\nlibname classdat \"sas/\";\n\nDATA tmp2; \n  set classdat.starwars;\n  where (species = 'Human') and (homeworld = 'Tatooine');\n  run;\n```\nSee the log file [here](other/05-filter-2.log)\n\n\nAt this point, you've seen the traditional SAS Data step options, but there is another SAS PROC that may be more useful (and more similar to `dplyr`). `dplyr` was developed to provide SQL-like syntax while enabling the use of more advanced computations than are supported in SQL. While SAS doesn't have anything quite the same as `dplyr`, it does have [PROC SQL](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=p07v6ho0hymhfvn1jboqfe38jnox.htm&docsetVersion=9.4&locale=en).\n\n#### Try it out\n\nUsing the pokemon data, can you create a new data frame that has only water type pokemon? Can you write a filter statement that looks for any pokemon which has water type for either type1 or type2?\n\n```\nlibname classdat \"sas/\";\n\nDATA water1;\nSET classdat.poke;\nWHERE type_1 = \"Water\";\nRUN;\n\nDATA water2;\nSET classdat.poke;\nWHERE (type_1 = \"Water\" OR type_2 = \"Water\");\nRUN;\n```\n\nIn the interests of only showing the parts of the log that are useful, I've just pasted them into this chunk. Not reproducible, but faster to read.\n\n````\nNOTE: There were 134 observations read from the data set CLASSDAT.POKE.\n      WHERE type_1='Water';\nNOTE: The data set WORK.WATER1 has 134 observations and 49 variables.\nNOTE: DATA statement used (Total process time):\n      real time           0.00 seconds\n      cpu time            0.00 seconds\n\nNOTE: There were 153 observations read from the data set CLASSDAT.POKE.\n      WHERE (type_1='Water') or (type_2='Water');\nNOTE: The data set WORK.WATER2 has 153 observations and 49 variables.\nNOTE: DATA statement used (Total process time):\n      real time           0.00 seconds\n      cpu time            0.00 seconds\n````\n\n#### SAS PROC SQL\nIn SQL, as in the SAS DATA step, `filter()` operations are performed using the keyword `WHERE`.\n\nTo limit the output I'm going to cheat a bit and use SELECT statements before I officially teach them to you - this is mostly so you don't get a table with all 49 variables in it. Similarly, I'm limiting the dataset to the first 5 observations that meet the condition so that we don't have to see *all* the water type pokemon.\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nSELECT pokedex_number, name, type_1, type_number FROM classdat.poke (obs=5)\nWHERE type_1 = \"Water\";\n```\n\nIf we want to store the output of our query to a new table, we can do that by starting our query with CREATE TABLE \\<table name\\> AS - this creates a table with our results.\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE aquapoke AS\nSELECT pokedex_number, name, type_1, type_2, type_number FROM classdat.poke\nWHERE (type_1 = \"Water\" OR type_2 = \"Water\");\n\nPROC PRINT DATA=aquapoke (obs=10);\nRUN;\n```\n\n### Common Cleaning Tasks\n\n#### Keeping only certain rows\n\nIn SAS, to use a variable, you have to define it in one data step, then make another data step in order to use that variable. But, like `dplyr`, SAS has a row number counter that we can use for this purpose.\n```\nlibname classdat \"sas/\";\n\nDATA tmp;\nSET classdat.poke;\n  rownum=_n_; /* SAS shorthand for row number */\nRUN;\n\nDATA evenrow;\n  SET WORK.tmp;\n  WHERE MOD(rownum, 2) = 0;\n  DROP rownum; /* ditch temp variable */\nRUN;\n```\n\n#### Top N values\n\nWe're going to want to use PROC SORT to get the data arranged before we take the top N values.\nAccording to [this](https://communities.sas.com/t5/General-SAS-Programming/if-and-where-statement-for-n/td-p/237647), we can't use `_n_` in a where statement, and the proposed solution isn't reliable. So we'll do it the long way.\n```\nlibname classdat \"sas/\";\n\nPROC SORT DATA = classdat.poke\n  OUT = pokesort;\n  BY descending total_points;\nRUN;\n\nDATA poken;\n  SET WORK.pokesort;\n  rownum = _n_;\nRUN;\n\nDATA poken;\n  SET WORK.poken;\n  WHERE rownum <= 5;\n  DROP rownum;\nRUN;\n\nPROC PRINT DATA = poken;\n  VAR pokedex_number name status species type_1 total_points;\nRUN;\n```\n\nIn both cases, the SAS statements required to perform the task require a WHERE clause, but also a few other statements to get things working. The equivalent base R code would be about the same (though tricky in different spots).\n\n#### PROC SQL filter statements \nSQL doesn't have an intrinsic notion of ordered rows, so in order to select even rows, we need to create a temporary dataset with `_n_` copied into a variable (just like last time).\n```\nlibname classdat \"sas/\";\n\nDATA poke;\n  SET classdat.poke;\n  rownum=_n_;\nRUN;\n\nPROC SQL;\nSELECT * FROM poke(obs=5)\nWHERE mod(rownum, 2) = 0;\n```\n\nSELECT \\* says to select all variables. We'll talk about SELECT in the next section, but with SQL it's not really possible to avoid using SELECT.\n\nIf we want the 5 pokemon with the highest total points, we can use ORDER BY to sort the table, and then specify that we only want 5 rows.\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nSELECT pokedex_number, name, status, species, type_1, total_points\nFROM classdat.poke(obs=5)\nORDER BY total_points DESC;\n```\n\nAs a reminder, if we want to store this new data into a new dataset, we have to start our statement with CREATE TABLE <tablename> AS, and then follow the statement with our query.\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE poketmp AS\nSELECT pokedex_number, name, status, species, type_1, total_points\nFROM classdat.poke(obs=5)\nORDER BY total_points DESC;\n\nPROC PRINT DATA=poketmp;\nRUN;\n```\n\n### Column Selection\nUnfortunately, SAS doesn't make column selection *quite* as easy. It's still not hard, but it can be tedious. In SAS, there are two primary methods to select variables: KEEP selects variables, DROP removes variables.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Export flights data for SAS\nflights %>%\nsample_frac(size = .25) %>% # Keep file from being too big\nwrite_csv(\"data/flights.csv\", na = \".\")\n```\n:::\n\n```\n/* Read in data */\nlibname classdat \"sas/\";\nfilename fileloc '~/Projects/Class/unl-stat850/2020-stat850/data/flights.csv';\nPROC IMPORT  datafile = fileloc out=classdat.flights\nDBMS = csv; /* comma delimited file */\nGETNAMES = YES;\nRUN;\n```\n\nIn SAS, a partial variable name either preceded or followed by `:` serves as  a wildcard.\nRanges of variables can be specified with two dashes, e.g. `var3 -- var5`.\n\nUnfortunately, the wildcard doesn't work on both ends, so to get the equivalent of `matches(\"dep\")`, we have to use two different options in our KEEP statement (plus the extra variables that don't have dep in them).\n\n```\nlibname classdat \"sas/\";\n\nDATA tmpfly;\n  KEEP flight year--day tailnum origin dep: sched_dep:;\n  SET classdat.flights;\nRUN;\n\nPROC PRINT DATA = tmpfly (obs=10);\nRUN;\n```\n\nNote also that SAS doesn't reorder the columns for us like `select()` does.\n\nIf we'd prefer to carve out columns (rather than assembling a new dataset with the columns we want to keep), we can use a DROP statement, which works exactly the same way. Let's see what columns we removed implicitly last time by dropping everything we'd previously kept:\n\n```\nlibname classdat \"sas/\";\n\nDATA tmpfly;\n  DROP flight year--day tailnum origin dep: sched_dep:;\n  SET classdat.flights;\nRUN;\n\nPROC PRINT DATA = tmpfly (obs=10);\nRUN;\n```\n  As with the filter statements, we can also use PROC SQL instead of a SAS DATA step. There are even ways to (sort-of) use elements of both.\n\n#### SAS PROC SQL SELECT statement\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE tmpfly\nAS\nSELECT flight, year, month, day, tailnum, origin\nFROM classdat.flights;\n\nPROC PRINT DATA = tmpfly(obs=10);\nRUN;\n```\nNote that PROC SQL doesn't have a RUN statement - it is executed immediately. But, using the PROC SQL syntax, we still have to list out all of the variables, and that's a drag.\n\nLuckily, PROC SQL will also let us use some of the DATA step options, if we're careful about it:\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE tmpfly\nAS\nSELECT *\nFROM classdat.flights(drop=year--day flight tailnum origin dep: sched_dep:);\n\nPROC PRINT DATA = tmpfly(obs=10);\nRUN;\n```\n\nNote the difference - we're selecting everything (in SQL) but dropping columns when we tell SQL where to look for the data.\n\n\nFor the most part, that is what you need to functionally replicate `select()` syntax. It may be a bit more work because there aren't the same convenience functions, but it'll do and you don't have to remember as many keywords, so that's a plus.\n\n### Creating New Variables\n\n\n#### SAS DATA STEP \nWe can create our variable a couple of different ways in SAS:\n- Use the [TRANWRD function](https://v8doc.sas.com/sashtml/lgref/z0215027.htm) for find and replace.\n- Use an if statement and define the replacement ourselves\n\nBoth are demonstrated below:\n```\nlibname classdat \"sas/\";\n\nDATA pvtmp;\n  SET classdat.police;\n  race = tranwrd(victim_s_race, \"Race\", \"race\");\n  race2 = victim_s_race; /* initialize it to current value */\n  IF victim_s_race='Unknown Race' THEN race2 = 'Unknown race';\nRUN;\n\nPROC FREQ DATA = pvtmp ORDER=FREQ; /* Combinations of vars */\nTABLES victim_s_race * race victim_s_race * race2 /\n  NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;\nRUN;\n```\nIn both cases we can see that the recode worked the way we wanted and we've now gotten rid of the extra \"unknown\" category\".\n\n\n#### Proc SQL\n\nWe can also use PROC SQL to create new variables using relatively complex logic if necessary.\n\nIn SQL, you define new variables using AS. In SELECT statements, this definition has the computation on the left and the variable on the right^[This is equivalent to using right assignment in R with `->`, which you shouldn't do unless you have a *really* good reason, because it's hard to read.].\n\nCASE WHEN is the if-else statement in SQL. When (`victim_s_race` = 'Unknown Race'), our variable value will be \"Unknown race\", otherwise it will be what ever value is in `victim_s_race`.\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE WORK.pvtmp AS\nSELECT * ,\nCASE WHEN victim_s_race='Unknown Race' THEN 'Unknown race' ELSE victim_s_race END AS race\nFROM classdat.police;\n\n\nPROC FREQ DATA = pvtmp ORDER=FREQ; /* Combinations of vars */\nTABLES victim_s_race * race /\n  NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;\nRUN;\n```\n\n#### Comparison\n\nThe choice of which method to use (DATA step or PROC SQL) involves weighing these competing factors:\n\n- computational time\n- code readability\n- programmer time\n\n\nPersonally, I find PROC SQL easier to work with, but I think the code is ugly. There are similar sql-syntax packages in R, but I don't feel the need to use them, because (for me) dplyr code is much easier to read (and thus, easier to maintain). dplyr code is not as efficient as SQL (or other packages, like `data.table`) on big datasets, but there are variants such as `dbplyr` to handle some of those cases, and I find that they don't come up very often in my work or research. If I were working at Google or Amazon, my opinion might be very different\n\n<!-- The fundamentals of `mutate` are very similar to the approaches above; the power of the dplyr approach is only really evident when you are doing multiple operations in the same step. Once you're working at that level, the `dplyr` approach produces much more readable code. -->\n\n### Summarize\n\n\nIn SAS, we can do something similar:\n```\nlibname classdat \"sas/\";\n\nDATA pv;\n  SET classdat.police;\n  age = INPUT(victim_s_age, 3.);\n  name_len = LENGTH(victim_s_name);\nRUN;\n\nPROC MEANS DATA=pv;\nVAR age name_len;\nRUN;\n```\n\nBy default, with SAS, we get a bit more than we bargained for; we can turn the extra output off with options.\n\nAnother option is to use PROC SQL in SAS, which will have a logical flow similar to `dplyr`. \n\n```\n\nlibname classdat \"sas/\";\n\nDATA pv;\n  SET classdat.police;\n  age = INPUT(victim_s_age, 3.);\n  name_len = LENGTH(victim_s_name);\nRUN;\n\nPROC SQL;\nSELECT AVG(age) as age, AVG(name_len) as name_len\nFROM pv;\n```\n\n### Group By + (?) = Power\n\n```\nlibname classdat \"sas/\";\n\nDATA pv;\n  SET classdat.police;\n  age = INPUT(victim_s_age, 3.);\n  IF victim_s_gender=' ' THEN victim_s_gender='Unknown';\n  race = victim_s_race; /* initialize it to current value */\n  IF victim_s_race='Unknown Race' THEN race = 'Unknown race';\nRUN;\n\nPROC SQL;\n  SELECT victim_s_gender AS gender, race, count(*) AS n\n  FROM pv\n  GROUP BY race;\n\nPROC SQL;\n  SELECT victim_s_gender AS gender, race, count(*) AS n, min(age) AS min_age, max(age) AS max_age\n  FROM pv\n  GROUP BY gender, race;\n```\n\n### Storm Example\n\n\n```\nlibname classdat \"sas/\";\nfilename fileloc 'data/storms.csv';\nPROC IMPORT  datafile = fileloc out=classdat.storms REPLACE\nDBMS = csv; /* comma delimited file */\nGUESSINGROWS=500;\nGETNAMES = YES;\nRUN;\n\nDATA classdat.storms;\nSET classdat.storms;\ndate = MDY(month, day, year);\ntime = DHMS(date, hour, 0, 0);\nFORMAT time DATETIME.;\nRUN;\n```\n<details><summary>Proc SQL in SAS</summary> \nIn SAS, this is going to require some work. Specifically, while dplyr commands are stated in recipe order (do this, then this), SQL statements... aren't. WHERE comes after SELECT xxx FROM yyy, and GROUP BY comes after that again. \n\nThere are a couple of ways to handle that: sub-queries, and creating temporary tables. I think the temporary tables approach will be easier to demonstrate, read, and understand, so lets go with that. \n\nAnother challenge will be the fact that SAS PROC SQL doesn't handle missing data quite as easily as dplyr does (na.rm is a very nice function, all things considered). \nWe can think through the steps we need to take: \n1. Create a table where wind and pressure observations aren't missing. We'll call that tmp1. \n2. Filter tmp1, keeping only rows with minimum pressure and maximum wind for each storm/year combination (HAVING is like WHERE, but after the GROUP BY clause has been applied). We'll call that tmp2. We can also select the variables we care about in this step. \n3. Summarize tmp2, keeping columns name, year, pressure, wind, category, status, and time, where time is the mean of all maximum-power observations. The other variables should have only one value each. We can accomplish this task using the combination of SELECT and DISTINCT. DISTINCT says \"keep only rows with new combinations of these values\". \n\n(Note also that we can format values inline in proc SQL Select statements. That forces SAS to treat time as a date-time variable, which will force it to format correctly in e.g. plots.)\n\n```\nlibname classdat \"sas/\";\n\n\nPROC SQL;\n  CREATE TABLE tmp1 AS\n  SELECT *\n  FROM classdat.storms\n  WHERE (NOT missing(pressure)) AND (NOT missing(wind));\n  \n  CREATE TABLE tmp2 AS \n  SELECT name, year, pressure, wind, category, status, time, \n         min(pressure) AS minpressure, max(wind) AS maxwind\n  FROM tmp1 \n  GROUP BY year, name\n  HAVING pressure = minpressure AND wind = maxwind;\n  \n  CREATE TABLE maxpwr AS\n  SELECT DISTINCT name, year, pressure, wind, category, status, \n                  mean(time) AS time format=DATETIME.\n  FROM tmp2\n  GROUP BY year, name;\n  \nQUIT;\n  \nPROC PRINT DATA=maxpwr (obs=5);\n  RUN;\n\nODS GRAPHICS ON;\nODS TRACE ON; /* this allows us to select only the plot and not tables */\nODS SELECT HISTOGRAM;\nPROC UNIVARIATE DATA=maxpwr;\n  VAR pressure;\n  HISTOGRAM;\n  RUN;\nODS TRACE OFF;\n  \nPROC SGPLOT DATA=maxpwr;\n  scatter X = time Y = pressure;\nRUN;\n  \nODS GRAPHICS OFF;\nQUIT;\n```\n</details>\n\n\n\n\nIn SAS, we have to know that [datetimes are stored in seconds](https://documentation.sas.com/?docsetId=ds2pg&docsetTarget=n02zpqz4j5u3j9n1t0i95ncqep5g.htm&docsetVersion=3.1&locale=en).  So if we subtract two date time values, and we want our answer in days, then we need to divide by the number of seconds in a day: 24\\*60\\*60 = 86400. R has helper functions to do this for us, but it's not that much harder to just do the computuation ourselves. \n\n```\nlibname classdat \"sas/\";\nPROC SQL;\nCREATE TABLE stormlencat AS\nSELECT name, year, (max(time) - min(time))/86400 AS duration, max(category) AS max_strength\nFROM classdat.storms\nGROUP BY year, name\nORDER BY max_strength;\n\nPROC BOXPLOT DATA=stormlencat;\n  PLOT duration * max_strength;\nRUN;\nQUIT;\n```\n\n\n```\n/* Clean log and output */\ndm log \"clear\";\ndm output \"clear\";\nods html close;\nods html;\n```\n\nWe can do something similar in SAS; this time, I decided to get rid of any storm which never had hurricane-force winds - that will get rid of a lot of lines that never leave the x-axis.\n\n```\nlibname classdat \"sas/\";\nPROC SQL;\nCREATE TABLE stormevo AS\nSELECT name, year, (time - min(time))/86400 AS time_since_start, category, status, hu_diameter, ts_diameter, max(hu_diameter) AS max_hu_diameter\nFROM classdat.storms\nWHERE NOT MISSING(hu_diameter)\nGROUP BY year, name\nHAVING max_hu_diameter > 0\nORDER BY year, name, time_since_start;\n\nPROC SGPANEL DATA=stormevo;\nPANELBY year / COLUMNS = 4 ROWS = 3;\nSERIES X = time_since_start Y = hu_diameter / GROUP = name;\nRUN;\nQUIT;\n```\n\nPROC SGPANEL in SAS does essentially the same thing as facet_wrap() in R - it allows you to select one or more variables to create sub-plots for. We do have to manually specify how many rows and columns (or SAS will give us 3 separate plots with 4 panels each). The essential components of the graph specification are the same - instead of specifying the use of a line, we specify \"series\" (which means plot a line). We specify the same x, y, and group variables, though the syntax differs a bit.\n\nThe SAS code for this is fairly similar (though I'll admit to not having the finesse with SAS to get a truly nice looking plot). At this point, we're going for quick-and-dirty graphics that show us what we want to know - we can figure out how to customize things later. \n\n```\nODS HTML style= HTMLBlue; /* needed for color graphs in bookdown */\n\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE ike AS\nSELECT * FROM classdat.storms WHERE name = \"Ike\"\nORDER BY time;\n\nPROC SGPLOT DATA=ike;\nSCATTER X = time Y = hu_diameter / \n  COLORRESPONSE=category /* color by another variable */\n  MARKERATTRS=(symbol=CircleFilled) /* use circles for points */\n  DATALABEL=category; /* label the circles with the value */\nRUN;\nQUIT;\n```\n\nWhile I'm tempted to plot out the diameter and location on a map, it's a bit excessive for this particular problem. Luckily, Wikipedia has us covered: \n![Hurricane Ike's path and strength over time](https://upload.wikimedia.org/wikipedia/commons/5/5f/Ike_2008_track.png)\n\nIt looks like Ike went long-ways across Cuba, which weakened it. When hurricanes weaken, often their wind fields expand (as they no longer have the angular momentum to maintain a tight structure). Ike crossed into the Gulf of Mexico, restrengthened, and then hit Houston just about dead-on. I was living just northwest of Houston when it hit (in College Station), and I can verify that it was not a fun time. \n\n### Gapminder: Try it Out\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::write_csv(gapminder_unfiltered, \"data/gapminder.csv\", na = '.')\n## Error in is.data.frame(x): object 'gapminder_unfiltered' not found\n```\n:::\n\n\n\n```\nlibname classdat \"sas/\";\n\nfilename fileloc 'data/gapminder.csv';\nPROC IMPORT  datafile = fileloc out=classdat.gapminder REPLACE\nDBMS = csv; /* comma delimited file */\nGUESSINGROWS=500;\nGETNAMES = YES;\nRUN;\n````\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE gapsummary AS\nSELECT DISTINCT country, COUNT(*) AS n, \nSUM(MISSING(lifeExp)) AS missinglifeExp, \nSUM(MISSING(pop)) AS missingpop,\nSUM(MISSING(gdpPercap)) AS missingGDP\nFROM classdat.gapminder\nGROUP BY country;\n\n/* Print the problem countries only */\nPROC PRINT DATA = gapsummary;\nWHERE n ^= 12;\nRUN;\n```\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE gap5 AS\nSELECT *\nFROM classdat.gapminder\nWHERE MOD(year, 5) = 2;\n\n/* Aus had too much data, so use it to see if the command worked */\nPROC PRINT DATA = gap5;\nWHERE country = \"Australia\";\nRUN;\n```\n\n```\nlibname classdat \"sas/\";\n\nPROC SQL;\nCREATE TABLE gap5 AS\nSELECT *\nFROM classdat.gapminder\nWHERE MOD(year, 5) = 2;\n\nCREATE TABLE gap_clean AS\nSELECT *, COUNT(*) as n \nFROM gap5\nGROUP BY country\nHAVING n = 12;\n\n/* Clean up extra column */\nALTER TABLE gap_clean \nDROP n;\n\nPROC PRINT DATA = gap_clean;\nRUN;\n```\n\n## References {#refs-sas}\n\n\n- [SAS quick start guide](https://towardsdatascience.com/getting-started-with-sas-beginner-354a94a48f08)\n\n- [SAS Cheatsheet (from another class like this)](https://sites.ualberta.ca/~ahamann/teaching/renr480/SAS-Cheat.pdf)\n- [SAS Cheatsheet (by SAS)](https://support.sas.com/content/dam/SAS/support/en/books/data/base-syntax-ref.pdf)\n- [SAS Programming for R Users (free book)](https://support.sas.com/content/dam/SAS/support/en/books/free-books/sas-programming-for-r-users.pdf)\n\n\n- [SAS Matrix reference](http://www.math.wpi.edu/saspdf/iml/chap4.pdf)\n- [SAS Data set documentation](https://documentation.sas.com/?docsetId=basess&docsetTarget=p1f5xhmkdfhyjcn1n6k9wdcacba0.htm&docsetVersion=9.4&locale=en)\n- [Creating SAS Data Sets from IML](https://support.sas.com/content/dam/SAS/support/en/books/simulating-data-with-sas/65378_Appendix_A_A_SAS_IML_Primer.pdf) (also [this](https://education.illinois.edu/docs/default-source/carolyn-anderson/edpsy584/SAS_iml.pdf) friendly guide and [this](https://blogs.sas.com/content/iml/2019/07/17/write-numeric-character-matrices-data-set.html) blog post)\n- [SAS Data Step options](https://libguides.library.kent.edu/SAS/DataStep)\n- [SAS Mathematical Operators](https://www.tutorialspoint.com/sas/sas_operators.htm)\n- [Lists and Data Structures in SAS](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_lists_gettingstarted03.htm&docsetVersion=14.3&locale=en)\n- [Loops in SAS](https://blogs.sas.com/content/iml/2011/09/07/loops-in-sas.html) and [SAS documentation for DO WHILE](https://support.sas.com/documentation/cdl/en/lestmtsref/63323/HTML/default/viewer.htm#p1awxgleif5wlen1pja0nrn6yi6i.htm) loops\n- [Random number generation in SAS](https://www.sas.com/content/dam/SAS/support/en/sas-global-forum-proceedings/2018/1810-2018.pdf)\n\n\n### Data Files\n\n\n- [Reading JSON in SAS](https://support.sas.com/resources/papers/proceedings17/0856-2017.pdf) -- You know SAS documentation is getting weird when they advertise a method as \"the sexiest way to import JSON data into SAS\". \n- [Reading Rdata files in SAS](http://proc-x.com/2015/05/import-rdata-to-sas-along-with-labels/)\n- [Common problems with SAS data files](https://blogs.sas.com/content/sgf/2015/04/17/turning-text-files-into-sas-data-sets-6-common-problems-and-their-solutions/)\n\n\n### Data Cleaning\n\n- [SAS Dates and Times](https://documentation.sas.com/?docsetId=lrcon&docsetTarget=p1wj0wt2ebe2a0n1lv4lem9hdc0v.htm&docsetVersion=9.4&locale=en).\n- [Common String operations in SAS](https://www.listendata.com/2014/12/sas-character-functions.html)\n- [Regular Expressions in SAS](https://support.sas.com/resources/papers/proceedings/proceedings/sugi29/265-29.pdf)\n\n- [Using WHERE with SAS Procedures](https://stats.idre.ucla.edu/sas/modules/using-where-with-sas-procedures/)\n- [PROC SQL documentation](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=n1oihmdy7om5rmn1aorxui3kxizl.htm&docsetVersion=9.4&locale=en)\n- [SAS data manipulation](https://vknight.org/SAS-R/Content/SAS-Chapter-03/)\n",
    "supporting": [
      "app-sas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": {},
    "postProcess": true
  }
}