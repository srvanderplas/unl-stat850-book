{
  "hash": "78b531c9e2da2f668c0013ebdbefb6c6",
  "result": {
    "markdown": "\n# Data Structures\n\n## Module Objectives {#module-4-objectives .unnumbered}\n\n-   Know the types of data structures and what restrictions each has\n-   Use indexing to pull information out of data structures\n-   Do basic mathematical calculations on scalars, vectors, and matrices\n-   Understand which data structures are included in the base language and which require add-on packages\n\n## Introduction\n\nData **structures** are more complex arrangements of information than single variables. Of primary interest in statistical programming are the following types of structures, illustrated with Lego pieces (piece size indicates \"data type\"):\n\n| Â    | Homogeneous | Heterogeneous |\n| --- | ---------- | ---------- |\n| 1d  | ![A lego vector made out of a row of 1x3 blocks](images/data-structures/lego-1x3-vector.png)                      | ![A lego list made out of a row of differently-sized lego bricks](images/data-structures/lego-list.png)                                                                                     |\n| | vector (R, python)<br/>Series (Pandas) | list (R, python)<br/>dict (python)<br/>tuple (python) |\n| 2d  | ![A lego matrix made out of a 3x4 rectangle of individual 2x2 bricks](images/data-structures/lego-2x2-matrix.png) | ![A lego data frame made out of multiple columns of bricks where each column is a different size of brick (representing a different data type)](images/data-structures/lego-data-frame.png) |\n| | matrix (R)<br/>ndarray(Numpy) | data frame (R, Pandas)<br/>data set (SAS) |\n| nd  | ![A 4x3x3 matrix/ndarray of 2x2 bricks of different colors.](images/data-structures/lego-ndarray.png)             |                                                                                                                                                                                        |\n| | array (R)<br/>ndarray(Numpy) |\n\n\n: Common data structures as implemented in various statistical programming languages. Where applicable, specific package names are listed (e.g. in Python, Numpy and Pandas). {#tbl-structure-lego}\n\n::: {.callout-note}\n\nFiguring out what to call these types with multiple languages is hard: in SAS, an array is a group of columns of a data set, but in R, it's a multi-dimensional matrix, and in Python it's a ndarray. I've attempted to separate out language-specific content (e.g. how to do X in python or R) from the general concepts where possible.\n\n:::\n\n\n## Homogeneous data structures {- .unnumbered}\n\n## Scalars\n\nR does not have scalar types - even single-value variables are technically vectors of length 1. SAS and Python do have scalar types. Creating scalars is as simple as defining a variable, which you have already seen before.\n\n## Vectors\n\nVectors are constrained so that all items in a vector must be of the same type. When necessary, this means that variables will be type-converted, as shown above.\n\n::: panel-tabset\n\n### R {.unnumbered .unnumbered}\n\nIn R, creating a vector is as easy as using the `c()` (concatenate) function. To create a vector of sequential integers, we use `start:end`, where start and end are integers. To create a finer-grained sequence, such as counting from 1 to 10 by 0.05, we would use the `seq()` function. `seq()` also has an argument named `length.out` which allows you to specify the vector length; the interval between successive numbers is then automatically calculated for you.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigits_of_pi <- c(3, 1, 4, 1, 5, 9)\n\nseq_10 <- 1:10\n\ntmp <- seq(1, 10, by = 0.05)\n\ntmp2 <- seq(1, 10, length.out = 100)\n```\n:::\n\n\n### Python {.unnumbered .unnumbered}\n\nIn python, we will use the NumPy package to create arrays of any dimension. First, we have to tell Python we want to use the `numpy` package, and what we're going to call it. Usually, this means that we add the line `import numpy as np` so that we call any functions in the package using `np.function_name()`.\n\nThe next thing to realize is that by default, python doesn't have a vector/matrix/array type - this is something added in numpy. So we'll be using lists to create our default data structures, and then converting them into numpy objects.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\nlst = [3, 1, 4, 1, 5, 9] # this is a list\n\ndigits_of_pi = np.array(lst) # this creates a vector\n\nseq_10 = np.array(range(1, 10))\n\ntmp = np.arange(1, 10, step = 0.05)\n\ntmp2 = np.linspace(1, 10, 100)\n```\n:::\n\nThe `range` function defines a range from 1 to 10, and the `np.array()` function converts that into a vector of integers counting from 1 to 10. In the next step, we use the `np.arange` function to specify what the step size we want is. Finally, we specify a vector of length 100 using the `np.linspace` function. \n\n:::\n\n:::{.callout-tip}\n### Try it out: Vectors {- }\n\n::: panel-tabset\n\n#### Problem {- .unnumbered}\n\nIf we try to create a heterogeneous vector in R, using the `concatenate` function, `c()`, which combines scalar entries into a vector, what happens?\n\n#### Solution {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, \"a\", \"b\", \"c\")\n## [1] \"1\" \"2\" \"a\" \"b\" \"c\"\n```\n:::\n\n\nBecause there were 3 character entries, the entire vector is now a character vector.\n\n:::\n:::\n\n## Matrices and Arrays\n\nMatrices (2 dimensional) and arrays (>2 dimensional) are homogeneous, rectangular arrangements of data. They may have dimension names in R (but not in python). \n\n::: panel-tabset\n\n### R {- .unnumbered}\n\nLet's start out by creating a 3x4 matrix (3 rows, 4 columns) of the digits 1:12.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:12, 3, 4)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9   12\n```\n:::\n\n\nBy default, R fills in everything column-by-column. If we want to change that behavior, we use the `byrow` option:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:12, 3, 4, byrow = T)\n##      [,1] [,2] [,3] [,4]\n## [1,]    1    2    3    4\n## [2,]    5    6    7    8\n## [3,]    9   10   11   12\n```\n:::\n\n\nIf we want to create a higher-order array in R, we use the `array` command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray(1:12, dim = c(2, 2, 3))\n## , , 1\n## \n##      [,1] [,2]\n## [1,]    1    3\n## [2,]    2    4\n## \n## , , 2\n## \n##      [,1] [,2]\n## [1,]    5    7\n## [2,]    6    8\n## \n## , , 3\n## \n##      [,1] [,2]\n## [1,]    9   11\n## [2,]   10   12\n```\n:::\n\n\nNote that higher-dimension arrays are hard to print and visualize.\n\nIt is easy enough to create an array that has all 0's or 1's in it as well - I have used 1:12 here to show you how things get populated to different slices of the array, but any vector will work to initialize your array.\n\n### Python {-}\n\nIf a vector and a list are relatively similar in structure, we can think up an analogue of the matrix as a list of lists of the same length. Note that this is only necessary because by default, Python has a list type but not a vector type; numpy adds the ability to deal with vectors and arrays directly, but we must first construct them out of something that makes sense to base python.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# Different shapes matter\n[[1, 2, 3], [4, 5, 6]] \n## [[1, 2, 3], [4, 5, 6]]\n[[1,2], [3,4], [5,6]] \n# Row by row inside the first-level list\n## [[1, 2], [3, 4], [5, 6]]\nnp.array([[1, 2, 3], [4, 5, 6]]) \n## array([[1, 2, 3],\n##        [4, 5, 6]])\nnp.array([[1,2], [3,4], [5,6]])\n## array([[1, 2],\n##        [3, 4],\n##        [5, 6]])\n```\n:::\n\n\nIf we instead want to create a matrix of 0s, we can do that using the `np.zeros` function.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.zeros(shape=(2, 2, 3), dtype=float)\n## array([[[0., 0., 0.],\n##         [0., 0., 0.]],\n## \n##        [[0., 0., 0.],\n##         [0., 0., 0.]]])\n```\n:::\n\n\nFilling the matrix with non-zero values is a different challenge that requires us to talk about indexing (discussed below).\n\n:::\n\n\n## Overgrown Calculators\n\nWhile R, SAS, and Python are all extremely powerful statistical programming languages, the core of most programming languages is the ability to do basic calculations and matrix arithmetic. As almost every dataset is stored as a matrix-like structure (data sets and data frames both allow for multiple types, which isn't quite compatible with more canonical matrices), it is useful to know how to do matrix-level calculations in whatever language you are planning to use to work with data.\n\nIn this section, we will essentially be using our programming language as overgrown calculators.\n\nIn the next chapters we'll talk about data types and structures, so you'll get to see more about matrices and arrays, but for now, let's confine ourselves to using R and python to do basic math calculations.\n\n\n| Operation                    | R      | SAS                             | Python     |\n|:---------|:-------|:-------|:-------|\n| Addition                     | \\+     | \\+                              | \\+         |\n| Subtraction                  | \\-     | \\-                              | \\-         |\n| Elementwise Multiplication   | \\*     | \\#                              | \\*         |\n| Division                     | /      | /                               | /          |\n| Modulo (Remainder)           | %%     | MOD                             | %          |\n| Integer Division             | %/%    | FLOOR(x\\\\y)                     | //         |\n| Elementwise Exponentiation   | \\^     | \\##                             | `**`       |\n| Matrix/Vector Multiplication | %\\*%   | \\*                              |  `np.dot()`          |\n| Matrix Exponentiation        | \\^     | \\*\\*                            | `np.exp()` |\n| Matrix Transpose             | `t(A)` | `A`\\` | `np.transpose(A)` |            |\n| Matrix Determinant | `det(A)` | `det(A)` | `np.linalg.det(A)` |\n| Matrix Diagonal | `diag(A)` | `diag(A)` | `np.linalg.diag(A)` |\n| Matrix Inverse | `solve(A)` | `solve(A, diag({...}))` | `np.linalg.inv(A)` |\n\n: Table of common mathematical and matrix operations in R, SAS, and Python [@PythonProgramming]. {#tbl-math-ops}\n\n\n### Basic Mathematical Operators \n\n::: panel-tabset\n\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- seq(3, 30, by = 3)\n\nx + y\n##  [1]  4  8 12 16 20 24 28 32 36 40\nx - y\n##  [1]  -2  -4  -6  -8 -10 -12 -14 -16 -18 -20\nx * y\n##  [1]   3  12  27  48  75 108 147 192 243 300\nx / y\n##  [1] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333\n##  [8] 0.3333333 0.3333333 0.3333333\nx^2\n##  [1]   1   4   9  16  25  36  49  64  81 100\nt(x) %*% y\n##      [,1]\n## [1,] 1155\n```\n:::\n\n\n#### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\nx = np.array(range(1, 11))\ny = np.array(range(3, 33, 3)) # python indexes are not inclusive\n\nx + y\n## array([ 4,  8, 12, 16, 20, 24, 28, 32, 36, 40])\nx - y\n## array([ -2,  -4,  -6,  -8, -10, -12, -14, -16, -18, -20])\nx * y\n## array([  3,  12,  27,  48,  75, 108, 147, 192, 243, 300])\nx / y\n## array([0.33333333, 0.33333333, 0.33333333, 0.33333333, 0.33333333,\n##        0.33333333, 0.33333333, 0.33333333, 0.33333333, 0.33333333])\nx ** 2\n## array([  1,   4,   9,  16,  25,  36,  49,  64,  81, 100])\nnp.dot(x.T, y)\n## 1155\n```\n:::\n\n\n#### SAS {.unnumbered}\n\nBy default, SAS creates row vectors with `do(a, b, by = c)` syntax. The transpose operator (a single backtick) can be used to transform `A` into `A`\\`.\n\n    proc iml; \n      x = do(1, 10, 1);\n      y = do(3, 30, 3);\n\n      z = x + y;\n      z2 = x - y;\n      z3 = x # y;\n      z4 = x/y;\n      z5 = x##2;\n      z6 = x` * y;\n      print z, z2, z3, z4, z5, z6;\n    quit;\n:::\n\n### Matrix Operations\n\nOther matrix operations, such as determinants and extraction of the matrix diagonal, are similarly easy:\n\n::: panel-tabset\n\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)\nmat\n##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    6    4    5\n## [3,]    7    8    9\nt(mat) # transpose\n##      [,1] [,2] [,3]\n## [1,]    1    6    7\n## [2,]    2    4    8\n## [3,]    3    5    9\ndet(mat) # get the determinant\n## [1] 18\ndiag(mat) # get the diagonal\n## [1] 1 4 9\ndiag(diag(mat)) # get a square matrix with off-diag 0s\n##      [,1] [,2] [,3]\n## [1,]    1    0    0\n## [2,]    0    4    0\n## [3,]    0    0    9\ndiag(1:3) # diag() also will create a diagonal matrix if given a vector\n##      [,1] [,2] [,3]\n## [1,]    1    0    0\n## [2,]    0    2    0\n## [3,]    0    0    3\n```\n:::\n\n\n#### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nmat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')\n\nmat\n## array([[1, 2, 3],\n##        [6, 4, 5],\n##        [7, 8, 9]])\nmat.T\n## array([[1, 6, 7],\n##        [2, 4, 8],\n##        [3, 5, 9]])\nnp.linalg.det(mat) # numerical precision...\n## 18.000000000000004\nnp.diag(mat)\n## array([1, 4, 9])\nnp.diag(np.diag(mat))\n## array([[1, 0, 0],\n##        [0, 4, 0],\n##        [0, 0, 9]])\nnp.diag(range(1, 4))\n## array([[1, 0, 0],\n##        [0, 2, 0],\n##        [0, 0, 3]])\n```\n:::\n\n\n#### SAS {.unnumbered}\n\n    proc iml;\n      mat = {1 2 3, 6 4 5, 7 8 9}; \n      tmat = mat`; /* transpose */\n      determinant = det(mat); /* get the determinant */\n      diagonal_vector = vecdiag(mat); /* get the diagonal as a vector */\n      diagonal_mat = diag(mat); /* get the diagonal as a square matrix */\n                                /* with 0 on off-diagonal entries */\n      \n      dm = diag({1 2 3}); /* make a square matrix with vector as the diagonal */\n      \n      print tmat, determinant, diagonal_vector, diagonal_mat, dm;\n    quit;\n:::\n\n\n### Matrix Inverse\n\nThe other important matrix-related function is the inverse. In R, `A^-1` will get you the elementwise reciprocal of the matrix. Not exactly what we'd like to see... Instead, in R and SAS, we use the `solve()` function. The inverse is defined as the matrix B such that `AB = I` where `I` is the identity matrix (1's on diagonal, 0's off-diagonal). So if we `solve(A)` (in R) or `solve(A, diag(n))` in SAS (where n is a vector of 1s the size of A), we will get the inverse matrix. In Python, we use the `np.linalg.inv()` function to invert a matrix, which is a bit more linguistically familiar.\n\n::: panel-tabset\n#### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)\n\nminv <- solve(mat) # get the inverse\n\nminv\n##            [,1]       [,2]       [,3]\n## [1,] -0.2222222  0.3333333 -0.1111111\n## [2,] -1.0555556 -0.6666667  0.7222222\n## [3,]  1.1111111  0.3333333 -0.4444444\nmat %*% minv \n##      [,1] [,2] [,3]\n## [1,]    1    0    0\n## [2,]    0    1    0\n## [3,]    0    0    1\n```\n:::\n\n\n#### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nmat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')\n\nminv = np.linalg.inv(mat)\nminv\n## array([[-0.22222222,  0.33333333, -0.11111111],\n##        [-1.05555556, -0.66666667,  0.72222222],\n##        [ 1.11111111,  0.33333333, -0.44444444]])\nnp.dot(mat, minv)\n## array([[ 1.00000000e+00,  0.00000000e+00,  1.11022302e-16],\n##        [-8.88178420e-16,  1.00000000e+00, -5.55111512e-16],\n##        [ 0.00000000e+00,  2.22044605e-16,  1.00000000e+00]])\nnp.round(np.dot(mat, minv), 2)\n## array([[ 1.,  0.,  0.],\n##        [-0.,  1., -0.],\n##        [ 0.,  0.,  1.]])\n```\n:::\n\n\n#### SAS {.unnumbered}\n\n[Documentation](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_langref_sect208.htm&docsetVersion=14.2&locale=en)\n\n```\n    proc iml;\n      mat = {1 2 3, 6 4 5, 7 8 9};\n\n      mat_inv = solve(mat, diag({1 1 1})); /* get the inverse */\n      mat_inv2 = inv(mat); /* less efficient and less accurate */\n      print mat_inv, mat_inv2;\n\n      id = mat * mat_inv;\n      id2 = mat * mat_inv2;\n      print id, id2; \n    quit;\n```\n\n:::\n\n\n## Heterogeneous data structures {- .unnumbered}\n\nThe heterogeneous data types are not much harder to grasp, as they're mostly different ways to combine various homogeneous data types.\n\n## One-dimensional structures\n\nIn R and SAS, lists are the basic building block of one-dimensional data structures. Python makes this a bit more complicated, as it has several different one-dimensional heterogeneous data structures that we'll have to cover. I've restructured this section considerably during the transition to R + Python as the main focus of this class, but I'd encourage you to read this section with a focus on lists and just keep in mind what the differences are between the structures - you don't have to remember them, but know where to look it up.\n\nType | Language | Named? | Ordered/Indexable | Other Notes\n--- | --- | --- | --- | --- |\nList | R | yes | yes | basic heterogeneous data type\nData frame | R | yes | yes | essentially a list of vectors of the same length\nList | python | no | yes | \nTuple | python | no | yes | cannot be edited once created\nDictionary | python | yes: key-value pairs | yes (Python 3.7)<br/> no (Python < 3.7) | cannot have duplicate keys\n\n\n### Lists\n\nA **list** is a sequence of different-typed values. \n\nUnlike when concatenating values, the `list()` command in R allows each value to keep its natural type. In Python, the default complex data type is a list; more strict data types are then converted from lists to more structured formats using e.g. `np.array` or `pd.DataFrame`. \n\n\n::: panel-tabset\n\n#### R {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(\"a\", \"b\", \"c\", 1, 2, 3)\n\nx\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] \"b\"\n## \n## [[3]]\n## [1] \"c\"\n## \n## [[4]]\n## [1] 1\n## \n## [[5]]\n## [1] 2\n## \n## [[6]]\n## [1] 3\nx[[1]] # Indexes start at 1 in R\n## [1] \"a\"\n\nx[[4]] + x[[5]]\n## [1] 3\n\nx[1:2] # This will work\n## [[1]]\n## [1] \"a\"\n## \n## [[2]]\n## [1] \"b\"\n\nx[[1:2]] # This won't work\n## Error in x[[1:2]]: subscript out of bounds\n```\n:::\n\n\nSome lists (and data frames) consist of named variables. These list components can be accessed either by index (as above) or by name, using the `$` operator. Names which have spaces or special characters must be enclosed in backticks (next to the 1 on the keyboard). Named components can also be accessed using the `[[ ]]` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndog <- list(name = \"Edison Vanderplas\", age = 9, \n            breed = \"Jack Russell Terrorist\", \n            `favorite toy` = \"a blue and orange stuffed duck. Or rawhide.\",\n            `link(video)` = \"https://youtu.be/zVeoQTOTIuQ\")\n\ndog\n## $name\n## [1] \"Edison Vanderplas\"\n## \n## $age\n## [1] 9\n## \n## $breed\n## [1] \"Jack Russell Terrorist\"\n## \n## $`favorite toy`\n## [1] \"a blue and orange stuffed duck. Or rawhide.\"\n## \n## $`link(video)`\n## [1] \"https://youtu.be/zVeoQTOTIuQ\"\n\ndog$name\n## [1] \"Edison Vanderplas\"\ndog$breed\n## [1] \"Jack Russell Terrorist\"\ndog$`favorite toy`\n## [1] \"a blue and orange stuffed duck. Or rawhide.\"\ndog[[\"link(video)\"]]\n## [1] \"https://youtu.be/zVeoQTOTIuQ\"\n```\n:::\n\n\nYou can get a sense of the structure of a list (or any other object) in R using the `str()` command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nstr(dog)\n## List of 5\n##  $ name        : chr \"Edison Vanderplas\"\n##  $ age         : num 9\n##  $ breed       : chr \"Jack Russell Terrorist\"\n##  $ favorite toy: chr \"a blue and orange stuffed duck. Or rawhide.\"\n##  $ link(video) : chr \"https://youtu.be/zVeoQTOTIuQ\"\n```\n:::\n\n\n#### Python {- .unnumbered}\n\nUnlike in R, lists in python cannot have named entries. Lists are a basic data structure in python, so they exist in base Python without needing to load e.g. `Numpy` or `Pandas`. As a reminder, Python is a 0-indexed language, so you will need to count starting at 0 instead of 1 to determine what elements you want to pull out of a list.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = ['a', 'b', 'c', 1, 2, 3]\n\nx\n## ['a', 'b', 'c', 1, 2, 3]\nx[0] # Indexes start at 0 in python\n## 'a'\nx[1:2] # Python indexes are [a, b); if you want b, use [a, b+1)\n## ['b']\nx[2:4]\n## ['c', 1]\n```\n:::\n\n\n:::\n\n### Tuple\n\nPython contains a data type called a **Tuple** used to store multiple items in a single variable. Tuples are **ordered** and **unchangeable** - Once stored, you cannot update them. Tuples can store more than one data type.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmytuple = (\"apple\", \"banana\", 3)\nmytuple[0]\n## 'apple'\nmytuple[1]\n## 'banana'\nmytuple[2]\n## 3\nmytuple\n## ('apple', 'banana', 3)\n```\n:::\n\n\n::: {.callout-important}\n\nNotice that the syntax for making a tuple is very similar to the syntax for making a list - the only difference is that tuples use () and lists use []. \n\n:::\n\nIt's worth knowing about tuples, but I wouldn't worry about using them frequently until you get better at programming. You can check out this article about [Lists, Arrays, and Tuples](https://www.geeksforgeeks.org/python-list-vs-array-vs-tuple/) for more information.\n\n### Dictionary\n\nAnother basic data type in Python used to store multiple pieces of data is a **dictionary**. \n\nA dictionary is ordered (in Python 3.7+), changeable, and does not allow duplicates.\n\nDictionaries are written with curly brackets, and have **keys** and **values**, where we use the syntax `key:value` (with quotes around strings). \n\n\n::: {.cell}\n\n```{.python .cell-code}\ndogdict = {\n  \"name\": \"Edison\",\n  \"age\": 9,\n  \"breed\": \"Jack Russell Terrorist\",\n  \"energy_level\": \"high\"\n}\nprint(dogdict)\n## {'name': 'Edison', 'age': 9, 'breed': 'Jack Russell Terrorist', 'energy_level': 'high'}\ndogdict[\"name\"]\n## 'Edison'\ndogdict[0] # dicts can be indexed by key but not by position\n## Error in py_call_impl(callable, dots$args, dots$keywords): KeyError: 0\ndogdict[\"color\"] = \"white\" # add a new item by adding a new key and assigning a value\ndogdict\n## {'name': 'Edison', 'age': 9, 'breed': 'Jack Russell Terrorist', 'energy_level': 'high', 'color': 'white'}\n```\n:::\n\n\n\n### Series\n\nThe Pandas package contains a data type called a **Series** - essentially, it's a one-dimensional vector with axis labels. This is roughly equivalent to a named vector in R.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ns1 = pd.Series([3,1,4,1,5])\ns1 # by default, the key is just the numeric index\n## 0    3\n## 1    1\n## 2    4\n## 3    1\n## 4    5\n## dtype: int64\ns1[0]\n\n# we can set labeled keys by converting a dict to a series\n## 3\ns2 = pd.Series({\"susan\":1987,\"ryan\":1986,\"alex\":2016,\"zoey\":2021})\ns2 \n\n# Series can be indexed by position or by key\n## susan    1987\n## ryan     1986\n## alex     2016\n## zoey     2021\n## dtype: int64\ns2[0]\n## 1987\ns2[\"zoey\"]\n## 2021\n```\n:::\n\n\n\n### Level Up: Recursive structures \n\nLists, dicts, and other one-dimensional structures can also contain containers - vectors, lists, or other multi-element items. When accessing a list-within-a-list, just add another index or name reference (see below).\n\n:::{.callout-caution}\n#### Example: Recursive lists\n\n::: panel-tabset\n\n#### R {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrocery_list <- list(\n  dairy = c(\"asiago\", \"fontina\", \"mozzarella\", \"blue cheese\"),\n  baking = c(\"flour\", \"yeast\", \"salt\"),\n  canned_goods = c(\"pepperoni\", \"pizza sauce\", \"olives\"),\n  meat = c(\"bacon\", \"sausage\", \"anchovies\"),\n  veggies = c(\"bell pepper\", \"onion\", \"scallions\", \"tomatoes\", \"basil\")\n)\n\nick <- c(grocery_list[[4]][2:3], grocery_list$canned_goods[[3]])\nick\n## [1] \"sausage\"   \"anchovies\" \"olives\"\n\ncrust_ingredients <- c(grocery_list$baking, \"water\")\ncrust_ingredients\n## [1] \"flour\" \"yeast\" \"salt\"  \"water\"\n\nessential_toppings <- c(grocery_list$dairy[3], grocery_list$canned_goods[2])\nessential_toppings\n## [1] \"mozzarella\"  \"pizza sauce\"\n\nyummy_toppings <- c(grocery_list$dairy[c(1, 2, 4)], grocery_list$meat[1], grocery_list[[5]][c(3, 5)])\nyummy_toppings\n## [1] \"asiago\"      \"fontina\"     \"blue cheese\" \"bacon\"       \"scallions\"  \n## [6] \"basil\"\n```\n:::\n\n\n\n#### Python {- .unnumbered}\n\nIn python we have to use a dict of lists, which doesn't quite work as well - but we have to do that mostly because the pizza example makes sense with named lists. If we used unnamed lists, we could do the whole thing as a list of lists, just like in R.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngrocery_list = {\n  \"dairy\": [\"asiago\", \"fontina\", \"mozzarella\", \"blue cheese\"],\n  \"baking\": [\"flour\", \"yeast\", \"salt\"],\n  \"canned_goods\": [\"pepperoni\", \"pizza sauce\", \"olives\"],\n  \"meat\": [\"bacon\", \"sausage\", \"anchovies\"],\n  \"veggies\": [\"bell pepper\", \"onion\", \"scallions\", \"tomatoes\", \"basil\"]\n  }\n  \nick = [grocery_list[\"meat\"][1:3], [grocery_list[\"canned_goods\"][2]]]\nick # this is a nested list, which isn't ideal\n## [['sausage', 'anchovies'], ['olives']]\nfrom itertools import chain\nick = list(chain(*ick)) # this unnests the list to a single level\n\ncrust_ingredients = [grocery_list[\"baking\"], [\"water\"]]\ncrust_ingredients = list(chain.from_iterable(crust_ingredients))\ncrust_ingredients\n## ['flour', 'yeast', 'salt', 'water']\nessential_toppings = [grocery_list[\"dairy\"][2], grocery_list[\"canned_goods\"][1]]\nessential_toppings\n## ['mozzarella', 'pizza sauce']\nyummy_toppings = [\n  grocery_list[\"dairy\"][0:2], \n  [\n    grocery_list[\"dairy\"][3], \n    grocery_list[\"meat\"][0], \n    grocery_list[\"veggies\"][2], \n    grocery_list[\"veggies\"][4]\n  ]# it works best to put individual entries in a list so that \n   # chain.from_iterable() works out\n  ]\n\nyummy_toppings = list(chain.from_iterable(yummy_toppings))\nyummy_toppings\n## ['asiago', 'fontina', 'blue cheese', 'bacon', 'scallions', 'basil']\n```\n:::\n\n\n:::\n\n:::\n\n:::{.callout-tip}\n#### Try it out: Lists {.unnumbered}\n\nUsing the list of pizza toppings above as a starting point, make your own list of pizza toppings organized by grocery store section (approximately). Create your own vectors of yummy, essential, and ick toppings, using R and Python.\n:::\n\n\n## Data frames\n\nA data frame is a special type of list - one in which each element in the list is a vector of the same length. If you put these vectors side-by-side, you get a table of data that looks like a spreadsheet. In Python, a DataFrame is a dict of Series. \n\n\nThe lego version of a data frame looks like this:\n\n![A data frame with 4 columns. A data frame is essentially a list where all of the components are vectors or lists, and are constrained to have the same length.](images/data-structures/lego-data-frame.png){width=50%}\n\n\n\n::: panel-tabset\n\n### R {- .unnumbered}\n\nWhen you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The `head(n)` command shows the first $n$ rows of a data frame (enough to see what's there, not enough to overflow your screen).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(mtcars) ## A data frame included in base R\n##                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n## Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n## Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n## Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n## Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\nstr(mtcars)\n## 'data.frame':\t32 obs. of  11 variables:\n##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n##  $ disp: num  160 160 108 258 360 ...\n##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n##  $ qsec: num  16.5 17 18.6 19.4 17 ...\n##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n```\n:::\n\n\nYou can change column values or add new columns easily using assignment. It's also easy to access specific columns to perform summary operations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$gpm <- 1/mtcars$mpg # gpm is sometimes used to assess efficiency\n\nsummary(mtcars$gpm)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n## 0.02950 0.04386 0.05208 0.05423 0.06483 0.09615\nsummary(mtcars$mpg)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   10.40   15.43   19.20   20.09   22.80   33.90\n```\n:::\n\n\nOften, it is useful to know the dimensions of a data frame. The number of rows can be obtained by using `nrow(df)` and similarly, the columns can be obtained using `ncol(df)` (or, get both with `dim()`). There is also an easy way to get a summary of each column in the data frame, using `summary()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mtcars)\n##       mpg             cyl             disp             hp       \n##  Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n##  1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n##  Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n##  Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n##  3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n##  Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n##       drat             wt             qsec             vs        \n##  Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n##  1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n##  Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n##  Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n##  3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n##  Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n##        am              gear            carb            gpm         \n##  Min.   :0.0000   Min.   :3.000   Min.   :1.000   Min.   :0.02950  \n##  1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000   1st Qu.:0.04386  \n##  Median :0.0000   Median :4.000   Median :2.000   Median :0.05208  \n##  Mean   :0.4062   Mean   :3.688   Mean   :2.812   Mean   :0.05423  \n##  3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000   3rd Qu.:0.06483  \n##  Max.   :1.0000   Max.   :5.000   Max.   :8.000   Max.   :0.09615\ndim(mtcars)\n## [1] 32 12\nnrow(mtcars)\n## [1] 32\nncol(mtcars)\n## [1] 12\n```\n:::\n\n\nMissing variables in an R data frame are indicated with NA.\n\n### Python {- .unnumbered}\n\nWhen you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The `df.head(n)` command shows the first $n$ rows of a data frame (enough to see what's there, not enough to overflow your screen).\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmtcars = pd.read_csv(\"https://vincentarelbundock.github.io/Rdatasets/csv/datasets/mtcars.csv\")\n\nmtcars.head(5)\n##           Unnamed: 0   mpg  cyl   disp   hp  ...   qsec  vs  am  gear  carb\n## 0          Mazda RX4  21.0    6  160.0  110  ...  16.46   0   1     4     4\n## 1      Mazda RX4 Wag  21.0    6  160.0  110  ...  17.02   0   1     4     4\n## 2         Datsun 710  22.8    4  108.0   93  ...  18.61   1   1     4     1\n## 3     Hornet 4 Drive  21.4    6  258.0  110  ...  19.44   1   0     3     1\n## 4  Hornet Sportabout  18.7    8  360.0  175  ...  17.02   0   0     3     2\n## \n## [5 rows x 12 columns]\nmtcars.info()\n## <class 'pandas.core.frame.DataFrame'>\n## RangeIndex: 32 entries, 0 to 31\n## Data columns (total 12 columns):\n##  #   Column      Non-Null Count  Dtype  \n## ---  ------      --------------  -----  \n##  0   Unnamed: 0  32 non-null     object \n##  1   mpg         32 non-null     float64\n##  2   cyl         32 non-null     int64  \n##  3   disp        32 non-null     float64\n##  4   hp          32 non-null     int64  \n##  5   drat        32 non-null     float64\n##  6   wt          32 non-null     float64\n##  7   qsec        32 non-null     float64\n##  8   vs          32 non-null     int64  \n##  9   am          32 non-null     int64  \n##  10  gear        32 non-null     int64  \n##  11  carb        32 non-null     int64  \n## dtypes: float64(5), int64(6), object(1)\n## memory usage: 3.1+ KB\n```\n:::\n\n\nYou can change column values or add new columns easily using assignment. It's also easy to access specific columns to perform summary operations. You can access a column named xyz using `df.xyz` or using `df[\"xyz\"]`. To create a new column, you must use `df[\"xyz\"]`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmtcars[\"gpm\"] = 1/mtcars.mpg # gpm is sometimes used to assess efficiency\n\nmtcars.gpm.describe()\n## count    32.000000\n## mean      0.054227\n## std       0.016424\n## min       0.029499\n## 25%       0.043860\n## 50%       0.052083\n## 75%       0.064834\n## max       0.096154\n## Name: gpm, dtype: float64\nmtcars.mpg.describe()\n## count    32.000000\n## mean     20.090625\n## std       6.026948\n## min      10.400000\n## 25%      15.425000\n## 50%      19.200000\n## 75%      22.800000\n## max      33.900000\n## Name: mpg, dtype: float64\n```\n:::\n\n\nOften, it is useful to know the dimensions of a data frame. The dimensions of a data frame (rows x columns) can be accessed using `df.shape`. There is also an easy way to get a summary of each column in the data frame, using `df.describe()`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmtcars.describe()\n##              mpg        cyl        disp  ...       gear     carb        gpm\n## count  32.000000  32.000000   32.000000  ...  32.000000  32.0000  32.000000\n## mean   20.090625   6.187500  230.721875  ...   3.687500   2.8125   0.054227\n## std     6.026948   1.785922  123.938694  ...   0.737804   1.6152   0.016424\n## min    10.400000   4.000000   71.100000  ...   3.000000   1.0000   0.029499\n## 25%    15.425000   4.000000  120.825000  ...   3.000000   2.0000   0.043860\n## 50%    19.200000   6.000000  196.300000  ...   4.000000   2.0000   0.052083\n## 75%    22.800000   8.000000  326.000000  ...   4.000000   4.0000   0.064834\n## max    33.900000   8.000000  472.000000  ...   5.000000   8.0000   0.096154\n## \n## [8 rows x 12 columns]\nmtcars.shape\n## (32, 13)\n```\n:::\n\n\nMissing variables in a pandas data frame are indicated with nan or NULL.\n\n\n:::\n\n\n:::{.callout-tip}\n### Try it out: Data Frames {.unnumbered}\n\n::: panel-tabset\n\n#### Setup {- .unnumbered}\n\nThe dataset `state.x77` contains information on US state statistics in the 1970s. By default, it is a matrix, but we can easily convert it to a data frame, as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(state)\nstate_facts <- data.frame(state.x77)\nstate_facts <- cbind(state = row.names(state_facts), state_facts, stringsAsFactors = F) \n# State names were stored as row labels\n# Store them in a variable instead, and add it to the data frame\n\nrow.names(state_facts) <- NULL # get rid of row names\n\nhead(state_facts)\n##        state Population Income Illiteracy Life.Exp Murder HS.Grad Frost   Area\n## 1    Alabama       3615   3624        2.1    69.05   15.1    41.3    20  50708\n## 2     Alaska        365   6315        1.5    69.31   11.3    66.7   152 566432\n## 3    Arizona       2212   4530        1.8    70.55    7.8    58.1    15 113417\n## 4   Arkansas       2110   3378        1.9    70.66   10.1    39.9    65  51945\n## 5 California      21198   5114        1.1    71.71   10.3    62.6    20 156361\n## 6   Colorado       2541   4884        0.7    72.06    6.8    63.9   166 103766\n\n# Write data out so that we can read it in using Python\nwrite.csv(state_facts, file = \"data/state_facts.csv\", row.names = F)\n```\n:::\n\n\nWe can write out the built in R data and read it in using `pd.read_csv`, which creates a DataFrame in pandas.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\nstate_facts = pd.read_csv(\"https://raw.githubusercontent.com/srvanderplas/unl-stat850/main/data/state_facts.csv\")\n```\n:::\n\n\n\n#### Problem {- .unnumbered}\n\n1. How many rows and columns does it have? Can you find different ways to get that information?\n\n2. The `Illiteracy` column contains the percent of the population of each state that is illiterate. Calculate the number of people in each state who are illiterate, and store that in a new column called `TotalNumIlliterate`. Note: `Population` contains the population in thousands.\n\n3. Calculate the average population density of each state (population per square mile) and store it in a new column `PopDensity`. Using the R reference card, can you find functions that you can combine to get the state with the minimum population density?\n\n#### R Solution {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3 ways to get rows and columns\nstr(state_facts)\n## 'data.frame':\t50 obs. of  9 variables:\n##  $ state     : chr  \"Alabama\" \"Alaska\" \"Arizona\" \"Arkansas\" ...\n##  $ Population: num  3615 365 2212 2110 21198 ...\n##  $ Income    : num  3624 6315 4530 3378 5114 ...\n##  $ Illiteracy: num  2.1 1.5 1.8 1.9 1.1 0.7 1.1 0.9 1.3 2 ...\n##  $ Life.Exp  : num  69 69.3 70.5 70.7 71.7 ...\n##  $ Murder    : num  15.1 11.3 7.8 10.1 10.3 6.8 3.1 6.2 10.7 13.9 ...\n##  $ HS.Grad   : num  41.3 66.7 58.1 39.9 62.6 63.9 56 54.6 52.6 40.6 ...\n##  $ Frost     : num  20 152 15 65 20 166 139 103 11 60 ...\n##  $ Area      : num  50708 566432 113417 51945 156361 ...\ndim(state_facts)\n## [1] 50  9\nnrow(state_facts)\n## [1] 50\nncol(state_facts)\n## [1] 9\n\n# Illiteracy\nstate_facts$TotalNumIlliterate <- state_facts$Population * 1e3 * (state_facts$Illiteracy/100) \n\n# Population Density\nstate_facts$PopDensity <- state_facts$Population * 1e3/state_facts$Area \n# in people per square mile\n\n# minimum population\nstate_facts$state[which.min(state_facts$PopDensity)]\n## [1] \"Alaska\"\n```\n:::\n\n\n\n#### Python Solution {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Ways to get rows and columns\nstate_facts.shape\n## (50, 9)\nstate_facts.index.size # rows\n## 50\nstate_facts.columns.size # columns\n## 9\nstate_facts.info() # columns + rows + missing counts + data types\n\n# Illiteracy\n## <class 'pandas.core.frame.DataFrame'>\n## RangeIndex: 50 entries, 0 to 49\n## Data columns (total 9 columns):\n##  #   Column      Non-Null Count  Dtype  \n## ---  ------      --------------  -----  \n##  0   state       50 non-null     object \n##  1   Population  50 non-null     int64  \n##  2   Income      50 non-null     int64  \n##  3   Illiteracy  50 non-null     float64\n##  4   Life.Exp    50 non-null     float64\n##  5   Murder      50 non-null     float64\n##  6   HS.Grad     50 non-null     float64\n##  7   Frost       50 non-null     int64  \n##  8   Area        50 non-null     int64  \n## dtypes: float64(4), int64(4), object(1)\n## memory usage: 3.6+ KB\nstate_facts[\"TotalNumIlliterate\"] = state_facts[\"Population\"] * 1e3 * state_facts[\"Illiteracy\"]/100\n\n# Population Density\nstate_facts[\"PopDensity\"] = state_facts[\"Population\"] * 1e3/state_facts[\"Area\"] \n# in people per square mile\n\n# minimum population\nmin_dens = state_facts[\"PopDensity\"].min()\n# Get location of minimum population\nloc_min_dens = state_facts.PopDensity.isin([min_dens])\n# Pull out matching state\nstate_facts.state[loc_min_dens]\n## 1    Alaska\n## Name: state, dtype: object\n```\n:::\n\n\n:::\n:::\n\n### Creating Data Frames\n\nIt is also possible to create data frames from scratch by building them out of simpler components, such as vectors or dicts of lists. This tends to be useful for small datasets, but it is more common to read data in from e.g. CSV files, which I've used several times already but haven't yet shown you how to do (give it a couple of weeks).\n\n::: panel-tabset\n\n#### R {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmath_and_lsd <- data.frame(\n  lsd_conc = c(1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41),\n  test_score = c(78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97))\nmath_and_lsd\n##   lsd_conc test_score\n## 1     1.17      78.93\n## 2     2.97      58.20\n## 3     3.26      67.47\n## 4     4.69      37.47\n## 5     5.83      45.65\n## 6     6.00      32.92\n## 7     6.41      29.97\n\n# add a column - character vector\nmath_and_lsd$subjective <- c(\"finally coming back\", \"getting better\", \"it's totally better\", \"really tripping out\", \"is it over?\", \"whoa, man\", \"I can taste color, but I can't do math\")\n\nmath_and_lsd\n##   lsd_conc test_score                             subjective\n## 1     1.17      78.93                    finally coming back\n## 2     2.97      58.20                         getting better\n## 3     3.26      67.47                    it's totally better\n## 4     4.69      37.47                    really tripping out\n## 5     5.83      45.65                            is it over?\n## 6     6.00      32.92                              whoa, man\n## 7     6.41      29.97 I can taste color, but I can't do math\n```\n:::\n\n\n\n#### Python {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmath_and_lsd = pd.DataFrame({\n  \"lsd_conc\": [1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41],\n  \"test_score\": [78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97]})\nmath_and_lsd\n\n# add a column - character vector\n##    lsd_conc  test_score\n## 0      1.17       78.93\n## 1      2.97       58.20\n## 2      3.26       67.47\n## 3      4.69       37.47\n## 4      5.83       45.65\n## 5      6.00       32.92\n## 6      6.41       29.97\nmath_and_lsd[\"subjective\"] = [\"finally coming back\", \"getting better\", \"it's totally better\", \"really tripping out\", \"is it over?\", \"whoa, man\", \"I can taste color, but I can't do math\"]\n\nmath_and_lsd\n##    lsd_conc  test_score                              subjective\n## 0      1.17       78.93                     finally coming back\n## 1      2.97       58.20                          getting better\n## 2      3.26       67.47                     it's totally better\n## 3      4.69       37.47                     really tripping out\n## 4      5.83       45.65                             is it over?\n## 5      6.00       32.92                               whoa, man\n## 6      6.41       29.97  I can taste color, but I can't do math\n```\n:::\n\n\n:::\n\n\n## Indexing {#sec-indexing}\n\nNow that you've seen some complex data structures, it's probably a good time to talk about indexing. \n\nIn order to access sub-elements of a complex data structure, we have to **index** the data type. There are two main ways to index something: \n\n- By name\n- By position\n\nNot every data type has both of these options - vectors, for instance, are generally not named, so we typically only index vectors by position^[In R, you can technically index vectors by name as well, but it's not that common]. \n\nDifferences in how things are indexed are one reason that heterogeneous data structures are a bit more complicated in Python than in R - different structures have different indexing rules and/or names attached.\n\nLanguage | Data Type | Index by position | Index by Name\n--- | --- | --- | ---\nR | vector | yes | yes (uncommon)\nR | array/matrix | yes | yes (uncommon)\nR | list | yes | yes\nR | data frame | yes | yes\nR | tibble | yes | yes\nPython | vector | yes | no\nPython | ndarray (numpy) | yes | no\nPython | dict | yes | yes\nPython | Series (pandas) | yes | yes\nPython | DataFrame (pandas) | yes | yes\n\nIn R, you can usually index things using one of `$`, `[]`, and `[[]]`.\n\nIn Python, you can usually index things using one of `[]` or `.loc` or `.iloc`. \n\nSee the examples below for which index methods work with each data type (and why). \n\n::: panel-tabset\n\n### R vector {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyvec <- c(d1 = 3, d2 = 1, d3 = 4, d4 = 1, d5 = 5, d6 = 9) # this is a named vector\n\nmyvec\n## d1 d2 d3 d4 d5 d6 \n##  3  1  4  1  5  9\nmyvec[1:3] # first 3 entries\n## d1 d2 d3 \n##  3  1  4\nmyvec[\"d1\"] # indexing a vector by name\n## d1 \n##  3\nmyvec$d1 # \"atomic vector\" = homogeneous vector; can't index by name using $\n## Error in myvec$d1: $ operator is invalid for atomic vectors\n```\n:::\n\n\n### R matrix {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmymat <- matrix(\n  myvec, nrow = 2, \n  dimnames = list(\n    c('r1', 'r2'), # row names\n    c('c1', 'c2', 'c3') # column names\n  )\n) # this creates a matrix with named rows and columns\n\nmymat\n##    c1 c2 c3\n## r1  3  4  5\n## r2  1  1  9\n\nmymat[1,] # get the first row\n## c1 c2 c3 \n##  3  4  5\nmymat[,1] # get the first column\n## r1 r2 \n##  3  1\nmymat['r1'] # this doesn't find anything\n## [1] NA\nmymat['r1',] # if you tell R to look for the row named 'r1' it actually works\n## c1 c2 c3 \n##  3  4  5\nmymat['c1'] # this doesn't find anything\n## [1] NA\nmymat[,'c1'] # if you tell R to look for the col named 'c1' it actually works\n## r1 r2 \n##  3  1\n\nmymat[,2:3] # get multiple columns and all rows\n##    c2 c3\n## r1  4  5\n## r2  1  9\nmymat[1, 2:3] # get multiple columns and the first row\n## c2 c3 \n##  4  5\n\nmymat$r1 # matrices are still atomic vectors\n## Error in mymat$r1: $ operator is invalid for atomic vectors\n```\n:::\n\n\n### R array {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyarray <- array(\n  1:12, \n  dim = c(2, 2, 3), \n  dimnames = list(\n    c('a1', 'a2'), \n    c('b1', 'b2'), \n    c('c1', 'c2', 'c3')\n  )\n)\n\n# adding another dimension just means we add another entry to our [a, b, c]\n\nmyarray[1, 2, 3]\n## [1] 11\nmyarray[1, 2, ] # leaving out a number provides everything\n## c1 c2 c3 \n##  3  7 11\nmyarray[, 1, 2] \n## a1 a2 \n##  5  6\nmyarray[,,2]\n##    b1 b2\n## a1  5  7\n## a2  6  8\nmyarray[, 3, ] # if you don't keep track of your dimensions you'll get an error\n## Error in myarray[, 3, ]: subscript out of bounds\nmyarray['a1', 'b1', ] # names still work IF you define dimnames (not common)\n## c1 c2 c3 \n##  1  5  9\n\nmyarray$a1 # arrays are still atomic vectors\n## Error in myarray$a1: $ operator is invalid for atomic vectors\n```\n:::\n\n\n### R list {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a named list\n\ndog <- list(name = \"Edison Vanderplas\", \n            age = 9, \n            breed = \"Jack Russell Terrorist\", \n            fav_toy = \"stuffed duck\",\n            video = \"https://youtu.be/zVeoQTOTIuQ\")\n\n# Getting things out of the list as single objects\ndog$name # use $ to index by name, with no quotes\n## [1] \"Edison Vanderplas\"\ndog$sex # if you use a name that isn't there, you get NULL\n## NULL\n\ndog[[\"name\"]] # use [[]] to get to a single element, then index by name or position\n## [1] \"Edison Vanderplas\"\ndog[[\"sex\"]]\n## NULL\n\ndog[[2]]\n## [1] 9\ndog[[7]] # if you use a position that isn't there you get an error\n## Error in dog[[7]]: subscript out of bounds\n\n# Getting a sub-list out (still as a list)\ndog[c(1, 3, 5)] # use [] to get a subset of the list\n## $name\n## [1] \"Edison Vanderplas\"\n## \n## $breed\n## [1] \"Jack Russell Terrorist\"\n## \n## $video\n## [1] \"https://youtu.be/zVeoQTOTIuQ\"\n\ndog[c(1, 3, 5)][[3]] # you can still use [[]] to get an item from this sub list\n## [1] \"https://youtu.be/zVeoQTOTIuQ\"\n```\n:::\n\n\n### R data frame {- .unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydf <- data.frame(\n  name = c(\"Edison\", \"Wishbone\"), \n  age = c(9, 2), \n  sex = \"M\" # this will be repeated for all entries in the data frame\n)\n\nmydf\n##       name age sex\n## 1   Edison   9   M\n## 2 Wishbone   2   M\n\nmydf$name\n## [1] \"Edison\"   \"Wishbone\"\nmydf$age\n## [1] 9 2\nmydf$sex\n## [1] \"M\" \"M\"\n\nmydf[2, 3]\n## [1] \"M\"\n\nmydf[\"name\"] # this is a data frame!\n##       name\n## 1   Edison\n## 2 Wishbone\nmydf[[\"name\"]] # this is a vector\n## [1] \"Edison\"   \"Wishbone\"\n\nmydf[[\"name\"]][1] # this is a single entry (but still a vector of length 1)\n## [1] \"Edison\"\n```\n:::\n\n\n:::\n\n::: panel-tabset\n\n### Python lists and tuples {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmylist = ['the', 'answer', 'to', 'life', 'is', 42]\n\nmylist[5]\n## 42\nmylist[0:5]\n## ['the', 'answer', 'to', 'life', 'is']\n```\n:::\n\n\nList indexing and tuple indexing works the same way as vector indexing in python.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmytuple = (3, 5, 'dog')\nmytuple[0]\n## 3\nmytuple[0:2] # can index with slices\n## (3, 5)\n```\n:::\n\n\n### Python dict {- .unnumbered}\n\nPython dicts can be indexed by name directly and by location if you convert the keys or values to a list first.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndog = {\"name\": \"Edison Vanderplas\", \n       \"age\": 9, \n       \"breed\": \"Jack Russell Terrorist\", \n       \"fav_toy\": \"stuffed duck\",\n       \"video\": \"https://youtu.be/zVeoQTOTIuQ\"}\n       \ndog[\"name\"]\n## 'Edison Vanderplas'\nlist(dog.keys()) # create a list from the keys of the dog dict\n## ['name', 'age', 'breed', 'fav_toy', 'video']\nlist(dog) # this does the same thing\n## ['name', 'age', 'breed', 'fav_toy', 'video']\nlist(dog)[0] # lists can then be indexed by location\n## 'name'\nlist(dog.values()) # create a list from the values of the dog dict\n## ['Edison Vanderplas', 9, 'Jack Russell Terrorist', 'stuffed duck', 'https://youtu.be/zVeoQTOTIuQ']\nlist(dog.values())[3]\n## 'stuffed duck'\n```\n:::\n\n\n### Numpy vector {- .unnumbered}\n\nVectors in python can't be named, so we can't try to index them by name.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\nmyvec = np.array([3, 1, 4, 1, 5, 9])\n\nmyvec[0] # indexing in python starts at 0 instead of 1\n## 3\nmyvec[0:4] # select [a, b) elements in the vector\n## array([3, 1, 4, 1])\n```\n:::\n\n\n### Numpy ndarray {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n# generate a 3d array of random integers\nmyndarray = np.random.randint(12, size = (2, 2, 3))\nmyndarray\n## array([[[ 6,  4,  5],\n##         [ 5,  4,  1]],\n## \n##        [[ 5,  8,  6],\n##         [ 4, 10,  9]]])\nmyndarray[0, 0, 0]\n## 6\nmyndarray[0, :, 2] # use ':' to get all numbers in a \"slice\"\n## array([5, 1])\nmyndarray[:, :, 2]\n## array([[5, 1],\n##        [6, 9]])\nmyndarray[1, 1, 0:3] # a:b gets you an integer list between [a, b) (not including b)\n## array([ 4, 10,  9])\n```\n:::\n\n\n### Pandas Series\n\nPandas Series and Data Frames are the only types that can be indexed by name and location.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ndog_series = pd.Series(dog)\n\ndog_series['name']\n## 'Edison Vanderplas'\ndog_series['name':'age']\n## name    Edison Vanderplas\n## age                     9\n## dtype: object\ndog_series[1]\n## 9\ndog_series[0:3] # slicing works with location and name based indexing.\n## name          Edison Vanderplas\n## age                           9\n## breed    Jack Russell Terrorist\n## dtype: object\n```\n:::\n\n\n### Pandas DataFrame {- .unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\n\ndogs = {\n  \"name\": [\"Edison Vanderplas\", \"Tesla Vanderplas\"],\n  \"age\": [9, 14], \n  \"breed\": [\"Jack Russell Terrorist\", \"Lhasa Apso\"],\n  \"fav_toy\": [\"stuffed duck\", \"a human to pet me\"],\n  \"video\": [\"https://youtu.be/zVeoQTOTIuQ\", \"none\"]\n  }\ndog_df = pd.DataFrame(dogs, index = [\"Eddie\", \"Tez\"])\n\ndog_df.name # can use .varname notation sometimes, but not as robust\n## Eddie    Edison Vanderplas\n## Tez       Tesla Vanderplas\n## Name: name, dtype: object\ndog_df['name']\n## Eddie    Edison Vanderplas\n## Tez       Tesla Vanderplas\n## Name: name, dtype: object\ndog_df['name'][1] # access the series entry within\n\n# .iloc provides integer-based indexing\n## 'Tesla Vanderplas'\ndog_df.iloc[0, :]\n## name                  Edison Vanderplas\n## age                                   9\n## breed            Jack Russell Terrorist\n## fav_toy                    stuffed duck\n## video      https://youtu.be/zVeoQTOTIuQ\n## Name: Eddie, dtype: object\ndog_df.iloc[1, 2]\n## 'Lhasa Apso'\ndog_df.iloc[:, 2]\n\n# .loc provides name-based indexing for ROW labels\n## Eddie    Jack Russell Terrorist\n## Tez                  Lhasa Apso\n## Name: breed, dtype: object\ndog_df.loc[\"Tez\"] \n## name        Tesla Vanderplas\n## age                       14\n## breed             Lhasa Apso\n## fav_toy    a human to pet me\n## video                   none\n## Name: Tez, dtype: object\ndog_df.loc[\"Eddie\"] # this returns a Series\n## name                  Edison Vanderplas\n## age                                   9\n## breed            Jack Russell Terrorist\n## fav_toy                    stuffed duck\n## video      https://youtu.be/zVeoQTOTIuQ\n## Name: Eddie, dtype: object\ndog_df.loc[[\"Eddie\"]] # double brackets returns a DataFrame\n# note, this is basically the opposite of what [[ ]] does in R\n##                     name  age  ...       fav_toy                         video\n## Eddie  Edison Vanderplas    9  ...  stuffed duck  https://youtu.be/zVeoQTOTIuQ\n## \n## [1 rows x 5 columns]\ndog_df.loc[\"Eddie\", 'age':'fav_toy'] # can be used with slices for columns\n## age                             9\n## breed      Jack Russell Terrorist\n## fav_toy              stuffed duck\n## Name: Eddie, dtype: object\n```\n:::\n\n\n:::\n\nThe 1, 2, and multi-dimensional homogeneous data types should be familiar from e.g. linear algebra and calculus. Single elements of a vector can be extracted using single square brackets, e.g. `x[1]` will get the first element of the vector `x`. In a matrix, elements are indexed as row, column, so to get the (2, 2) entry of a matrix x, you would use `x[2,2]`. This is extended for multi-dimensional arrays in both R and python, with each dimension added, e.g. `x[3,1,2]` or `x[4, 3, 2, 1]`.\n\nTo get a full row or column from a matrix (in both SAS and R) you would use `x[1,]` (get the first row) or `x[,3]` (get the 3rd column). In python, you would use `x[1,:]`, where `:` indicates that you want the whole row or column.\n\nTo select multiple rows or columns from a matrix, you would use `x[, c(1, 3)]` in R or `x[,{1 3}]` in SAS - both options get the first and third column of the matrix, with all rows of data included. In Python, you would use `x.loc[:,[1,3]]`. \n\n:::{.callout-important}\n\nIn both R and SAS, `a:b` where a and b are numbers will form a sequence from `a` to `b` by 1s. So `1:4` is 1, 2, 3, 4. This is often used to get a set of rows or columns: `x[3:4, 1:2]`. In Python, a similar notation is used, but instead of counting from `a` to `b` when using `a:b`, Python will count from `a` to `b-1`. \n\n\nBoth R and SAS are 1-indexed languages, so the elements of a list or vector are indexed as 1, 2, 3, 4, .... Python is 0-indexed, like most general-purpose programming languages.[^intro-prog-3]\n:::\n\n[^intro-prog-3]: Most languages are 0-indexed languages: C, C++, python, Java, javascript. Vectors in these languages are indexed as 0, 1, 2, 3. Other 1-indexed languages include FORTRAN, Matlab, Julia, Mathematica, and Lua, many of which were intended for mathematical processing or data analysis.\n\nIn both R and Python, it is possible to index a vector using a logical vector of the same length. This is called **logical indexing** and is a very handy way to collect only the data you need for a task.\n\n:::{.callout-tip}\n### Try it out: Logical Indexing\n\n::: panel-tabset\n\n#### Problem {-}\n\n(From project Euler)\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.\n\nHint: The modulo operator, `%%`, gives the integer remainder of one number divided by another. So `a %% b` gives the integer remainder when dividing `a` by `b`. Modular division is often used to find multiples of a number.\n\n#### R solution {-}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nx <- 1:999 # all nums below 1000\n\nm3 <- (x %% 3) == 0 # multiple of 3\nm5 <- (x %% 5) == 0 # multiple of 5\nm3or5 <- m3 | m5\n\nsum(x[m3or5])\n## [1] 233168\n```\n:::\n\n\n\n\n#### Python solution {-}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = np.array(list(range(1, 1000)))\n\nm3 = (x % 3) == 0\nm5 = (x % 5) == 0\nm3or5 = m3|m5\n\nsum(x[m3or5])\n## 233168\n```\n:::\n\n\n:::\n:::\n\nMost complicated structures in R (and python) are actually lists underneath. You should be able to access any of the pieces of a list using a combination of named references (where appropriate) and indexing.\n\n\n:::{.callout-note}\n### R Indexing Analogy\n\nIf you have trouble distinguishing between `$`, `[`, and `[[`, you're not alone. @r4ds has an excellent [illustration](https://r4ds.had.co.nz/vectors.html#lists-of-condiments), which I will summarize for you here in abbreviated, tabular form (pictures directly lifted from the book).\n\n\n| `x`                      | `x[1]`                     | `x[[1]]`                   | `x[[1]][[1]]`              |\n|--------------------------|----------------------------|----------------------------|----------------------------|\n| ![](images/data-structures/02_pepper.jpg) | ![](images/data-structures/02_pepper-1.jpg) | ![](images/data-structures/02_pepper-2.jpg) | ![](images/data-structures/02_pepper-3.jpg) |\n:::\n\n## References {-}\n",
    "supporting": [
      "data-structures_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}