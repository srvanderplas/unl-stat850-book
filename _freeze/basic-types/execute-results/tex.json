{
  "hash": "5d56e707567adcf4fee552098447913e",
  "result": {
    "markdown": "\n# Basic Variable Types \n\n## Module Objectives {#module-3-objectives .unnumbered}\n\n-   Know the basic data types and what their restrictions are\n-   Know how to test to see if a variable is a given data type\n-   Understand the basics of implicit and explicit type conversion\n-   Write code that assigns values to variables\n\n## Vocabulary\n\nFor a general overview, @tomscottWhyTRUETRUE2020 is an excellent introduction to data types:\n\n<iframe width=\"640\" height=\"400\" src=\"https://www.youtube.com/embed/6otW6OXjR8c?list=PL96C35uN7xGLLeET0dOWaKHkAlPsrkcha\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; picture-in-picture\" allowfullscreen></iframe>\n\n\nLet's start this section with some basic vocabulary.\n\n-   a **value** is a basic unit of stuff that a program works with, like 1, 2, \"Hello, World\", and so on.\n\n-   **values** have **types** - 2 is an integer, \"Hello, World\" is a string (it contains a \"string\" of letters). Strings are in quotation marks to let us know that they are not variable names.\n\nIn most languages, there are some very basic data types:\n\n-   **logical** or **boolean** - FALSE/TRUE or 0/1 values. Sometimes, boolean is shortened to bool\n\n-   **integer** - whole numbers (positive or negative)\n\n-   **double** or **float** or **numeric** - decimal numbers.\n\n    -   float is short for floating-point value.\n\n    -   double is a floating-point value with more precision (\"double precision\").\n\n    -   R uses the name **numeric** to indicate a decimal value, regardless of precision.\n\n-   **character** or **string** - holds text, usually enclosed in quotes.\n\nIf you don't know what type a value is, there are usually functions to help you with that.\n\n::: panel-tabset\n## R {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(FALSE)\nclass(2L) # by default, R treats all numbers as numeric/decimal values. \n          # The L indicates that we're talking about an integer. \nclass(2)\nclass(\"Hello, programmer!\")\n## [1] \"logical\"\n## [1] \"integer\"\n## [1] \"numeric\"\n## [1] \"character\"\n```\n:::\n\n\n\n## Python {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntype(False)\ntype(2)\ntype(3.1415)\ntype(\"This is python code\")\n## <class 'bool'>\n## <class 'int'>\n## <class 'float'>\n## <class 'str'>\n```\n:::\n\n\n\n:::\n\n::: note\nIn R, boolean values are `TRUE` and `FALSE`, but in Python they are `True` and `False`. Capitalization matters a LOT.\n\nOther things matter too: if we try to write a million, we would write it `1000000` instead of `1,000,000` (in both languages). Commas are used for separating numbers, not for proper spacing and punctuation of numbers. This is a hard thing to get used to but very important -- especially when we start reading in data.\n:::\n\n## Testing Types\n\nYou can use different functions to test whether a variable has a specific type as well:\n\n::: panel-tabset\n### R {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.logical(FALSE)\nis.integer(2L) # by default, R treats all numbers as numeric/decimal values. \n          # The L indicates that we're talking about an integer. \nis.integer(2)\nis.numeric(2)\nis.character(\"Hello, programmer!\")\n## [1] TRUE\n## [1] TRUE\n## [1] FALSE\n## [1] TRUE\n## [1] TRUE\n```\n:::\n\n\n\nIn R, you use `is.xxx` functions, where xxx is the name of the type in question.\n\n### Python {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nisinstance(False, bool)\nisinstance(2, int)\nisinstance(2, (int, float)) # Test for one of multiple types\nisinstance(3.1415, float)\nisinstance(\"This is python code\", str)\n## True\n## True\n## True\n## True\n## True\n```\n:::\n\n\n\nIn python, test for types using the `isinstance` function with an argument containing one or more data types in a tuple (`(int, float)` is an example of a tuple - a static set of multiple values).\n:::\n\n## Exploring Types\n\n::: note\n### Assignment {.unnumbered}\n\nNote that `<-` is used for assigning a value to a variable. So `x <- \"R is awesome\"` is read \"x gets 'R is awesome'\" or \"x is assigned the value 'R is awesome'\".\n:::\n\n::: panel-tabset\n### Character {.unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- \"R is awesome\"\ntypeof(x)\n## [1] \"character\"\nis.character(x)\n## [1] TRUE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] FALSE\n```\n:::\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = \"python is awesome\"\ntype(x)\n## <class 'str'>\nisinstance(x, str)\n## True\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## False\nisinstance(x, float)\n## False\n```\n:::\n\n\n\n### Logical {.unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- FALSE\ntypeof(x)\n## [1] \"logical\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] TRUE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] FALSE\n```\n:::\n\n\n\nIn R, is possible to use the shorthand `F` and `T`, but be careful with this, because `F` and `T` are not reserved, and other information can be stored within them. See [this discussion](https://twitter.com/tslumley/status/1279870794730893312) for pros and cons of using `F` and `T` as variables vs. shorthand for true and false. [^intro-prog-1]\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = False\ntype(x)\n## <class 'bool'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## True\nisinstance(x, int)\n## True\nisinstance(x, float)\n## False\n```\n:::\n\n\n\nNote that in python, boolean variables are also integers. If your goal is to test whether something is a T/F value, you may want to e.g. test whether its value is one of 0 or 1, rather than testing whether it is a boolean variable directly, since integers can also function directly as bools in Python.\n\n### Integer {.unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- 2\ntypeof(x)\n## [1] \"double\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] TRUE\n```\n:::\n\n\n\nWait, 2 is an integer, right?\n\n2 is an integer, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically.\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- 2L # The L immediately after the 2 indicates that it is an integer.\ntypeof(x)\n## [1] \"integer\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] TRUE\nis.double(x)\n## [1] FALSE\nis.numeric(x)\n## [1] TRUE\n```\n:::\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = 2\ntype(x)\n## <class 'int'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## True\nisinstance(x, float)\n## False\n```\n:::\n\n\n\n### Double {.unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nx <- 2.45\ntypeof(x)\n## [1] \"double\"\nis.character(x)\n## [1] FALSE\nis.logical(x)\n## [1] FALSE\nis.integer(x)\n## [1] FALSE\nis.double(x)\n## [1] TRUE\nis.numeric(x)\n## [1] TRUE\n```\n:::\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nx = 2.45\ntype(x)\n## <class 'float'>\nisinstance(x, str)\n## False\nisinstance(x, bool)\n## False\nisinstance(x, int)\n## False\nisinstance(x, float)\n## True\n```\n:::\n\n\n\n### Numeric {.unnumbered}\n\nA fifth common \"type\"[^intro-prog-2], `numeric` is really the union of two types: integer and double, and you may come across it when using `str()` or `mode()`, which are similar to `typeof()` but do not quite do the same thing.\n\nThe `numeric` category exists because when doing math, we can add an integer and a double, but adding an integer and a string is ... trickier. Testing for numeric variables guarantees that we'll be able to do math with those variables. `is.numeric()` and `as.numeric()` work as you would expect them to work.\n\nThe general case of this property of a language is called **implicit type conversion** - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double.\n:::\n\n[^intro-prog-1]: There is also an [R package dedicated to pure evil](https://purrple.cat/blog/2017/05/28/turn-r-users-insane-with-evil/) that will set F and T randomly on startup. Use this information wisely.\n\n[^intro-prog-2]: `numeric` is not really a type, it's a mode. Run `?mode` for more information.\n\n## Type Conversions {.unnumbered}\n\nProgramming languages will generally work hard to seamlessly convert variables to different types. So, for instance,\n\n::: panel-tabset\n\n### R {- .unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nTRUE + 2\n## [1] 3\n\n2L + 3.1415\n## [1] 5.1415\n\n\"abcd\" + 3\n## Error in \"abcd\" + 3: non-numeric argument to binary operator\n```\n:::\n\n\n\n### Python {- .unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nTrue + 2\n## 3\nint(2) + 3.1415\n## 5.141500000000001\n\"abcd\" + 3\n## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: can only concatenate str (not \"int\") to str\n## \n## Detailed traceback:\n##   File \"<string>\", line 1, in <module>\n```\n:::\n\n\n:::\n\nThis conversion doesn't always work - there's no clear way to make \"abcd\" into a number we could use in addition. So instead, R or python will issue an error. This error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops.\n\nWhen you want to, you can also use `as.xxx()` to make the type conversion **explicit**. So, the analogue of the code above, with explicit conversions would be:\n\n::: panel-tabset\n\n### R {- .unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nas.double(TRUE) + 2\n## [1] 3\n\nas.double(2L) + 3.1415\n## [1] 5.1415\n\nas.numeric(\"abcd\") + 3\n## [1] NA\n```\n:::\n\n\n\n### Python {- .unnumbered}\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nint(True) + 2\n## 3\nfloat(2) + 3.1415\n## 5.141500000000001\nfloat(\"abcd\") + 3\n## Error in py_call_impl(callable, dots$args, dots$keywords): ValueError: could not convert string to float: 'abcd'\n## \n## Detailed traceback:\n##   File \"<string>\", line 1, in <module>\nimport pandas as pd # Load pandas library\npd.to_numeric(\"abcd\", errors = 'coerce') + 3\n## nan\n```\n:::\n\n\n:::\n\nWhen we make our intent explicit (convert \"abcd\" to a numeric variable) we get an NA - a missing value - in R. In Python, we get a more descriptive error by default, but we can use the `pandas` library (which adds some statistical functionality) to get a similar result to the result we get in R.\n\nThere's still no easy way to figure out where \"abcd\" is on a number line, but our math will still have a result - `NA + 3` is `NA`.\n\n## Determining a Variable's Type\n\n::: panel-tabset\n\n### R {- .unnumbered}\n\nIf you are unsure what the type of a variable is, use the `typeof()` function to find out.\n\n\n\n::: {.cell hold='true'}\n\n```{.r .cell-code}\nw <- \"a string\"\nx <- 3L\ny <- 3.1415\nz <- FALSE\n\ntypeof(w)\n## [1] \"character\"\ntypeof(x)\n## [1] \"integer\"\ntypeof(y)\n## [1] \"double\"\ntypeof(z)\n## [1] \"logical\"\n```\n:::\n\n\n\n### Python {- .unnumbered}\n\nIf you are unsure what the type of a variable is, use the `type()` function to find out.\n\n\n\n::: {.cell hold='true'}\n\n```{.python .cell-code}\nw = \"a string\"\nx = 3\ny = 3.1415\nz = False\n\ntype(w)\n## <class 'str'>\ntype(x)\n## <class 'int'>\ntype(y)\n## <class 'float'>\ntype(z)\n## <class 'bool'>\n```\n:::\n\n\n\n:::\n\n## Try It Out {.unnumbered .tryitout}\n\n::: panel-tabset\n\n### R {- .unnumbered}\n\n1.  Create variables `string`, `integer`, `decimal`, and `logical`, with types that match the relevant variable names.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \ninteger <- \ndecimal <- \nlogical <- \n```\n:::\n\n\n\n2.  Can you get rid of the error that occurs when this chunk is run?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical + decimal\ninteger + decimal\nstring + integer\n```\n:::\n\n\n\n3.  What happens when you add string to string? logical to logical?\n\n### Python {- .unnumbered}\n\n1.  Create variables `string`, `integer`, `decimal`, and `logical`, with types that match the relevant variable names.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nstring = \ninteger = \ndecimal = \nlogical = \n```\n:::\n\n\n\n2.  Can you get rid of the error that occurs when this chunk is run?\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlogical + decimal\ninteger + decimal\nstring + integer\n```\n:::\n\n\n\n3.  What happens when you add string to string? logical to logical?\n\n### R Solution {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring <- \"hi, I'm a string\"\ninteger <- 4L\ndecimal <- 5.412\nlogical <- TRUE\n\nlogical + decimal\n## [1] 6.412\ninteger + decimal\n## [1] 9.412\nas.numeric(string) + integer\n## [1] NA\n\n\"abcd\" + \"efgh\"\n## Error in \"abcd\" + \"efgh\": non-numeric argument to binary operator\nTRUE + TRUE\n## [1] 2\n```\n:::\n\n\n\nIn R, adding a string to a string creates an error (\"non-numeric argument to binary operator\"). Adding a logical to a logical, e.g. TRUE + TRUE, results in 2, which is a numeric value.\n\nTo concatenate strings in R (like the default behavior in python), we would use the `paste0` function: `paste0(\"abcd\", \"efgh\")`, which returns abcdefgh.\n\n### Python Solution {- .unnumbered}\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\nstring = \"hi, I'm a string\"\ninteger = 4\ndecimal = 5.412\nlogical = True\n\nlogical + decimal\n## 6.412\ninteger + decimal\n## 9.411999999999999\npd.to_numeric(string, errors='coerce') + integer\n## nan\n\"abcd\" + \"efgh\"\n## 'abcdefgh'\nTrue + True\n## 2\n```\n:::\n\n\n\nIn Python, when a string is added to another string, the two strings are **concatenated**. This differs from the result in R, which is a \"non-numeric argument to binary operator\" error.\n\n:::\n\n\n## References {.unnumbered}\n",
    "supporting": [
      "basic-types_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}