{
  "hash": "754c05e1d17d4d3ba4dfe9a564a0124c",
  "result": {
    "markdown": "# Programming First Steps {#intro-prog}\n\nThe only way to learn how to program effectively is to take something that works, break it, and then fix it again. There's plenty of theory and you should definitely learn that, but fundamentally, if you are not regularly breaking code, you're probably not programming.\n\n![This is the class in picture form](images/intro-prog/learning_to_code_Orly.jpeg){fig-alt=\"A parody of the O'Reilly programming books (O RLY?) called 'Changing Stuff and Seeing What Happens' with the subtitle 'How to actually learn any new programming concept'. A black-and-white kitten is featured on the cover.\" fig-align=\"center\" width=\"50%\"}\n\nThe goal for this chapter (and several chapters to come) is that you can modify example code and adapt it to the problem at hand. This is the best way to learn how to program, but it means you may break the code and not know how to fix it. If that happens, please try the following steps:\n\n1.  Google the error and see if you can understand why it happened.\n2.  Consult with a classmate to see if they can understand where things broke.\n3.  Post to the discussion board and see if anyone in the class can understand where things broke.\\\n    (When you do this, post all of the code relevant to the problem, and the error you're getting, so that your classmates can replicate the problem)\n\nIf you do not hopelessly break code during this chapter because you have so much prior experience programming, then please do your best to help others. While writing this chapter, I came across about 10 errors that I'd never encountered before, so helping others is a great way to learn.\n\nIf all else fails, while you're waiting for someone to help you figure out what an error message means... [try this approach](https://xkcd.com/1024/).\n\n## Module Objectives {#module-2-objectives .unnumbered}\n\n-   Understand the difference between reserved words and variables\n-   Create a program flow map by breaking a problem down into smaller steps\n-   Explain the difference between interactive mode and command-line execution of a script\n-   Understand the difference between scripts and notebooks and explain when each is appropriate\n\nMore informally, the goal is to get familiar with the basics of each programming language, and to show you where to find references for how to use each command -- because (at least) half of programming is knowing where to look something up.\n\n::: callout-note\n## Cheat Sheets and Reference Guides {.unnumbered}\n\nI kept the classic R reference card by my computer for about 5 years, and referenced it at least once or twice a day for that entire period. There will be other cheat sheets and reference cards scattered through this book because if you can't remember something's name, you might be able to remember where it is on the reference card (or at least, that's how I learned R).\n\n::: panel-tabset\n### R {.unnumbered}\n\n-   [R Cheatsheet](http://github.com/rstudio/cheatsheets/blob/main/base-r.pdf) - this is a simplified cheat sheet offered by RStudio.\n-   [R Cheatsheet (classic)](https://cran.r-project.org/doc/contrib/Short-refcard.pdf)\n\n### Python {.unnumbered}\n\n-   [Data Wrangling in Pandas](https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf)\n-   [NumPy Cheat Sheet](http://datacamp-community-prod.s3.amazonaws.com/ba1fe95a-8b70-4d2f-95b0-bc954e9071b0)\n-   [Data Input in Python](http://datacamp-community-prod.s3.amazonaws.com/72e88aa1-b4f2-4658-9d86-15becf8263df)\n\n### SAS {.unnumbered}\n\n-   [SAS Cheatsheet (from another class like this)](https://sites.ualberta.ca/~ahamann/teaching/renr480/SAS-Cheat.pdf)\n-   [SAS Cheatsheet (by SAS)](https://support.sas.com/content/dam/SAS/support/en/books/data/base-syntax-ref.pdf)\n-   [SAS Programming for R Users (free book)](https://support.sas.com/content/dam/SAS/support/en/books/free-books/sas-programming-for-r-users.pdf)\n:::\n:::\n\n## What is programming?\n\n> Programming today is a race between software engineers striving to build bigger and better idiot-proof programs, and the universe trying to produce bigger and better idiots. So far, the universe is winning. - Rick Cook\n\nProgramming is the art of solving a problem by developing a sequence of steps that make up a solution, and then very carefully communicating those steps to the computer. To program, you need to know how to\n\n-   break a problem down into smaller, easily solvable problems\n-   solve small problems\n-   communicate the solution to a computer using a programming language\n\nThis book will demonstrate statistical programming using both `R` and `Python`. We will be using these languages to solve problems that are related to working with data. At first, we'll start with smaller, simpler problems that don't involve data, but by the end of the semester, you will hopefully be able to solve some statistical problems using one or both languages.\n\nIt will be hard at first - you have to learn the vocabulary in both languages in order to be able to put commands into logical \"sentences\". The problem solving skills are the same for all programming languages, though, and while those are harder to learn, they'll last you a lifetime (and be applicable to many other things beyond programming, like research).\n\n## Breaking Problems Down\n\nThe most fundamental part of programming that you will need to learn in this class is how to break down a big problem into smaller (hopefully solvable) problems. [This post](https://medium.com/@dannysmith/breaking-down-problems-its-hard-when-you-re-learning-to-code-f10269f4ccd5) is a great example of the process of breaking things down for programming, but the same concept applies outside of programming too!\n\n::: callout-caution\n### Breaking Problems Down IRL\n\n::: panel-tabset\n#### Scenario {.unnumbered}\n\nMy spouse and I recently decided to replace our shower curtain with glass doors because the curtain didn't really prevent water from getting all over the floor.\n\nWe went to the store and picked out the parts, and the installation instructions broke the steps down like this:\n\n1.  Install the base of the track\n\n2.  Install the top of the track\n\n3.  Hang shower doors\n\n4.  Add hardware to shower doors\n\nSo we started in on the instructions, only to find out that when our house was built, our shower wasn't leveled properly.\n\n#### Brainstorming Solutions {.unnumbered}\n\nThe instructions had a solution - we could send off for a \\$300 custom part that would level our floor, but we'd have to wait at least 4-6 weeks for them to make and ship the part to us. At this point, we'd already taken apart the shower and bought the shower door, so having the bathroom out of commission for 4-6 weeks was not appealing.\n\nWe're both programmer-adjacent, so we started thinking through how we could deal with our problem a different way. We considered ignoring the instructions -- our shower was about 1/8\" off of level, surely that couldn't be so important, right? My spouse is a bit more ... detail oriented ... than I am, so he wasn't good with that suggestion.\n\nWe considered adding a ton of caulk or plaster to try to level the shower out. But we figured that 1) probably wouldn't work, and 2) would look awful.\n\nFinally, I suggested that my spouse 3D print sections of track-leveler using our 3D printer. Now, this isn't an option for most people, but it is for us - we have a small 3D printer, and my husband knows how to use OpenSCAD to create very accurate, custom dimension 3D printer files. He tested things out a few times, and printed up a series of 12 \\~5\" sections that, when assembled, were equivalent to the \\$300 custom part we could have ordered. He added those sections to the shower, caulked them in, and proceeded with the rest of the installation.\n\n#### Conclusion {.unnumbered}\n\nBecause we had a list of subproblems (steps for installation), we could focus our efforts on debugging the one problem we had (not level shower ledge) and we didn't have to get bogged down in \"it's impossible to get this job done\".\n\nWe knew that if we could solve the little problem, we'd be able to get the bigger job done. Programming is just like this - if you can break your problem down into steps (and not steps with code), you can think through how to solve a single step of the problem before you worry about the next step.\n:::\n:::\n\nOne tool that is often used to help break a problem down is a [flowchart](https://www.programiz.com/article/flowchart-programming). In a flowchart, each step in a process is described in sequential order, with decisions represented as forks in the \"flow\".\n\n::: callout-note\n#### Sketch Tool Recommendation\nA tool that I often use to make flowcharts and other diagrams/sketches while programming is [Excalidraw](https://excalidraw.com).\n:::\n\n::: callout-tip\n### Try it out {.unnumbered}\n\nThe biggest advantage to breaking problems down into smaller steps is that it allows you to focus on solving a small, approachable problem.\n\nLet's think through an example:\n\n::: panel-tabset\n#### Problem\n\nPrint out a pyramid of stars, 10 lines high.\n\nYes, I remember, I haven't taught you how to write any code yet. Don't worry about code right now - let's just think about how we might create a pyramid of stars.\n\nStart by doing the task manually on paper or in a text editor. Observe the steps you go through and think about how you might generalize those steps.\n\n#### Manual Solution\n\nFirst, we have to think about what we would need to make a pyramid of stars. So let's make a miniature one by hand (I'm using - for spaces here to make things visible):\n\n    ---*---\n    --***--\n    -*****-\n\nTo make my miniature star pyramid, I started out by adding space on the first line, then a star, then more space. When I moved to the next line, I added space, but one less space than I'd added before, and then 3 stars, and then more space.\n\n#### Analysis\n\nExamining the manual solution, it seems we can break our problem down into two(ish) components:\n\n-   How much space? (one side)\n-   How many stars?\n-   (redundant piece) How much space (the other side).\n\nThinking my way through how I created my manual pyramid, I realized that I was adding $n$ spaces (where $n$ is the total number of rows) on the first line, and then $n - i$ spaces on subsequent lines, if we start with i=0.\n\nBut I am an R programmer, so we start with $i=1$, which means I need to have $n - i + 1$ spaces on each row first.\n\nThen, for $i=1$ the first row, we have $2*i - 1$ stars - i = 1, stars = 1, then i = 2, stars = 3, then i = 3, stars = 5.... you can do the regression if you want to, but it's pretty easy to see the relationship.\n\nFinally, we have to (in theory) add the same amount of space on the other side -- strictly speaking, this is optional, but it makes the lines the same length, so it is nice.\n\n#### Program Flow Map\n\n![Program flow map for stars](images/intro-prog/prog-flow-pyramid-stars.svg)\n\n#### Formal Solution\n\nIf we want a pyramid that is $n$ rows high, we might think of creating it by using the following line-by-line formula, where $i$ is our current line:\n\n$n - i +1$ spaces, $2i - 1$ stars, $n - i + 1$ spaces\n\nWorking this out in a small example helped me come up with that formula; now, I can write a \"loop\":\n\n-   line 1: i = 1, n = 10, 10 spaces, 1 star, 10 spaces\n-   line 2: i = 2, n = 10, 9 spaces, 3 stars, 9 spaces\n-   line 3: i = 3, n = 10, 8 spaces, 5 stars, 8 spaces\n-   line 4: i = 4, n = 10, 7 spaces, 7 stars, 7 spaces\n-   ...\n-   line n: i = n, n = 10, 1 space, 19 stars, 1 space\n:::\n:::\n\n## Programming Concepts {.unnumbered}\n\nMany programming resources talk about 3, or 5, or 10 core concepts in any programming language.Here, we're going to discuss the generic concepts, and then how these concepts are implemented in the languages we're working with.\n\nInterestingly, the \"core concepts\" aren't necessarily the same across lists. Here is a consensus list of concepts which are generic across languages and usually important\\[@pageBasicProgrammingConcepts2021,@mukitBasicProgrammingConcepts2018,@holowczakProgrammingConceptsBrief2013,@fenjvesComputerLanguageFundamentals2016,@asayBasicProgrammingConcepts2005\\]:\n\n1.  **Variables**\\\n    a symbolic name or reference to some kind of information. In the expression `a + b > a`, both `a` and `b` are variables. Variables may have a specific type (what data can be stored in the variable), scope (where the variable can be accessed), and location (where the information is stored in the computer's memory). [@mukitBasicProgrammingConcepts2018] has a nice explanation of the difference between variables in programming and variables in math.\n\n2.  **Conditional statements** (if statements)\\\n    These statements allow the program to handle information adaptively - if a statement is true, one set of instructions will be used, and if the statement is false, a different set of instructions will be used.\n\n3.  **Looping and iteration**\\\n    An iteration is any time a sequence of steps is executed. Most languages have several different types of loops or iteration: `for` loops, which allow for the sequence of steps to be executed a specific number of times, `while` loops, which allow for the sequence of steps to be executed while a conditional statement is true, `recursion`, where a block of code calls itself.\n\n4.  **Data types and data structures**\\\n    these concepts determine what information a variable can hold. Data types are lower-level, simple objects (floating-point numbers, integers, Boolean T/F, characters, strings). Data structures may include lists (sequences of many objects) and vectors (sequences of many objects of the same type), dictionaries (a list of key-value pairs), objects (data structures which may hold multiple related pieces of information).\n\n5.  **Functions**\\\n    self-contained modules of code that accomplish a particular task.\n\n6.  **Syntax**\\\n    The set of rules that define which combinations of symbols consist of correctly structured and interpretable commands in the language.\n\n7.  **Tools**\\\n    The set of external programs which may help with development and writing code. Some common tools are IDEs (Integrated Development Environments), which may correct syntax and typos, organize files for you, allow you to keep track of which variables you have defined, and assist you with code organization and navigation. Other tools include compilers (which take human-written code and translate it into efficient machine code), version control systems (which help you track changes to code over time), debuggers, and documentation generators. Not all of these tools are necessary for all languages - scripting languages such as python and R do not require compilers by default, for instance.\n\n8.  **Sequence of commands**\\\n    It's important to have the right commands in the right order.\n\n<div>\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Ct-lOOUqmyY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\nIt's important to get both the level of specificity and the order of the commands just right when programming.\n\n</div>\n\n## Programming Vocabulary: Hello world\n\nI particularly like the way that Python for Everybody [@py4e] explains vocabulary:\n\n> Unlike human languages, the Python vocabulary is actually pretty small. We call this \"vocabulary\" the \"reserved words\". These are words that have very special meaning to Python. When Python sees these words in a Python program, they have one and only one meaning to Python. Later as you write programs you will make up your own words that have meaning to you called variables. You will have great latitude in choosing your names for your variables, but you cannot use any of Python's reserved words as a name for a variable.\n\n> When we train a dog, we use special words like \"sit\", \"stay\", and \"fetch\". When you talk to a dog and don't use any of the reserved words, they just look at you with a quizzical look on their face until you say a reserved word. For example, if you say, \"I wish more people would walk to improve their overall health\", what most dogs likely hear is, \"blah blah blah walk blah blah blah blah.\" That is because \"walk\" is a reserved word in dog language. Many might suggest that the language between humans and cats has no reserved words.\n\n> The reserved words in the language where humans talk to Python include the following:\n\n    and       del       global      not       with\n    as        elif      if          or        yield\n    assert    else      import      pass\n    break     except    in          raise\n    class     finally   is          return\n    continue  for       lambda      try\n    def       from      nonlocal    while    \n\n> That is it, and unlike a dog, Python is already completely trained. When you say 'try', Python will try every time you say it without fail.\n\n> We will learn these reserved words and how they are used in good time, but for now we will focus on the Python equivalent of \"speak\" (in human-to-dog language). The nice thing about telling Python to speak is that we can even tell it what to say by giving it a message in quotes:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint('Hello world!')\n## Hello world!\n```\n:::\n\n\n> And we have even written our first syntactically correct Python sentence. Our sentence starts with the function print followed by a string of text of our choosing enclosed in single quotes. The strings in the print statements are enclosed in quotes. Single quotes and double quotes do the same thing; most people use single quotes except in cases like this where a single quote (which is also an apostrophe) appears in the string.\n\nR has a slightly smaller set of reserved words:\n\n    if          else     repeat      while        \n    for         in       next        break  \n    TRUE        FALSE    NULL        Inf         \n    NA_integer_ NA_real_ NA_complex_ NA_character_  \n    NaN         NA       function    ...\n\nIn R, the \"Hello World\" program looks exactly the same as it does in python.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint('Hello world!')\n## [1] \"Hello world!\"\n```\n:::\n\n\nIn many situations, R and python will be similar because both languages are based on C. R has a more complicated history, because it is also similar to Lisp, but both languages are still very similar to C and run C or C++ code in the background.\n\n## Interactive Mode\n\nR and python both have an \"interactive mode\" that you will use most often. In the previous chapter, we talked about scripts and markdown documents, both of which are non-interactive methods for writing R and python code. But for the moment, let's work with the interactive console in both languages in order to get familiar with how we talk to R and python.\n\nLet's start by creating a Qmd file (File -\\> New File -\\> Quarto Document) - this will let us work with R and python at the same time.\n\nAdd an R chunk to your file by typing ```` ```{r} ```` into the first line of the file, and then hit return. RStudio should add a blank line followed by ```` ``` ````.\n\nAdd a python chunk to your file by typing ```` ```{python} ```` on a blank line below the R chunk you just created, and then hit return. RStudio should add a blank line followed by ```` ``` ````.\n\nYour file should look like this:\n\n![Screenshot of qmd file after adding an empty r and python chunk](images/intro-prog/finding-your-way-demo-screenshot.png)\n\nIf instead your file looks like this:\n\n![Screenshot of qmd file with visual markdown editing on](images/intro-prog/finding-your-way-demo-screenshot-visualmarkdown.png)\n\nyou have visual markdown mode on. To turn it off, click on the A icon at the top right of your editor window:\n\n![Screenshot of editor window toolbar, with A icon highlighted in green](images/intro-prog/visual-markdown-mode-highlight.png)\n\nIf we are working in interactive mode, why did I have you start out by creating a markdown document? Good Question! RStudio allows you to switch back and forth between R and python seamlessly, which is good and bad - it's hard to get a python terminal without telling R which language you're working in! You can create a python script if you'd prefer to work in a script instead of a markdown document, but that would involve working in 2 separate files, which I personally find rather tedious.\n\n::: panel-tabset\n### The R Console {.unnumbered}\n\nIn your R chunk or script, type in `2+2` and hit `Ctrl+Enter` (or `Cmd+Enter` on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you're like me, output shows up in two places at once:\n\n| Location | Picture                                                                                                |\n|----------------|-------------------------------------------------------|\n| Chunk    | ![R output underneath the code chunk](images/intro-prog/R-chunk-2+2.png)                               |\n| Script   | ![R doesn't show script output in the script](images/intro-prog/R-script-2+2.png)                      |\n| Console  | ![R output in the console (from either a script or a code chunk)](images/intro-prog/R-console-2+2.png) |\n\nR will indicate that it is waiting for your command with a `>` character in the console. If you don't see that `>` character, chances are you've forgotten to finish a statement - check for parentheses and brackets.\n\nWhen you are working in an R script, any output is shown only in the console. When you are working in an R code chunk, output is shown both below the chunk and in the console.\n\nIf you want, you can also just work within the R console. This can be useful for quick, interactive work, or if, like me, you're too lazy to pull up a calculator on your machine and you just want to use R to calculate something quickly. You just type your R command into the console:\n\n![R console with commands \"Hello\", print(\"Hello\"), and (unquoted) \"I love R\", which causes an error](images/intro-prog/R-console.png)\n\nThe first two statements in the above example work - \"Hello\" is a string, and is thus a valid statement equivalent to typing \"2\" into the console and getting \"2\" back out. The second command, `print(\"Hello\")`, does the same thing - \"Hello\" is returned as the result. The third command, `I love R`, however, results in an error - there is an unexpected symbol (the space) in the statement. R thinks we are telling it to do something with variables `I` and `love` (which are not defined), and it doesn't know what we want it to do to the two objects.\n\nSuppose we define `I` and `love` as variables by putting a value into each object using `<-`, which is the assignment operator. Then, typing \"I love\" into the console generates the same error, and R tells us \"hey, there's an unexpected symbol here\" - in this case, maybe we meant to add the two variables together.\n\n![R console with commands \"Hello\", print(\"Hello\"), and (unquoted) \"I love R\", which causes an error. Defining variables I and love provides us a context in which R's error message about unexpected symbols makes sense - R is reminding us that we need a numerical operator in between the two variable names.](images/intro-prog/R-console-error.png)\n\n### The Python Console {.unnumbered}\n\nIn your python chunk or script, type in `2+2` and hit `Ctrl+Enter` (or `Cmd+Enter` on a mac). Look down to the Console (which is usually below the editor window) and see if 4 appears. If you're like me, output shows up in two places at once:\n\n| Location | Picture                                                                                     |\n|-----------------|-------------------------------------------------------|\n| Chunk    | ![python output underneath the code chunk](images/intro-prog/python-chunk-2+2.png)          |\n| Script   | ![python doesn't show script output in the script](images/intro-prog/python-script-2+2.png) |\n| Console  | ![python output in the console](images/intro-prog/python-console-2+2.png)                   |\n\nNotice that in the console, you get a bit of insight into how RStudio is running the python code: we see `reticulate::repl_python()`, which is R code telling R to run the line in Python. The python console has `>>>` instead of `>` to indicate that python is waiting for instructions.\n\nNotice also that the only difference between the R and python script file screenshots is that there is a different logo on the documents: ![R and python script logos](images/intro-prog/R-python-script.png). Personally, I think it's easier to work in a markdown document and keep my notes with specific chunks labeled by language when I'm learning the two languages together, but when you are writing code for a specific project in a single language, it is probably better to use a script file specific to that language.\n\nIf you want to start the python console by itself (without a script or working in a markdown document), you can simply type `reticulate::repl_python()` into the R console.\n\n![Screenshot of how to get the python console](images/intro-prog/python-console.png)\n\nR is nice enough to remind you that to end the conversation with python, you just need to type \"exit\" or \"quit\".\n\nIf you want to start a python console outside of RStudio, bring up your command prompt (Darwin on mac, Konsole on Linux, CMD on Windows) and type python3 into that window and you should see the familiar `>>>` waiting for a command.\n:::\n\n## Script Mode\n\nIn the last section, we played with interactive mode by typing R and python commands into a console or running code chunks interactively using the Run button or `Ctrl/Cmd + Enter` (which is the keyboard shortcut).\n\nYou may be learning to program in R and python because it's a required part of the curriculum, but hopefully, you also have some broader ideas of what you might do with either language - process data, make pretty pictures, write a program to trigger the computer uprising...\n\nScripts are best used when you have a thing you want to do, and you will need to do that thing many times, perhaps with different input data. Suppose that I have a text file and I want to pull out the most common word in that file. In the next few examples, I will show you how to do this in R and python, and at the same time, demonstrate the difference between interactive mode and script mode in both languages. In each example, try to compare to the previous example to identify whether something is running as a full script or in interactive mode, and how it is launched (in R? at the command line?).\n\n@py4e provides a handy python program to count words. This program is meant to be run on the command line, and it will run for any specified text file.\n\n::: callout-caution\n### Example: Counting Words {#counting-words-ex}\n\n::: panel-tabset\n#### Python Terminal\n\nDownload [words.py](code/words.py) to your computer and open up a command line terminal in the location where you saved the file.\n\nBefore you run the script, save [Oliver Twist](data/dickens-oliver-627.txt) to the same folder as `dickens-oliver-627.txt` (you can use another file name, but you will have to adjust your response to the program)\n\n\n::: {.cell}\n\n```{.python .cell-code}\nname = input('Enter file:')\nhandle = open(name, 'r')\ncounts = dict()\n\nfor line in handle:\n    words = line.split()\n    for word in words:\n        counts[word] = counts.get(word, 0) + 1\n\nbigcount = None\nbigword = None\nfor word, count in list(counts.items()):\n    if bigcount is None or count > bigcount:\n        bigword = word\n        bigcount = count\n\nprint(bigword, bigcount)\n\n# Code: http://www.py4e.com/code3/words.py\n```\n:::\n\n\nIn your terminal, type in `python words.py`. If all goes well, you should get a prompt that tells you to enter a file name. Type in `dickens-oliver-627.txt`, and the program will read in the file and execute the program according to the instructions shown above. You don't need to understand what is happening in this program (just like you don't need to understand what is happening in the R code above either) -- you get the answer anyways: the most common word, according to the output from the program, is\n\n    the 8854\n\nThat is, the word `the` occurs 8854 times in the text.\n\n![Screenshot of folder and python script evaluation, showing how to run the python script in the terminal and get the count of the most common word, 'the', in the file dickens-oliver-627.txt](images/intro-prog/python-wordcount-example-screenshot.png)\n\n#### Python (RStudio)\n\nWe can run this script in interactive mode in RStudio if we want to: Open the words.py file you downloaded in RStudio.\n\n![Rstudio screenshot showing the words.py file opened, with a green highlighted rectangle around the button \"Source Script\" which allows you to run the file in RStudio.](images/intro-prog/python-wordcount-rstudio-screenshot.png)\n\nClick the \"Source Script\" button highlighted in green above, and then look at the console below the script window:\n\n![RStudio screenshot of console window after Source Script button is clicked. Python asks you to enter the file of words to count.](images/intro-prog/python-wordcount-rstudio-screenshot-console1.png) Once you enter the path to the text file -- this time, from the **project** working directory -- you get the same answer. It can be a bit tricky to figure out what your current working directory is in RStudio, but in the R console you can get that information with the `getwd()` command.\n\n![RStudio screenshot of console window with getwd() command and result](images/intro-prog/python-wordcount-rstudio-screenshot-console3.png)\n\nSince I know that I have stored the text file in the `data` subdirectory of the `stat151book` folder, I can type in `data/dickens-oliver-627.txt` and the python program can find my file.\n\nIn the above example, RStudio is functioning essentially like a terminal window - it runs the script as a single file, and once it has your input, all commands are executed one after the other automatically. This is convenient if you want to test the whole block of code at once, but it can be more useful to test each line individually and \"play\" with the output a bit (or modify code line-by-line).\n\n#### Interactive Python\n\nSuppose we want to modify this python script to be more like the R script, where we tell python what the file name is in the file itself, instead of waiting for user input at the terminal.\n\nInstead of using the `input` command, I just provide python with a string that contains the path to the file. If you have downloaded the text file to a different folder and RStudio's working directory is set to that folder, you would change the first line to `name = \"dickens-oliver-627.txt\"` - I have set things up to live in a data folder because if I had all of the files in the same directory where this book lives, I would never be able to find anything.\n\nCreate a new python script file in RStudio (File -\\> New File -\\> Python Script) and paste in the following lines of code, adjusting the path to the text file appropriately.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nname = \"data/dickens-oliver-627.txt\"\nhandle = open(name, 'r')\ncounts = dict()\n\nfor line in handle:\n    words = line.split()\n    for word in words:\n        counts[word] = counts.get(word, 0) + 1\n\nbigcount = None\nbigword = None\nfor word, count in list(counts.items()):\n    if bigcount is None or count > bigcount:\n        bigword = word\n        bigcount = count\n\nprint(bigword, bigcount)\n\n# Code: http://www.py4e.com/code3/words.py\n## the 8854\n```\n:::\n\n\n![Above script in the RStudio text editor window, with the first 3 lines of code highlighted](images/intro-prog/python-wordcount-rstudio-noinput-interactive1.png)\n\nWith the first 3 lines highlighted, click the Run button.\n\n![In the console, the first 3 lines of the program have run. Note that we are still in python mode - the \\>\\>\\> indicates that the python interpreter is waiting for additional instructions.](images/intro-prog/python-wordcount-rstudio-noinput-interactive2.png) We can examine the objects that we have defined this far in the program by typing their names into the console directly.\n\n![RStudio python console allows us to examine the objects we have defined after the first 3 lines of code have been run. We can see that counts is an empty object, handle is a pointer to a text file, and name is a string with the path to the text file -- so far, so good.](images/intro-prog/python-wordcount-rstudio-noinput-interactive3.png)\n\nIf we want to continue walking through the program chunk by chunk, we can run the next four lines of code. Lines 5-8 are a for loop, so we should run them all at once unless we want to fiddle with how the for loop works.\n\n![RStudio editor window with the next four lines of the code chunk highlighted. If we click the Run button, we can tell python to evaluate these few lines of code, and then we can see what the objects we've defined look like once that has been done](images/intro-prog/python-wordcount-rstudio-noinput-interactive4.png)\n\nSelect lines 5-8 as shown above, and click the Run button. Your console window should update with additional lines of code. You can type in `counts` after that has been evaluated to see what the `counts` object looks like now.\n\n![RStudio python console with lines 5-8 run and the counts object displayed. Counts is now filled with words and corresponding integer counts of the frequency of that word's appearance in the text](images/intro-prog/python-wordcount-rstudio-noinput-interactive5.png)\n\nThe next few lines of code determine which word has the highest count. We won't get into the details here, but to finish out the running of the program, select lines 10-17 and run them in RStudio.\n\n![RStudio editor window and console showing the results when lines 10-17 are evaluated. It is clear that line 17 results in the console output of `the 8854`](images/intro-prog/python-wordcount-rstudio-noinput-interactive6.png)\n\nRunning scripts in interactive mode or within RStudio is much more convenient if you are still working on the script - it allows you to debug the script line-by-line if necessary. Running a script at the terminal (like we did above) is sometimes more convenient if you have a pre-written script that you know already works. Both modes are useful, but for the time being you will probably be running scripts within your development environment (RStudio or VSCode or any other IDE you prefer) more often than at the command line.\n\n#### R (RStudio)\n\nJust for fun, let's work with [Oliver Twist, by Charles Dickens](http://www.textfiles.com/etext/AUTHORS/DICKENS/dickens-oliver-627.txt), which I have saved [here](data/dickens-oliver-627.txt).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in the file\ntext <- readLines(\"dickens-oliver-627.txt\")\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n```\n:::\n\n\nMake a new R script (File -\\> New File -\\> R script) and copy the above code into R, or [download the file to your computer directly](code/words-noinput.R) and open the downloaded file in RStudio.\n\nIn the R console, run the command `getwd()` to see where R is running from. This is your \"working directory\".\n\n![R editor window with relevant script, with R console shown below. My working directory is `/home/susan/Projects/Class/unl-stat151/stat151book/demo`; yours will be different.](images/intro-prog/R-wordcount-rstudio-noinput-interactive1.png)\n\nSave the copy of Oliver Twist to the file `dickens-oliver-627.txt` in the folder that `getwd()` spit out. You can test that you have done this correctly by typing `list.files()` into the R console window and hitting enter. It is very important that you know where on your computer R is looking for files - otherwise, you will constantly get \"file not found\" errors, and that will be very annoying.\n\n![R editor window with relevant script, with R console shown below. dickens-oliver-627.txt is in the working directory, so we can proceed.](images/intro-prog/R-wordcount-rstudio-noinput-interactive2.png)\n\nUse the \"Run\" button to run the script and see what the output is. How many times does 'the' appear in the file?\n\n#### Interactive R\n\nUsing the file you created above, let's examine what each line does in interactive mode.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in the file\ntext <- readLines(\"dickens-oliver-627.txt\")\n```\n:::\n\n\nSelect the above line and click the \"Run\" button in RStudio. Once you've done that, type in `text[1:5]` in the R console to see the first 5 lines of the file.\n\n![RStudio editor window with the first 2 lines of the words-noinput.R file selected. The screenshot also shows the console window after running the first 2 lines of the R file, with the `text[1:5]` command run interactively afterwards showing the first 5 lines of the text file we read in.](images/intro-prog/R-wordcount-rstudio-noinput-interactive3.png)\n\nRun the next line of code using the run button (or click on the line of code and hit Ctrl/Cmd + Enter).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n```\n:::\n\n\nType in `text[[1]]` to see what the `text` object looks like now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntext[[1]]\n##  [1] \"The\"       \"Project\"   \"Gutenberg\" \"Etext\"     \"of\"        \"Oliver\"   \n##  [7] \"Twist\"     \"by\"        \"Charles\"   \"Dickens\"\n```\n:::\n\n\n![Screenshot of RStudio editor window with lines of code highlighted, plus RStudio console with the code as run and `text[[1]]` showing the first entry in the text object - a list of the separate words in the first line of the text file.](images/intro-prog/R-wordcount-rstudio-noinput-interactive4.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simplify the list\ntext <- unlist(text)\ntext[[1]]\n## [1] \"The\"\ntext[1:20]\n##  [1] \"The\"       \"Project\"   \"Gutenberg\" \"Etext\"     \"of\"        \"Oliver\"   \n##  [7] \"Twist\"     \"by\"        \"Charles\"   \"Dickens\"   \"#13\"       \"in\"       \n## [13] \"our\"       \"series\"    \"by\"        \"Charles\"   \"Dickens\"   \"Copyright\"\n## [19] \"laws\"      \"are\"\n```\n:::\n\n\nRunning `unlist` on text simplifies the object so that it is now a single **vector** of every word in the file, without regard for which line it appears on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count up the number of occurrences of each word\nword_freq <- table(text)\nword_freq[1:5]\n## text\n##             _I_     --'    --by --kneel \n##    4558       4       1       1       1\n```\n:::\n\n\nThe next line assembles a table of frequency counts in `text`. There are 4558 spaces, 4 occurrences of the string `_I_`, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\nword_freq[1:5]\n## text\n##  the  and        to   of \n## 8854 4902 4558 3767 3763\n```\n:::\n\n\nWe can then sort `word_freq` so that the most frequent words are listed first. The final line just prints out the first 10 words instead of the first 5.\n\n#### R Terminal\n\nDownload the following file to your working directory: [words.R](code/words.R), or paste the following code into a new R script and save it as `words.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Take arguments from the command line\nargs <- commandArgs(TRUE)\n\n# Read in the file\ntext <- readLines(args[1])\n\n# Split the lines of text into separate words\ntext <- strsplit(text, \" \")\n\n# Simplify the list\ntext <- unlist(text)\n\n# Count up the number of occurrences of each word\nword_freq <- table(text)\n\n# Sort the table by decreasing frequency\nword_freq <- sort(word_freq, decreasing = T)\n\n# Show the counts for the most common 10 words\nword_freq[1:10]\n```\n:::\n\n\nIn a terminal window opened at the location you saved the file (and the corresponding text file), enter the following: `Rscript words.R dickens-oliver-627.txt`.\n\nHere, `Rscript` is the command that tells R to evaluate the file, `words.R` is the R code to run, and `dickens-oliver-627.txt` is an argument to your R script that tells R where to find the text file. This is similar to the python code, but instead, the user passes the file name in at the same time as the script instead of having to wait around a little bit.\n:::\n:::\n\n### Comparing Python and R\n\nThis is one good example of the difference in culture between python and R: python is a general-purpose programming language, where R is a domain specific programming language. In both languages, I've shown you how I would run the script by default first - in python, I would use a pre-built script to run things, and in R I would open things up in RStudio and source the script rather than running R from the command line.\n\nThis is a bit of a cultural difference -- because python is a general purpose programming language, it is easy to use for a wide variety of tasks, and is a common choice for creating scripts that are used on the command line. R is a domain-specific language, so it is extremely easy to use R for data analysis, but that tends to take place (in my experience) in an interactive or script-development setting using RStudio. It is less natural to me to write an R script that takes input from the user on the command line, even though obviously R is completely capable of doing that task. More commonly, I will write an R script for my own use, and thus there is no need to make it easy to use on the command line, because I can just change it in interactive mode. Python scripts, on the other hand, may be written for a novice to use at the command line with no idea of how to write or modify python code. This is a subtle difference, and may not make a huge impression on you now, but it is something to keep in mind as you learn to write code in each language -- the culture around python and the culture around R are slightly different, and this affects how each language is used in practice.\n\n## Scripts and Notebooks\n\nWe've talked about organizing code in scripts and running them at the command line, but there is a (somewhat) more recent way to program that involves mixing code and text together in a document, usually called a **notebook**. This interweaving of code and text is called [**literate programming**](https://en.wikipedia.org/wiki/Literate_programming) and was first proposed by @knuth84.\n\nThere are many advantages to each workflow, and they are useful in different situations. In this section, try to figure out when you might want to use a script and when you might want to use a notebook.\n\n### Scripts\n\n**Scripts** are files of code that are meant to be run on their own. They may produce results, or format data and save it somewhere, or scrape data from the web -- scripts can do just about anything. As you saw in the previous section, a script can be used in interactive mode as well, but their primary purpose is generally to run autonomously, even if they are sometimes written interactively.\n\nScripts can have documentation within the file, using `#` characters (at least, in R and python) at the beginning of a line. `#` indicates a comment -- that is, that the line does not contain code and should be ignored by the computer when the program is run. Comments are incredibly useful to help humans understand what the code does and why it does it.\n\n::: callout-caution\n#### Plotting a [logarithmic spiral](https://mathworld.wolfram.com/LogarithmicSpiral.html)\n\nThis code will use concepts we have not yet introduced - feel free to tinker with it if you want, but know that you're not responsible for being able to **write** this code yet. You just need to read it and get a sense for what it does. I have heavily commented it to help with this process.\n\n::: panel-tabset\n##### R {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta <- seq(0, 4*pi, .01) \n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta\nr <- seq(0, 5, length.out = length(theta))\n\n# Now define x and y in cartesian coordinates\nx <- r * cos(theta)\ny <- r * sin(theta)\n\nplot(x, y, type = \"l\")\n```\n\n::: {.cell-output-display}\n![A Cartesian Spiral in R](intro-prog_files/figure-html/fig-polar-r-1.png){#fig-polar-r width=2100}\n:::\n:::\n\n\nI have saved this script [here](files/markdown-spiral-script.R). You can download it and open it up in RStudio (File -\\> Open -\\> Navigate to file location).\n\n##### Python {.unnumbered}\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Define the angle of the spiral (polar coords)\n# go around two full times (2*pi = one revolution)\ntheta = np.arange(0, 4 * np.pi, 0.01)\n# Define the distance from the origin of the spiral\n# Needs to have the same length as theta \n# (get length of theta with theta.size, \n#  and then divide 5 by that to get the increment)\nr = np.arange(0, 5, 5/theta.size)\n\n# Now define x and y in cartesian coordinates\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\n# Define the axes\nfig, ax = plt.subplots()\n# Plot the line\nax.plot(x, y)\nplt.show()\n```\n\n::: {.cell-output-display}\n![A Cartesian Spiral in python](intro-prog_files/figure-html/fig-polar-py-1.png){#fig-polar-py width=672}\n:::\n:::\n\n\nI have saved this script [here](files/markdown-spiral-script.py). You can download it and open it up in RStudio (File -\\> Open -\\> Navigate to file location).\n:::\n:::\n\nScripts can be run in Rstudio by clicking the Run button ![RStudio run button](images/intro-prog/Run-button-Rstudio.png) at the top of the editor window when the script is open.\n\n::: callout-tip\n#### Try it out! {.unnumbered}\n\n-   Download the R and python scripts in the above example, open them in RStudio, and run each script using the Run button. What do you see?\n\n-   (Advanced) Open a terminal in RStudio (Tools -\\> Terminal -\\> New Terminal) and see if you can run the R script from the terminal using\\\n    `R CMD BATCH path/to/file/markdown-spiral-script.R`\\\n    (You will have to modify this command to point to the file on your machine)\\\n    Notice that two new files appear in your working directory: `Rplots.pdf` and `markdown-spiral-script.Rout`\n\n-   (Advanced) Open a terminal in RStudio (Tools -\\> Terminal -\\> New Terminal) and see if you can run the R script from the terminal using\\\n    `python3 path/to/file/markdown-spiral-script.py`\\\n    (You will have to modify this command to point to the file on your machine)\n:::\n\nMost of the time, you will run scripts interactively - that is, you'll be sitting there watching the script run and seeing what the results are as you are modifying the script. However, one advantage to scripts over notebooks is that it is easy to write a script and schedule it to run without supervision to complete tasks which may be repetitive.\n\nHere are some examples of scripts I have running on my machine:\n\n-   A script that runs daily at midnight, 6am, noon, and 6pm to pull images of shoes off of shopping sites online for research purposes\n-   A script that runs every 10 minutes to push updates from a dataset on my server to github so that my students can access the latest data\n-   A script that runs every 10 minutes to pull updates from a github repository so that the web application on my server has the latest updates\n-   A script that runs daily to pull the day's weather off of the National Weather Service site to maintain a local log (because I'm a weather nerd)\n\nThese scheduled tasks make my life easier and make it possible for me to do research more effectively without requiring me to remember to do tasks on a regular schedule.\n\n### Notebooks\n\nNotebooks are an implementation of literate programming. Both R and python have native notebooks that are cross-platform and allow you to code in R or python. This book is written using Quarto markdown, which is an extension of Rmarkdown, but it is also possible to use jupyter notebooks to write R and python code.\n\nThis book will focus on the use of Quarto/R markdown, because it is a much better tool for creating polished reports than Jupyter (in my opinion). My goal is that you learn something useful for your own class work that can be easily applied when you go to work as an analyst somewhere to produce impressive documents. Jupyter notebooks are great for interactive coding, but aren't so wonderful for producing polished results. They also don't allow you to switch between languages mid-notebook, and since I'm writing this in both R and python (and will be teaching that way as well), I want you to have both languages available.\n\n::: callout-note\n#### Learn more about notebooks \nThere are some excellent opinions surrounding the use of notebooks in data analysis:\n\n-   [Why I Don't Like Notebooks\"](https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/preview#slide=id.g362da58057_0_1) by Joel Grus at JupyterCon 2018\n-   [The First Notebook War](https://yihui.org/en/2018/09/notebook-war/) by Yihui Xie (response to Joel's talk).[^intro-prog-1]\n:::\n\n[^intro-prog-1]: Yihui Xie is the person responsible for `knitr` and `Rmarkdown` and has been heavily involved in the creation of `quarto` as well.\n\n::: callout-tip\n#### Try it out\n\n::: panel-tabset\n##### R markdown\n\nTake a look at the [R markdown sample file](files/markdown-demo.Rmd) I've created to go with the R script above. You can see the HTML file it generates [here](files/markdown-demo.html).\n\n-   Download the Rmd file and open it with RStudio.\n\n-   Change the output to `output: word_document` and hit the Render button ![Render button in RStudio](images/intro-prog/Render-button-Rstudio.png). Can you find the markdown-demo.docx file that was generated? What does it look like?\n\n-   Change the output to `output: pdf_document` and hit the Render button ![Render button in RStudio](images/intro-prog/Render-button-Rstudio.png). Can you find the markdown-demo.pdf file that was generated? What does it look like?\n\nRmarkdown tries very hard to preserve your formatted text appropriately regardless of the output document type. While things may not look exactly the same, the goal is to allow you to focus on the content and the formatting will \"just work\".\n\n##### Jupyter\n\nTake a look at the [jupyter notebook sample file](files/Jupyter-demo.ipynb) I've created to go with the R script above. You can see the HTML file it generates [here](files/Jupyter-demo.html).\n\n-   Download the ipynb file and open it with jupyter.\n\n-   Export the notebook as a pdf file (File -\\> Save as -\\> PDF via HTML). Can you find the jupyter-demo.pdf file that was generated? What does it look like?\n\n-   Export the notebook as an html file (File -\\> Save as -\\> HTML). Can you find the jupyter-demo.html file that was generated? What does it look like?\n\n##### Quarto markdown\n\nThe nice thing about quarto is that it will work with python and R seamlessly, and you can compile the document using python or R. R markdown will also allow you to use python chunks, but you must compile the document using R; quarto can be compiled using the command line and is more platform-agnostic.\n\nTake a look at the [Qmd notebook sample file](files/quarto-demo.qmd) I've created to go with the scripts above. You'll notice that it is basically the script portion of this textbook -- that's because I'm writing the textbook in Quarto.\n\n-   Download the qmd file and open it with RStudio\n\n-   Try to compile the file by hitting the Render button ![Render button in RStudio](images/intro-prog/Render-button-Rstudio.png)\n\n-   (Advanced) In the terminal, type in `quarto render path/to/file/quarto-demo.qmd`. Does that render the HTML file? One advantage of this is that using quarto to render the file doesn't require R at the command line. As the document contains R chunks, R is still required to compile the document, but the biggest difference between qmd and rmd is that qmd files are workflow agnostic - you can generate them in e.g. MS Visual Studio Code, compile them in that workflow, and never have to use RStudio.\n:::\n:::\n\n::: callout-warning\n## Additional Material {.unnumbered}\n\n### Textbooks {.unnumbered}\n\n-   [R for Data Science](https://r4ds.had.co.nz/) [@r4ds]\n-   [Advanced R](http://adv-r.had.co.nz/Introduction.html) [@advr]\n-   [Non Programmer's Tutorial for Python 3](https://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3) [@NonProgrammerTutorialPython2021]\n\n### Other Course Websites {.unnumbered}\n\n-   Stat 850 at UNL (Bilder): [@bilderStat850Course2019]\n-   [Stat 579 at Iowa State](https://stat579-at-isu.github.io/schedule.html): [@hofmannStat579Iowa2020]\n-   [Stat 545 at Univ. British Columbia](https://stat545.com/): [@bryanStat545UBC2019]\n-   [Introduction to SAS](https://online.stat.psu.edu/statprogram/stat480) - Undergraduate course at Penn State\n-   [Intermediate SAS](https://online.stat.psu.edu/statprogram/stat481) - Undergraduate course at Penn State\n-   [Advanced SAS](https://online.stat.psu.edu/statprogram/stat482) - Undergraduate course at Penn State\n\n### Helpful Debugging Resources {.unnumbered}\n\n- [Common R Problems](https://nickch-k.github.io/DataCommSlides/Lecture_04_Common_R_Problems.html#common-r-problems)\n:::\n\n## References {#intro-prog-refs}\n",
    "supporting": [
      "intro-prog_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}