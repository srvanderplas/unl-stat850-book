{
  "hash": "6bffb14b66373becc5b1999a213a0132",
  "result": {
    "markdown": "# Lists, Nested Lists, and Functional Programming {#sec-functional-programming}\n\n\n## Module Objectives  {- #module14-objectives}\n\n- Use functional programming techniques to create code which is well organized and easier to understand and maintain\n\n\n## Review\n### Lists and Vectors\n\nA **vector** is a 1-dimensional data structure that contains items of the same simple ('atomic') type (character, logical, integer, factor). \n\n::: panel-tabset\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\n(logical_vec <- c(T, F, T, T))\n## [1]  TRUE FALSE  TRUE  TRUE\n(numeric_vec <- c(3, 1, 4, 5))\n## [1] 3 1 4 5\n(char_vec <- c(\"A\", \"AB\", \"ABC\", \"ABCD\"))\n## [1] \"A\"    \"AB\"   \"ABC\"  \"ABCD\"\n```\n:::\n\n\n#### Python\nNotice that in python, we define each of these things as a list first, and then convert to a numpy array, which is equivalent to an R vector.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\nlogical_vec = np.array([True, False, True, True])\nlogical_vec\n## array([ True, False,  True,  True])\nnumeric_vec = np.array([3, 1, 4, 5])\nnumeric_vec\n## array([3, 1, 4, 5])\nchar_vec = np.array(['A', 'AB', 'ABC', 'ABCD'])\nchar_vec\n## array(['A', 'AB', 'ABC', 'ABCD'], dtype='<U4')\n```\n:::\n\n:::\n\nYou **index** a vector using brackets: to get the $i$th element of the vector `x`, you would use `x[i]` in R or `x[i-1]` in python (Remember, python is 0-indexed, so the first element of the vector is at location 0).\n\n::: panel-tabset\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\nlogical_vec[3]\n## [1] TRUE\nnumeric_vec[3]\n## [1] 4\nchar_vec[3]\n## [1] \"ABC\"\n```\n:::\n\n\n#### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nlogical_vec[2]\n## True\nnumeric_vec[2]\n## 4\nchar_vec[2]\n## 'ABC'\n```\n:::\n\n:::\n\n\nYou can also index a vector using a logical vector:\n\n::: panel-tabset\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\nnumeric_vec[logical_vec]\n## [1] 3 4 5\nchar_vec[logical_vec]\n## [1] \"A\"    \"ABC\"  \"ABCD\"\nlogical_vec[logical_vec]\n## [1] TRUE TRUE TRUE\n```\n:::\n\n\n#### Python\n\n::: {.cell}\n\n```{.python .cell-code}\nnumeric_vec[logical_vec]\n## array([3, 4, 5])\nchar_vec[logical_vec]\n## array(['A', 'ABC', 'ABCD'], dtype='<U4')\nlogical_vec[logical_vec]\n## array([ True,  True,  True])\n```\n:::\n\n\n:::\n\nA **list** is a 1-dimensional data structure that has no restrictions on what type of content is stored within it. \nA list is a \"vector\", but it is not an atomic vector - that is, it does not necessarily contain things that are all the same type.\n\n::: panel-tabset\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(\n  mylist <- list(\n    logical_vec, \n    numeric_vec, \n    third_thing = char_vec[1:2]\n  )\n)\n## [[1]]\n## [1]  TRUE FALSE  TRUE  TRUE\n## \n## [[2]]\n## [1] 3 1 4 5\n## \n## $third_thing\n## [1] \"A\"  \"AB\"\n```\n:::\n\n\nIn R, list components may have names (or not), be homogeneous (or not), have the same length (or not). \n\n#### Python\n\nIn python, lists are similar, but do not have named entries. \n\n::: {.cell}\n\n```{.python .cell-code}\nmylist = [logical_vec, numeric_vec, char_vec[0:1]]\n```\n:::\n\n\nIn python, list components are unnamed, but can be homogeneous (or not) and may have the same length (or not).\n\n:::\n\n### Indexing\n\nIndexing necessarily differs between R and python, and since the list types are also somewhat different (e.g. lists cannot be named in python), we will treat list indexing in the two languages separately.\n\n::: panel-tabset\n#### R\n\n\n::: {#fig-pepper layout-ncol=4}\n![An unusual pepper shaker which we'll call `pepper`](images/data-structures/02_pepper.jpg){fig-alt=\"A pepper shaker containing several individual paper packets of pepper\"}\n\n![When a list is indexed with single brackets, `pepper[1]`, the return value is always a list containing the selected element(s).](images/data-structures/02_pepper-1.jpg){fig-alt=\"A pepper shaker containing a single individual paper packet of pepper.\"}\n\n![When a list is indexed with double brackets, `pepper[[1]]`, the return value is the selected element.](images/data-structures/02_pepper-2.jpg){fig-alt=\"A single individual paper packet of pepper, no longer contained within a pepper shaker.\"}\n\n![To actually access the pepper, we have to use double indexing and index both the list object and the sub-object, as in `pepper[[1]][[1]]`.](images/data-structures/02_pepper-3.jpg){fig-alt=\"A pile of pepper, free from any containment structures.\"}\n\nThe types of indexing in R are made most memorable with a fantastic visual example from @r4ds, which I have repeated here. This example may be familiar from @sec-indexing, but hopefully at this point it makes a lot more sense.\n:::\n\n\nIn R, there are 3 ways to index a list:\n\n- With single square brackets, just like we index atomic vectors. In this case, the return value is always a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[1]\n## [[1]]\n## [1]  TRUE FALSE  TRUE  TRUE\n\nmylist[2]\n## [[1]]\n## [1] 3 1 4 5\n\nmylist[c(T, F, T)]\n## [[1]]\n## [1]  TRUE FALSE  TRUE  TRUE\n## \n## $third_thing\n## [1] \"A\"  \"AB\"\n```\n:::\n\n\n- With double square brackets. In this case, the return value is the thing inside the specified position in the list, but you also can only get one entry in the main list at a time. You can also get things by name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[[1]]\n## [1]  TRUE FALSE  TRUE  TRUE\n\nmylist[[\"third_thing\"]]\n## [1] \"A\"  \"AB\"\n```\n:::\n\n\n- Using `x$name`. This is equivalent to using `x[[\"name\"]]`. Note that this does not work on unnamed entries in the list. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist$third_thing\n## [1] \"A\"  \"AB\"\n```\n:::\n\n\nTo access the contents of a list object, we have to use double-indexing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist[[\"third_thing\"]][[1]]\n## [1] \"A\"\n```\n:::\n\n\n\n\n::: callout-note\nYou can get a more thorough review of vectors and lists [from Jenny Bryan's purrr tutorial introduction](https://jennybc.github.io/purrr-tutorial/bk00_vectors-and-lists.html) [@bryanLessonsExamples20191021].\n:::\n\n#### Python\n\nBecause Python lists are unnamed, indexing is pretty straightforward and works exactly like indexing vectors.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhhgtg = ['the', 'answer', 'to', 'life', 'is', 42]\n\nhhgtg[5]\n## 42\nhhgtg[0:5]\n## ['the', 'answer', 'to', 'life', 'is']\n```\n:::\n\n\nIndexing nested lists is just a matter of appending multiple sets of indexes.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# The quote above is an abbreviation... here's the full version\nhhgtg = ['the', 'answer', 'to', 'the', \n         'ultimate', 'question', 'of', \n         ['life', 'the universe', 'and everything'], \n         'is', 42]\n\nhhgtg[7]\n## ['life', 'the universe', 'and everything']\nhhgtg[7][0]\n## 'life'\n```\n:::\n\n\n:::\n\n## Vectorized Operations\n\nOperations in R and numpy are (usually) **vectorized** - that is, by default, they operate on vectors. This is primarily a feature that applies to atomic vectors (and we don't even think about it): \n\n::: panel-tabset\n### R\n\n::: {.cell}\n\n```{.r .cell-code}\n(rnorm(10) + rnorm(10, mean = 3))\n##  [1] 4.096248 3.182472 4.160299 2.167633 2.849340 3.004994 1.883960 3.282649\n##  [9] 1.372756 1.108213\n```\n:::\n\n\n\n### Numpy\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\nnpx = np.array([1,2,3])\nnpy = np.array([4,5,6])\nnpx + npy # numpy uses vectorized arithmetic operations\n## array([5, 7, 9])\n```\n:::\n\n\n:::\n\nWith vectorized functions, we don't have to use a for loop to add these two vectors with 10 entries each together. In languages which don't have implicit support for vectorized computations, this might instead look like:\n\n::: panel-tabset\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- rnorm(10)\nb <- rnorm(10, mean = 3)\n\nresult <- rep(0, 10)\nfor (i in 1:10) {\n  result[i] <- a[i] + b[i]\n}\n\nresult\n##  [1] 3.8859799 3.2256176 2.3621698 3.4717828 3.2511672 4.3374697 4.0713542\n##  [8] 2.2581989 3.3939106 0.1578225\n```\n:::\n\n\n### (Base) Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1, 2, 3]\ny = [4, 5, 6]\n\nx + y # This just appends the lists... which is not what we want\n\n# This is what we actually want\n## [1, 2, 3, 4, 5, 6]\nz = [0, 0, 0]\nfor i in range(3):\n  z[i] = x[i] + y[i]\n\nz\n## [5, 7, 9]\n```\n:::\n\n\n:::\n\n\nThat is, we would **apply** or **map** the `+` function to each entry of a and b. For atomic vectors, it's easy to do this by default; with a list, however, we need to be a bit more explicit (because everything that's passed into the function may not be the same type). \n\nThe R package `purrr` (and similar base functions `apply`, `lapply`, `sapply`, `tapply`, and `mapply`) are based on extending \"vectorized\" functions to a wider variety of vector-like structures. \n\n::: column-margin\nI find the purrr package easier to work with, but you may use the base package versions if you want, and you can find a [side-by-side comparison in the purrr tutorial](https://jennybc.github.io/purrr-tutorial/bk01_base-functions.html).\n:::\n\nIn python, similar methods apply but are built in to pandas [@koneswarakanthaMovingPythonPandas2018]. As a result, I have structured this section based on the `purrr` package, but will show equivalent python code where possible.\n\n## Functional Programming\n\n::: callout-note\nA much more thorough treatment of functional programming is available in [Advanced R](http://adv-r.had.co.nz/Functional-programming.html) [@wickhamFunctionalProgramming2019]. This is a bare summary in comparison.\n:::\n\nOne last concept that is relevant to this chapter is the idea of **functional programming**. This concept is a bit hard to define rigorously at the level we're working at, but generally, functional programming is concerned with **pure functions**: functions that have an input value that determines the output value and create no other side effects. \n\nWhat this means is that you describe every step of the computation using a function, and chain the functions together. At the end of the computations, you might save the program's results to an object, but (in general), the goal is to not change things outside of the \"pipeline\" along the way.\n\nThis has some advantages:\n\n- Easier parallelization    \n\"Side effects\" generally make it hard to parallelize code because e.g. you have to update stored objects in memory, which is hard to do with multiple threads accessing the same memory.\n- Functional programming tends to be easier to read    \nYou can see output and input and don't have to work as hard to keep track of what is stored where .\n- Easier Debugging    \nYou can examine the input and output at each stage to isolate which function is introducing the problem.\n\nThe introduction of the pipe in R has made chaining functions together in a functional programming-style pipeline much easier. `purrr` is just another step in this process: by making it easy to apply functions to lists of things (or to use multiple lists of things in a single function), `purrr` makes it easier to write clean, understandable, debuggable code.\n\n::: column-margin\nWhile I'm not quite ready to introduce it in class, because the syntax has changed significantly from V1 to V2, there is also a [Pipe](https://github.com/JulienPalard/Pipe) package for python [@tranWriteCleanPython2021] that may be worth investigating.\n:::\n\n\n::: callout-caution\n### Functional Programming Example\n\nThis example is modified from the motivation section of the [Functional Programming chapter](http://adv-r.had.co.nz/Functional-programming.html) in Advanced R [@wickhamFunctionalProgramming2019].\n\n::: panel-tabset\n\n#### Problem\n\nSuppose we want to replace every -99 in the following sample dataset with an NA. (-99 is sometimes used to indicate missingness in datasets).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a sample dataset\nset.seed(1014)\ndf <- data.frame(replicate(6, sample(c(1:10, -99), 6, rep = TRUE)))\nnames(df) <- letters[1:6]\ndf\n##   a   b   c   d  e f\n## 1 7   5 -99   2  5 2\n## 2 5   5   5   3  6 1\n## 3 6   8   5   9  9 4\n## 4 4   2   2   6  6 8\n## 5 6   7   6 -99 10 6\n## 6 9 -99   4   7  5 1\n```\n:::\n\n\n#### Naive Approach\n\nThe \"beginner\" approach is to just replace each individual -99 with an NA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- df\ndf1[6,2] <- NA\ndf1[1,3] <- NA\ndf1[5,4] <- NA\n\ndf1\n##   a  b  c  d  e f\n## 1 7  5 NA  2  5 2\n## 2 5  5  5  3  6 1\n## 3 6  8  5  9  9 4\n## 4 4  2  2  6  6 8\n## 5 6  7  6 NA 10 6\n## 6 9 NA  4  7  5 1\n```\n:::\n\n\nThis is tedious, and painful, and won't work if we have a slightly different dataset where the -99s are in different places. So instead, we might consider being a bit more general:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- df\ndf2$a[df2$a == -99] <- NA\ndf2$b[df2$b == -99] <- NA\ndf2$c[df2$c == -99] <- NA\ndf2$d[df2$d == -99] <- NA\ndf2$e[df2$e == -99] <- NA\ndf2$f[df2$f == -99] <- NA\ndf2\n##   a  b  c  d  e f\n## 1 7  5 NA  2  5 2\n## 2 5  5  5  3  6 1\n## 3 6  8  5  9  9 4\n## 4 4  2  2  6  6 8\n## 5 6  7  6 NA 10 6\n## 6 9 NA  4  7  5 1\n```\n:::\n\n\nThis requires a few more lines of code, but is able to handle any data frame with 6 columns `a` - `f`. It also requires a lot of copy-paste and can leave you vulnerable to making mistakes.\n\n#### Writing a function\n\nThe standard rule is that if you copy-paste the same code 3x, then you should write a function, so let's try that instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfix_missing <- function(x, missing = -99){\n  x[x == missing] <- NA\n  x\n}\n\ndf3 <- df\ndf3$a <- fix_missing(df$a)\ndf3$b <- fix_missing(df$b)\ndf3$c <- fix_missing(df$c)\ndf3$d <- fix_missing(df$d)\ndf3$e <- fix_missing(df$e)\ndf3$f <- fix_missing(df$f)\ndf3\n##   a  b  c  d  e f\n## 1 7  5 NA  2  5 2\n## 2 5  5  5  3  6 1\n## 3 6  8  5  9  9 4\n## 4 4  2  2  6  6 8\n## 5 6  7  6 NA 10 6\n## 6 9 NA  4  7  5 1\n```\n:::\n\n\nThis still requires a lot of copy-paste, and doesn't actually make the code more readable. We can more easily change the missing value, though, which is a bonus. \n\n#### Mapping a function\n\nWe have a function that we want to **apply** or **map** to every column in our data frame. We could use a for loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfix_missing <- function(x, missing = -99){\n  x[x == missing] <- NA\n  x\n}\n\ndf4 <- df\nfor (i in 1:ncol(df)) {\n  df4[,i] <- fix_missing(df4[,i])\n}\ndf4\n##   a  b  c  d  e f\n## 1 7  5 NA  2  5 2\n## 2 5  5  5  3  6 1\n## 3 6  8  5  9  9 4\n## 4 4  2  2  6  6 8\n## 5 6  7  6 NA 10 6\n## 6 9 NA  4  7  5 1\n```\n:::\n\n\nThis is more understandable and flexible than the previous function approach as well as the naive approach - we don't need to know the names of the columns in our data frame, or even how many there are. It is still quite a few lines of code, though.\n\nIterating through a list (or columns of a data frame) is a very common task, so R has a shorthand function for it. For these purposes, I'll use the base function `lapply`, since it doesn't require any additional packages and demonstrates the concept nicely.\n\n`lapply(x, f, ...)` is a function that takes arguments `x`, a list, `f`, a function, and `...` - a special parameter in R that can handle one or more arguments that are passed to the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfix_missing <- function(x, missing = -99){\n  x[x == missing] <- NA\n  x\n}\n\ndf5 <- df\ndf5[] <- lapply(df5, fix_missing)\ndf5\n##   a  b  c  d  e f\n## 1 7  5 NA  2  5 2\n## 2 5  5  5  3  6 1\n## 3 6  8  5  9  9 4\n## 4 4  2  2  6  6 8\n## 5 6  7  6 NA 10 6\n## 6 9 NA  4  7  5 1\n```\n:::\n\n\nBy default, `lapply` returns a list. By assigning the results to `df5[]`, we tell R we want the results to be a data frame, instead.\n\nWe've replaced 6 lines of code that only worked for 6 columns named `a` - `f` with a single line of code that works for any data frame with any number of rows and columns, so long as -99 indicates missing data. In addition to being shorter, this code is also somewhat easier to read and much less vulnerable to typos.\n\n:::\n\n:::\n\n\n## Introduction to `map`\n\n::: column-margin\nThe source data for this example comes from [An API of Ice and Fire](https://anapioficeandfire.com/) and is fairly typical for API (automatic programming interface) data in both cleanliness and complexity.\n:::\n\n### Data Setup\n\nFirst, let's export the data from `repurrrsive` to a JSON file that we can read into R or Python, so that we start out in both languages at approximately the same place.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(repurrrsive) # example data\ndata(got_chars)\n\nlibrary(rjson)\nwrite(toJSON(got_chars), \"data/got_chars.json\")\n```\n:::\n\n\n\n::: panel-tabset\n#### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) \nlibrary(purrr) # functions for working with lists\ngot_chars <- fromJSON(file = \"data/got_chars.json\")\n```\n:::\n\n\nWe'll use one of the datasets in `repurrsive`, `got_chars`, to start playing with the `map_` series of functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(got_chars)\n## [1] 30\ngot_chars[[1]][1:6] # Only show the first 6 fields\n## $url\n## [1] \"https://www.anapioficeandfire.com/api/characters/1022\"\n## \n## $id\n## [1] 1022\n## \n## $name\n## [1] \"Theon Greyjoy\"\n## \n## $gender\n## [1] \"Male\"\n## \n## $culture\n## [1] \"Ironborn\"\n## \n## $born\n## [1] \"In 278 AC or 279 AC, at Pyke\"\nnames(got_chars[[1]]) # How many total fields? names?\n##  [1] \"url\"         \"id\"          \"name\"        \"gender\"      \"culture\"    \n##  [6] \"born\"        \"died\"        \"alive\"       \"titles\"      \"aliases\"    \n## [11] \"father\"      \"mother\"      \"spouse\"      \"allegiances\" \"books\"      \n## [16] \"povBooks\"    \"tvSeries\"    \"playedBy\"\n```\n:::\n\n\nIt appears that each entry in this 30-item list is a character from Game of Thrones, and there are several sub-fields for each character. \n\n#### Python\n\nWe can read the data in to Python as a pandas DataFrame. Note that the default structure here is very different than the equivalent R structure for reading in a JSON file.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\ngot_chars = pd.read_json('data/got_chars.json')\n\nfrom skimpy import skim\nskim(got_chars) \n## ╭─────────────────────────────── skimpy summary ───────────────────────────────╮\n## │          Data Summary                Data Types                              │\n## │ ┏━━━━━━━━━━━━━━━━━━━┳━━━━━━━━┓ ┏━━━━━━━━━━━━━┳━━━━━━━┓                       │\n## │ ┃ dataframe         ┃ Values ┃ ┃ Column Type ┃ Count ┃                       │\n## │ ┡━━━━━━━━━━━━━━━━━━━╇━━━━━━━━┩ ┡━━━━━━━━━━━━━╇━━━━━━━┩                       │\n## │ │ Number of rows    │ 30     │ │ object      │ 16    │                       │\n## │ │ Number of columns │ 18     │ │ int64       │ 1     │                       │\n## │ └───────────────────┴────────┘ │ bool        │ 1     │                       │\n## │                                └─────────────┴───────┘                       │\n## │                                   number                                     │\n## │ ┏━━━━┳━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━┳━━━━━┳━━━━┳━━━━━┳━━━━━━┳━━━━━━┳━━━━━━━━┓  │\n## │ ┃    ┃ missing ┃ complete  ┃ mean ┃ sd  ┃ p0 ┃ p25 ┃ p75  ┃ p100 ┃ hist   ┃  │\n## │ ┃    ┃         ┃ rate      ┃      ┃     ┃    ┃     ┃      ┃      ┃        ┃  │\n## │ ┡━━━━╇━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━╇━━━━━╇━━━━╇━━━━━╇━━━━━━╇━━━━━━╇━━━━━━━━┩  │\n## │ │ id │       0 │         1 │  710 │ 500 │ 60 │ 220 │ 1100 │ 2100 │ █▃▅▅ ▁ │  │\n## │ └────┴─────────┴───────────┴──────┴─────┴────┴─────┴──────┴──────┴────────┘  │\n## │                                    bool                                      │\n## │ ┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┓  │\n## │ ┃                ┃ true        ┃ true rate              ┃ hist            ┃  │\n## │ ┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━┩  │\n## │ │ alive          │          20 │                   0.67 │     ▄    █      │  │\n## │ └────────────────┴─────────────┴────────────────────────┴─────────────────┘  │\n## ╰──────────────────────────────────── End ─────────────────────────────────────╯\n```\n:::\n\n\nAs most of the columns are object types, using `skimpy` to examine the data structure really doesn't help us much.\n\n:::\n\n### Exploring the Data\n\nWhat characters do we have? How is the data structured?\n\nList data can be incredibly hard to work with because the structure is so flexible. It's important to have a way to visualize the structure of a complex list object: the `View()` command in RStudio is one good way to explore and poke around a list.\n\n::: panel-tabset\n\n#### R\n\nWe can use `purrr::map(x, \"name\")` to get a list of all characters' names. Since they are all the same type, we could also use an extension of `map`, `map_chr`, which will coerce the returned list into a character vector (which may be simpler to operate on). \n\n::: callout-note\nThere are several packages with map() functions including functions that are meant to actually plot maps; it generally saves time and effort to just type the function name with the package you want in `package::function` notation. You don't *have* to do so, but if you have a lot of other (non tidyverse, in particular) packages loaded, it will save you a lot of grief.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(got_chars, \"name\")[1:5]\n## [[1]]\n## [1] \"Theon Greyjoy\"\n## \n## [[2]]\n## [1] \"Tyrion Lannister\"\n## \n## [[3]]\n## [1] \"Victarion Greyjoy\"\n## \n## [[4]]\n## [1] \"Will\"\n## \n## [[5]]\n## [1] \"Areo Hotah\"\npurrr::map_chr(got_chars, \"name\")[1:5]\n## [1] \"Theon Greyjoy\"     \"Tyrion Lannister\"  \"Victarion Greyjoy\"\n## [4] \"Will\"              \"Areo Hotah\"\n```\n:::\n\n\nSimilar shortcuts work to get the nth item in each sub list:\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_chr(got_chars, 4)\n##  [1] \"Male\"   \"Male\"   \"Male\"   \"Male\"   \"Male\"   \"Male\"   \"Male\"   \"Female\"\n##  [9] \"Female\" \"Male\"   \"Female\" \"Male\"   \"Female\" \"Male\"   \"Male\"   \"Male\"  \n## [17] \"Female\" \"Female\" \"Female\" \"Male\"   \"Male\"   \"Male\"   \"Male\"   \"Male\"  \n## [25] \"Male\"   \"Female\" \"Male\"   \"Male\"   \"Male\"   \"Female\"\n```\n:::\n\n\nSpecifying the output type using e.g. `map_chr` works if each item in the list is an atomic vector of length 1. If the list is more complicated, though, these shortcuts will issue an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(got_chars, \"books\")[1:5]\n## [[1]]\n## [1] \"A Game of Thrones\" \"A Storm of Swords\" \"A Feast for Crows\"\n## \n## [[2]]\n## [1] \"A Feast for Crows\"         \"The World of Ice and Fire\"\n## \n## [[3]]\n## [1] \"A Game of Thrones\" \"A Clash of Kings\"  \"A Storm of Swords\"\n## \n## [[4]]\n## [1] \"A Clash of Kings\"\n## \n## [[5]]\n## [1] \"A Game of Thrones\" \"A Clash of Kings\"  \"A Storm of Swords\"\npurrr::map_chr(got_chars, \"books\")[1:5]\n## Error in `stop_bad_type()`:\n## ! Result 1 must be a single string, not a character vector of length 3\n```\n:::\n\n\nWhat if we want to extract several things? This trick works off of the idea that `[` is a function: that is, the single brackets we used before are actually a special type of function. In R functions, there is often the argument `...`, which is a convention that allows us to pass arguments to other functions that are called within the main function we are using (you'll see ... used in plotting and regression functions frequently as well). \n\nHere, we use `...` to pass in our list of 3 things we want to pull from each item in the list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(got_chars, `[`, c(\"name\", \"gender\", \"born\"))[1:5]\n## [[1]]\n## [[1]]$name\n## [1] \"Theon Greyjoy\"\n## \n## [[1]]$gender\n## [1] \"Male\"\n## \n## [[1]]$born\n## [1] \"In 278 AC or 279 AC, at Pyke\"\n## \n## \n## [[2]]\n## [[2]]$name\n## [1] \"Tyrion Lannister\"\n## \n## [[2]]$gender\n## [1] \"Male\"\n## \n## [[2]]$born\n## [1] \"In 273 AC, at Casterly Rock\"\n## \n## \n## [[3]]\n## [[3]]$name\n## [1] \"Victarion Greyjoy\"\n## \n## [[3]]$gender\n## [1] \"Male\"\n## \n## [[3]]$born\n## [1] \"In 268 AC or before, at Pyke\"\n## \n## \n## [[4]]\n## [[4]]$name\n## [1] \"Will\"\n## \n## [[4]]$gender\n## [1] \"Male\"\n## \n## [[4]]$born\n## [1] \"\"\n## \n## \n## [[5]]\n## [[5]]$name\n## [1] \"Areo Hotah\"\n## \n## [[5]]$gender\n## [1] \"Male\"\n## \n## [[5]]$born\n## [1] \"In 257 AC or before, at Norvos\"\n```\n:::\n\n\nIf this is ugly syntax to you, that's fine - the `magrittr` package also includes an `extract` function that works the same way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(got_chars, magrittr::extract, c(\"name\", \"gender\", \"born\"))[1:5]\n## [[1]]\n## [[1]]$name\n## [1] \"Theon Greyjoy\"\n## \n## [[1]]$gender\n## [1] \"Male\"\n## \n## [[1]]$born\n## [1] \"In 278 AC or 279 AC, at Pyke\"\n## \n## \n## [[2]]\n## [[2]]$name\n## [1] \"Tyrion Lannister\"\n## \n## [[2]]$gender\n## [1] \"Male\"\n## \n## [[2]]$born\n## [1] \"In 273 AC, at Casterly Rock\"\n## \n## \n## [[3]]\n## [[3]]$name\n## [1] \"Victarion Greyjoy\"\n## \n## [[3]]$gender\n## [1] \"Male\"\n## \n## [[3]]$born\n## [1] \"In 268 AC or before, at Pyke\"\n## \n## \n## [[4]]\n## [[4]]$name\n## [1] \"Will\"\n## \n## [[4]]$gender\n## [1] \"Male\"\n## \n## [[4]]$born\n## [1] \"\"\n## \n## \n## [[5]]\n## [[5]]$name\n## [1] \"Areo Hotah\"\n## \n## [[5]]$gender\n## [1] \"Male\"\n## \n## [[5]]$born\n## [1] \"In 257 AC or before, at Norvos\"\n```\n:::\n\n\nWhat if we want this to be a data frame instead? We can use `map_dfr` to get a data frame that is formed by row-binding each element in the list. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map_dfr(got_chars, `[`, c(\"name\", \"gender\", \"born\")) \n## # A tibble: 30 × 3\n##    name               gender born                                    \n##    <chr>              <chr>  <chr>                                   \n##  1 Theon Greyjoy      Male   \"In 278 AC or 279 AC, at Pyke\"          \n##  2 Tyrion Lannister   Male   \"In 273 AC, at Casterly Rock\"           \n##  3 Victarion Greyjoy  Male   \"In 268 AC or before, at Pyke\"          \n##  4 Will               Male   \"\"                                      \n##  5 Areo Hotah         Male   \"In 257 AC or before, at Norvos\"        \n##  6 Chett              Male   \"At Hag's Mire\"                         \n##  7 Cressen            Male   \"In 219 AC or 220 AC\"                   \n##  8 Arianne Martell    Female \"In 276 AC, at Sunspear\"                \n##  9 Daenerys Targaryen Female \"In 284 AC, at Dragonstone\"             \n## 10 Davos Seaworth     Male   \"In 260 AC or before, at King's Landing\"\n## # … with 20 more rows\n\n# Equivalent to\npurrr::map(got_chars, `[`, c(\"name\", \"gender\", \"born\")) %>%\n  dplyr::bind_rows()\n## # A tibble: 30 × 3\n##    name               gender born                                    \n##    <chr>              <chr>  <chr>                                   \n##  1 Theon Greyjoy      Male   \"In 278 AC or 279 AC, at Pyke\"          \n##  2 Tyrion Lannister   Male   \"In 273 AC, at Casterly Rock\"           \n##  3 Victarion Greyjoy  Male   \"In 268 AC or before, at Pyke\"          \n##  4 Will               Male   \"\"                                      \n##  5 Areo Hotah         Male   \"In 257 AC or before, at Norvos\"        \n##  6 Chett              Male   \"At Hag's Mire\"                         \n##  7 Cressen            Male   \"In 219 AC or 220 AC\"                   \n##  8 Arianne Martell    Female \"In 276 AC, at Sunspear\"                \n##  9 Daenerys Targaryen Female \"In 284 AC, at Dragonstone\"             \n## 10 Davos Seaworth     Male   \"In 260 AC or before, at King's Landing\"\n## # … with 20 more rows\n```\n:::\n\n\nIf we want to more generally convert the entire data set to a data frame, we can use a couple of handy functions to do that: \n\n- `purrr::transpose` transposes a list, so that x[[1]][[2]] becomes x[[2]][[1]]. This turns the list into a set of columns.\n- `tibble::as_tibble` turns an object into a tibble. This creates a rectangular, data frame like structure\n- `purrr::unnest` takes columns and \"ungroups\" them, so that each entry in the sub-lists of the column gets a row in the data frame. Here, I've used this to unwrap lists that are all single items so that we can see some of the data. \n\nThese operations make the data look more or less like it does in Python by default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_df <- got_chars %>%\n  transpose() %>%\n  as_tibble() %>%\n  unnest(c(\"url\", \"id\", \"name\", \"gender\", \n           \"culture\", \"born\", \"died\", \"alive\", \n           \"father\", \"mother\", \"spouse\"))\n```\n:::\n\n\n#### Python\n\nIn python, because Pandas read things in as a DataFrame, we don't need to go to any great measures to get characters names - we can just access the column.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngot_chars.name[0:5]\n## 0        Theon Greyjoy\n## 1     Tyrion Lannister\n## 2    Victarion Greyjoy\n## 3                 Will\n## 4           Areo Hotah\n## Name: name, dtype: object\n```\n:::\n\n\nSimilarly, we can use normal indexing to access the fourth item in each sub-list (which corresponds to the 4th column), assuming we remember that Python is 0-indexed, so we need the column with index 3.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngot_chars.iloc[0:5,3] \n## 0    Male\n## 1    Male\n## 2    Male\n## 3    Male\n## 4    Male\n## Name: gender, dtype: object\n```\n:::\n\n\nBut what happens when our columns are made up of more complicated objects, like when we examine which books each character appears in?\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngot_chars.books[0:5]\n## 0    [A Game of Thrones, A Storm of Swords, A Feast...\n## 1       [A Feast for Crows, The World of Ice and Fire]\n## 2    [A Game of Thrones, A Clash of Kings, A Storm ...\n## 3                                     A Clash of Kings\n## 4    [A Game of Thrones, A Clash of Kings, A Storm ...\n## Name: books, dtype: object\n```\n:::\n\n\nThis is a little bit messier. What if we want to know the first book the character appears in? We have to handle the fact that some entries are lists, some are strings, and some are entirely empty. We can use list comprehensions to do this in shorthand, or we can write out a full for loop:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nz1 = [x if type(x) == str else x[0] if len(x) > 0  else \"\" for x in got_chars.books]\n\nz2 = ['']*len(got_chars.books)\nfor i in got_chars.books.index:\n  j = got_chars.books[i]\n  if type(j) == str:\n    z2[i] = j\n  elif len(j) > 0:\n    z2[i] = j[0]\n  else:\n    z2[i] = ''\nz1\n\n# Check, both methods are the same\n## ['A Game of Thrones', 'A Feast for Crows', 'A Game of Thrones', 'A Clash of Kings', 'A Game of Thrones', 'A Game of Thrones', 'A Storm of Swords', 'A Game of Thrones', 'A Feast for Crows', 'A Feast for Crows', '', 'A Game of Thrones', 'A Game of Thrones', 'A Game of Thrones', 'A Storm of Swords', 'A Feast for Crows', 'A Clash of Kings', 'A Feast for Crows', 'A Game of Thrones', 'A Clash of Kings', 'A Game of Thrones', 'A Storm of Swords', 'A Feast for Crows', 'A Game of Thrones', 'A Game of Thrones', 'A Clash of Kings', 'A Game of Thrones', 'A Game of Thrones', 'A Game of Thrones', 'A Dance with Dragons']\nz1 == z2\n\n  \n## True\n```\n:::\n\n\nThe first version is more compact and more 'pythonic', but the second is more readable.\n\n:::\n\n### Map inside Mutate\n\nA very powerful way to work with data is to use a map function inside of a mutate statement: to simplify data and create a new column all in one go. Let's use this to create a more human-readable (though somewhat less \"clean\") data frame: \n\n- function to simplify a character list-column, \n    - replace any 0-length/NULL entries with an empty string\n    - paste all of the entries together, separated by \", \"\n    - ensure that the resulting list is coerced to a character vector\n- Then, we can apply the above function to each list column in our data frame.\n\n::: panel-tabset\n\n#### R\n\n::: {.cell}\n\n```{.r .cell-code}\npaste_entries <- function(x) {\n  # Replace any null entries of x with \"\"\n  x[map_int(x, length) == 0] <- \"\"\n  \n  map_chr(x, ~paste(., collapse = \", \"))\n}\n\ngot_df <- got_df %>%\n  mutate(across(where(is.list), paste_entries))\n```\n:::\n\n\n#### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\ndef paste_entries(x):\n  # Copy x to y so that x is not modified directly\n  y = x.copy()\n  \n  # Replace any null entries of x with \"\"\n  ylen = np.array([len(i) for i in x])\n  y[ylen == 0] = \"\"\n  \n  # if the entry in y is a list, collapse it, otherwise do nothing\n  # this for loop iterates over the index and the item at the same time\n  for idx, i in enumerate(y):\n    if isinstance(i, list):\n      y[idx] = ', '.join(map(str, i))\n  \n  return y\n\n## Approach 1: split the data frame then rejoin\n# split off non-object columns\ndf1 = got_chars.select_dtypes(exclude=['object'])\ndf2 = got_chars.select_dtypes(include=['object'])\n# apply our function to object columns\ndf2fix = df2.apply(paste_entries, axis = 1)\n# join back together\ngot_df = pd.concat([df2fix, df1], axis = 1)\n\n## Approach 2: keep the data frame together and mutate only some cols\n# Get a logical vector of columns to mutate\ndfcols = got_df.columns[np.array(got_chars.dtypes == 'object')]\n# Avoid copy on write errors by copying the data frame to a new object\ngot_df = got_chars.copy()\n# Replace any columns that are objects with the pasted version\ngot_df[dfcols] = got_df[dfcols].apply(paste_entries, axis = 1)\n## Error in py_call_impl(callable, dots$args, dots$keywords): TypeError: object of type 'int' has no len()\n```\n:::\n\n\n:::\n\n## Creating (and Using) List-columns\n\nData structures in R are typically list-based in one way or another. Sometimes, more complicated data structures are actually lists of lists, or tibbles with a list-column, or other variations on \"list within a ____\". In combination with `purrr`, this is an *incredibly* powerful setup that can make working with simulations and data very easy. In Python, list columns come along with pandas by default and are incredibly common when you're working with data stored as a JSON, YAML, XML, and other markup formats. \n\n::: callout-caution\n\n### Example: Benefits of List columns\n\n::: panel-tabset\n\n#### R\n\nSuppose, for instance, I want to simulate some data for modeling purposes, where I can control the number of outliers in the dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_sim <- function(n_outliers = 0) {\n  tmp <- tibble(x = seq(-10, 10, .1),\n                y = rnorm(length(x), mean = x, sd = 1))\n  \n  \n  outlier_sample <- c(NULL, sample(tmp$x, n_outliers))\n  \n  # Create outliers\n  tmp %>% \n    mutate(\n      is_outlier = x %in% outlier_sample,\n      y = y + is_outlier * sample(c(-1, 1), n(), replace = T) * runif(n(), 5, 10)\n    )\n}\ndata_sim()\n## # A tibble: 201 × 3\n##        x      y is_outlier\n##    <dbl>  <dbl> <lgl>     \n##  1 -10   -10.8  FALSE     \n##  2  -9.9 -11.4  FALSE     \n##  3  -9.8  -8.86 FALSE     \n##  4  -9.7  -9.52 FALSE     \n##  5  -9.6  -9.36 FALSE     \n##  6  -9.5  -7.88 FALSE     \n##  7  -9.4  -9.29 FALSE     \n##  8  -9.3  -9.43 FALSE     \n##  9  -9.2 -11.1  FALSE     \n## 10  -9.1  -9.38 FALSE     \n## # … with 191 more rows\n```\n:::\n\n\nNow, lets suppose that I want 100 replicates of each of 0, 5, 10, and 20 outliers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim <- crossing(rep = 1:100, n_outliers = c(0, 5, 10, 20)) %>%\n  mutate(sim_data = purrr::map(n_outliers, data_sim))\n```\n:::\n\n\nI could use `unnest(sim_data)` if I wanted to expand my data a bit to see what I have, but in this case, it's more useful to leave it in its current, compact form. Instead, suppose I fit a linear regression to each of the simulated data sets, and store the fitted linear regression object in a new list-column?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim <- sim %>%\n  mutate(reg = purrr::map(sim_data, ~lm(data = ., y ~ x)))\n```\n:::\n\n\nHere, we use an **anonymous** function in purrr: by using `~{expression}`, we have defined a function that takes the argument `.` (which is just a placeholder). So in our case, we're saying \"use the data that I pass in to fit a linear regression of `y` using `x` as a predictor\". \n\nLet's play around a bit with this: We might want to look at our regression coefficients or standard errors to see how much the additional outliers affect us. We could use a fancy package for tidy modeling, such as `broom`, but for now, lets do something a bit simpler and apply the purrr name extraction functions we used earlier.\n\nIt can be helpful to examine one of the objects just to see what you're dealing with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sim$reg[[1]])\n## List of 12\n##  $ coefficients : Named num [1:2] -0.117 1.001\n##   ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"x\"\n##  $ residuals    : Named num [1:201] 0.584 -0.721 0.696 1.282 -0.627 ...\n##   ..- attr(*, \"names\")= chr [1:201] \"1\" \"2\" \"3\" \"4\" ...\n##  $ effects      : Named num [1:201] 1.662 82.367 0.733 1.318 -0.591 ...\n##   ..- attr(*, \"names\")= chr [1:201] \"(Intercept)\" \"x\" \"\" \"\" ...\n##  $ rank         : int 2\n##  $ fitted.values: Named num [1:201] -10.13 -10.03 -9.93 -9.83 -9.73 ...\n##   ..- attr(*, \"names\")= chr [1:201] \"1\" \"2\" \"3\" \"4\" ...\n##  $ assign       : int [1:2] 0 1\n##  $ qr           :List of 5\n##   ..$ qr   : num [1:201, 1:2] -14.1774 0.0705 0.0705 0.0705 0.0705 ...\n##   .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. ..$ : chr [1:201] \"1\" \"2\" \"3\" \"4\" ...\n##   .. .. ..$ : chr [1:2] \"(Intercept)\" \"x\"\n##   .. ..- attr(*, \"assign\")= int [1:2] 0 1\n##   ..$ qraux: num [1:2] 1.07 1.11\n##   ..$ pivot: int [1:2] 1 2\n##   ..$ tol  : num 1e-07\n##   ..$ rank : int 2\n##   ..- attr(*, \"class\")= chr \"qr\"\n##  $ df.residual  : int 199\n##  $ xlevels      : Named list()\n##  $ call         : language lm(formula = y ~ x, data = .)\n##  $ terms        :Classes 'terms', 'formula'  language y ~ x\n##   .. ..- attr(*, \"variables\")= language list(y, x)\n##   .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n##   .. .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. .. ..$ : chr [1:2] \"y\" \"x\"\n##   .. .. .. ..$ : chr \"x\"\n##   .. ..- attr(*, \"term.labels\")= chr \"x\"\n##   .. ..- attr(*, \"order\")= int 1\n##   .. ..- attr(*, \"intercept\")= int 1\n##   .. ..- attr(*, \"response\")= int 1\n##   .. ..- attr(*, \".Environment\")=<environment: 0x55c0f382a350> \n##   .. ..- attr(*, \"predvars\")= language list(y, x)\n##   .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n##   .. .. ..- attr(*, \"names\")= chr [1:2] \"y\" \"x\"\n##  $ model        :'data.frame':\t201 obs. of  2 variables:\n##   ..$ y: num [1:201] -9.55 -10.75 -9.23 -8.55 -10.36 ...\n##   ..$ x: num [1:201] -10 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 ...\n##   ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language y ~ x\n##   .. .. ..- attr(*, \"variables\")= language list(y, x)\n##   .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n##   .. .. .. ..- attr(*, \"dimnames\")=List of 2\n##   .. .. .. .. ..$ : chr [1:2] \"y\" \"x\"\n##   .. .. .. .. ..$ : chr \"x\"\n##   .. .. ..- attr(*, \"term.labels\")= chr \"x\"\n##   .. .. ..- attr(*, \"order\")= int 1\n##   .. .. ..- attr(*, \"intercept\")= int 1\n##   .. .. ..- attr(*, \"response\")= int 1\n##   .. .. ..- attr(*, \".Environment\")=<environment: 0x55c0f382a350> \n##   .. .. ..- attr(*, \"predvars\")= language list(y, x)\n##   .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n##   .. .. .. ..- attr(*, \"names\")= chr [1:2] \"y\" \"x\"\n##  - attr(*, \"class\")= chr \"lm\"\n```\n:::\n\n\nIf we pull out the coefficients by name we get a vector of length two. So before we unnest, we need to change that so that R formats it as a row of a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim$reg[[1]]$coefficients %>% as_tibble_row()\n## # A tibble: 1 × 2\n##   `(Intercept)`     x\n##           <dbl> <dbl>\n## 1        -0.117  1.00\n```\n:::\n\n\nThis will make our formatting a lot easier and prevent any duplication that might occur if we unnest a vector that has length > 1. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim <- sim %>%\n  mutate(coefs = purrr::map(reg, \"coefficients\") %>%\n           purrr::map(as_tibble_row))\n\nsim$coefs[1:5]\n## [[1]]\n## # A tibble: 1 × 2\n##   `(Intercept)`     x\n##           <dbl> <dbl>\n## 1        -0.117  1.00\n## \n## [[2]]\n## # A tibble: 1 × 2\n##   `(Intercept)`     x\n##           <dbl> <dbl>\n## 1        -0.105 0.977\n## \n## [[3]]\n## # A tibble: 1 × 2\n##   `(Intercept)`     x\n##           <dbl> <dbl>\n## 1        -0.125 0.961\n## \n## [[4]]\n## # A tibble: 1 × 2\n##   `(Intercept)`     x\n##           <dbl> <dbl>\n## 1         0.211 0.966\n## \n## [[5]]\n## # A tibble: 1 × 2\n##   `(Intercept)`     x\n##           <dbl> <dbl>\n## 1         0.108  1.01\n```\n:::\n\n\nThen, we can plot our results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim %>%\n  unnest(coefs) %>%\n  select(rep, n_outliers, `(Intercept)`, x) %>%\n  pivot_longer(-c(rep, n_outliers), names_to = \"coef\", values_to = \"value\") %>%\n  ggplot(aes(x = value, color = factor(n_outliers))) + geom_density() + \n  facet_wrap(~coef, scales = \"free_x\")\n```\n\n::: {.cell-output-display}\n![](functional-programming_files/figure-html/list-cols7-1.png){width=2100}\n:::\n:::\n\n\nSo as there are more and more outliers, the coefficient estimates get a wider distribution, but remain (relatively) centered on the \"true\" values of 0 and 1, respectively. \n\nNotice that we keep our data in list column form right up until it is time to actually unnest it - which means that we have at the ready the simulated data, the simulated model, and the conditions under which it was simulated, all in the same data structure. It's a really nice, organized system.\n\n#### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef data_sim(n_outliers = 0):\n  tmp = pd.DataFrame({'x': range(-100, 100, 1), 'y': 0})\n  tmp['x'] = tmp.x/10\n  tmp['y'] = np.random.normal(size = len(tmp.x), loc = tmp.x, scale = 1)\n  tmp['is_outlier'] = False\n  \n  # Choose sample\n  outlier_sample = list(np.random.choice(tmp.index, size = n_outliers))\n  tmp.loc[outlier_sample, 'is_outlier'] = True\n  # Create outliers\n  tmp['y'] = tmp.y + tmp.is_outlier * np.random.choice([-1,1], len(tmp.index), replace = True) * (np.random.sample(size = len(tmp.index))*5 + 5)\n  \n  return tmp\n\ndata_sim()\n##         x          y  is_outlier\n## 0   -10.0  -8.615630       False\n## 1    -9.9  -9.282386       False\n## 2    -9.8 -11.125694       False\n## 3    -9.7  -9.517860       False\n## 4    -9.6  -9.653798       False\n## ..    ...        ...         ...\n## 195   9.5  11.883267       False\n## 196   9.6   9.297179       False\n## 197   9.7   7.945535       False\n## 198   9.8  11.113908       False\n## 199   9.9   9.923770       False\n## \n## [200 rows x 3 columns]\n```\n:::\n\n\nNow, lets suppose that I want 100 replicates of each of 0, 5, 10, and 20 outliers. \n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport itertools as it\n\nsim = pd.DataFrame(it.product(range(100), [0,5,10,20]))\nsim.columns = ['rep', 'n_outliers']\nsim['data'] = sim.n_outliers.apply(data_sim)\n```\n:::\n\n\nI could use `sim.explode('data')`, which is the pandas equivalent of `unnest()` in R, if I wanted to expand my data a bit to see what I have, but in this case, it's more useful to leave it in its current, compact form. Instead, suppose I fit a linear regression to each of the simulated data sets, and store the fitted linear regression object in a new column?\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom sklearn.linear_model import LinearRegression\n\n# This function just makes it a bit simpler to run linear regressions \n# by moving the reshaping from pd.Series to np.array inside the function.\ndef lreg(df):\n  X = df.loc[:,'x'].values.reshape(-1,1)\n  Y = df.loc[:,'y'].values.reshape(-1,1)\n  lregobj = LinearRegression()\n  lregobj.fit(X, Y)\n  return lregobj\n\nsim['reg'] = sim.data.apply(lreg)\n```\n:::\n\n\nIn a more simple example, we could use an anonymous lambda function here as well (I've demonstrated this in other places in this book), but it's a good idea to know when to use anonymous functions, and if they take more than a line of code, it's better to define a named function instead.\n\nLet's play around a bit with this: We might want to look at our regression coefficients or standard errors to see how much the additional outliers affect us. \n\nIt can be helpful to examine one of the objects just to see what you're dealing with:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsim.reg[0]\n\n# We can use the regression object to make predictions\n```\n\n::: {.cell-output-display}\n```{=html}\n<style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: \"▸\";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: \"▾\";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: \"\";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: \"\";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id=\"sk-container-id-1\" class=\"sk-top-container\"><div class=\"sk-text-repr-fallback\"><pre>LinearRegression()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class=\"sk-container\" hidden><div class=\"sk-item\"><div class=\"sk-estimator sk-toggleable\"><input class=\"sk-toggleable__control sk-hidden--visually\" id=\"sk-estimator-id-1\" type=\"checkbox\" checked><label for=\"sk-estimator-id-1\" class=\"sk-toggleable__label sk-toggleable__label-arrow\">LinearRegression</label><div class=\"sk-toggleable__content\"><pre>LinearRegression()</pre></div></div></div></div></div>\n```\n:::\n\n```{.python .cell-code}\nsim.reg[0].predict(sim.data[0].x.values.reshape(-1,1))[0:10]\n## array([[-9.96234581],\n##        [-9.86210883],\n##        [-9.76187185],\n##        [-9.66163487],\n##        [-9.56139788],\n##        [-9.4611609 ],\n##        [-9.36092392],\n##        [-9.26068694],\n##        [-9.16044995],\n##        [-9.06021297]])\nsim.reg[0].coef_ # Slope\n## array([[1.00236982]])\nsim.reg[0].intercept_ # Intercept\n## array([0.06135242])\n```\n:::\n\n\nIf we pull out the coefficients by name we get a vector of length two. So before we unnest, we need to change that so that R formats it as a row of a data frame.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsim['coef'] = sim.reg.apply(lambda x: x.coef_[0])\nsim['intercept'] = sim.reg.apply(lambda x: x.intercept_)\nsim[['coef','intercept']]\n##                      coef                intercept\n## 0    [1.0023698231233278]    [0.06135241846652731]\n## 1    [1.0110948633547137]    [-0.3352445668499911]\n## 2    [1.0052749068195836]   [-0.20413176000098113]\n## 3    [1.0302173118405402]   [-0.11580709112777833]\n## 4    [0.9866128945470576]   [0.011473162003821986]\n## ..                    ...                      ...\n## 395  [0.9858802082967044]  [-0.011756628213911928]\n## 396  [0.9949013921221167]    [0.03225461650765866]\n## 397  [1.0170495910756496]    [0.05694564748206274]\n## 398   [1.012342843368514]    [0.07840335880278498]\n## 399  [0.9847894940809924]   [-0.12237977359705118]\n## \n## [400 rows x 2 columns]\n```\n:::\n\n\nThen, we can plot our results:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsimcoefs = sim.explode(['coef', 'intercept'])\ntmp = pd.melt(simcoefs[['rep', 'n_outliers', 'intercept', 'coef']], ['rep', 'n_outliers'])\n\nimport seaborn as sns\ng = sns.FacetGrid(tmp, col = 'variable', hue = 'n_outliers', sharex = False)\ng.map_dataframe(sns.kdeplot, x='value', palette = \"crest\")\n```\n\n::: {.cell-output-display}\n![](functional-programming_files/figure-html/unnamed-chunk-22-1.png){width=94}\n:::\n\n```{.python .cell-code}\ng.add_legend()\n```\n\n::: {.cell-output-display}\n![](functional-programming_files/figure-html/unnamed-chunk-22-2.png){width=107}\n:::\n\n```{.python .cell-code}\nplt.show()\n## Error in py_call_impl(callable, dots$args, dots$keywords): NameError: name 'plt' is not defined\n```\n:::\n\n\nSo as there are more and more outliers, the coefficient estimates get a wider distribution, but remain (relatively) centered on the \"true\" values of 0 and 1, respectively. \n\nNotice that we keep our data in nested form right up until it is time to actually \"explode\" it - which means that we have at the ready the simulated data, the simulated model, and the conditions under which it was simulated, all in the same data structure. It's a really nice, organized system.\n\n:::\n\n:::\n\n## Ways to use `map` and `apply`\n\nThere are 3 main use cases for `map` (and its cousins `pmap`, `map2`, etc.):\n\n1. Use with an existing function\n2. Use with an anonymous function, defined on the fly\n3. Use with a formula (which is just a concise way to define an anonymous function)\n\nTwo of these use cases also are relevant to `apply` in python:\n\n1. Use with an existing function\n2. Use with an anonymous (lambda) function, defined on the fly\n\n(Python doesn't seem to use formulas in quite the same way R does)\n\n\nI'll use a trivial example to show the difference between these options:\n\n::: panel-tabset\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# An existing function\nres <- tibble(x = 1:10, y1 = map_dbl(x, log10))\n\n# An anonymous function\nres <- res %>% mutate(y2 = map_dbl(x, function(z) z^2/10))\n\n# A formula equivalent to function(z) z^5/(z + 10)\n# the . is the variable you're manipulating\nres <- res %>% mutate(y3 = map_dbl(x, ~.^5/(.+10)))\n```\n:::\n\n\nIt can be a bit tricky to differentiate between options 2 and 3 in practice - the biggest difference is that you're not using the keyword `function` and your variable is the default placeholder variable `.` used in the tidyverse. \n\n### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nres = pd.DataFrame({'x': range(10)})\n\nres['y'] = res.x.apply(np.log10)\n\nres['y1'] = res.x.apply(lambda x: x**2/10)\n```\n:::\n\n\nThe lambda function is something of a hybrid between anonymous functions and formulas in R: it's defined on the fly, but has a bit more structure than the formula option in R.\n\n:::\n\n::: callout-tip\n### Try it out \n\n::: panel-tabset\n\n#### Problem\nCreate a new column containing a single string of all of the books each character was in. \n\nTo do this, you'll need to collapse the list of books for each character into a single string, which you can do with the `paste` function and the `collapse` argument in R, or with some modification to the `paste_entries` function we defined earlier in Python, which I've copied here for convenience. (The function won't work out of the box, because it was designed to work on each column of a DataFrame, and here we'd be applying it to each row.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters[1:10] %>% paste(collapse = \"|\")\n## [1] \"a|b|c|d|e|f|g|h|i|j\"\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndef paste_entries(x):\n  # Copy x to y so that x is not modified directly\n  y = x.copy()\n  \n  # Replace any null entries of x with \"\"\n  ylen = np.array([len(i) for i in x])\n  y[ylen == 0] = \"\"\n  \n  # if the entry in y is a list, collapse it, otherwise do nothing\n  # this for loop iterates over the index and the item at the same time\n  for idx, i in enumerate(y):\n    if isinstance(i, list):\n      y[idx] = ', '.join(map(str, i))\n  \n  return y\n\nx = [chr(i) for i in range(ord('a'), ord('k'))]\nx = pd.Series([x])\nx\n## 0    [a, b, c, d, e, f, g, h, i, j]\n## dtype: object\npaste_entries(x)\n## 0    a, b, c, d, e, f, g, h, i, j\n## dtype: object\n```\n:::\n\n\nStart with this data frame of character names and book list-columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(got_chars)\n\ngot_df <- tibble(name = map_chr(got_chars, \"name\"),\n                 id = map_int(got_chars, \"id\"),\n                 books = map(got_chars, \"books\"))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\ngot_chars = pd.read_json('data/got_chars.json')\n\ngot_df = got_chars[[\"name\", \"id\", \"books\"]]\n```\n:::\n\n\n#### R Solution\n\n\n::: {.cell depends='[\"map-tryitout2\",\"map-tryitout1\"]'}\n\n```{.r .cell-code}\n# Define a function\nmy_collapse <- function(x) paste(x, collapse = \" | \")\n\ndata(got_chars)\n\ngot_df <- tibble(name = map_chr(got_chars, \"name\"),\n                 id = map_int(got_chars, \"id\"),\n                 books = map(got_chars, \"books\"))\n\ngot_df <- got_df %>%\n  mutate(\n    fun_def_res = map_chr(books, my_collapse),\n    # Here, I don't have to define a function, I just pass my additional \n    # argument in after the fact...\n    fun_base_res = map_chr(books, paste, collapse = \" | \"),\n    \n    # Here, I can just define a new function without a name and apply it to \n    # each entry\n    fun_anon_res = map_chr(books, function(x) paste(x, collapse = \" | \")),\n    \n    # And here, I don't even bother to specifically say that I'm defining a \n    # function, I just apply a formula to each entry\n    fun_formula_res = map_chr(books, ~paste(., collapse = \" | \"))\n  ) \n\nhead(got_df)\n## # A tibble: 6 × 7\n##   name                 id books     fun_def_res          fun_b…¹ fun_a…² fun_f…³\n##   <chr>             <int> <list>    <chr>                <chr>   <chr>   <chr>  \n## 1 Theon Greyjoy      1022 <chr [3]> A Game of Thrones |… A Game… A Game… A Game…\n## 2 Tyrion Lannister   1052 <chr [2]> A Feast for Crows |… A Feas… A Feas… A Feas…\n## 3 Victarion Greyjoy  1074 <chr [3]> A Game of Thrones |… A Game… A Game… A Game…\n## 4 Will               1109 <chr [1]> A Clash of Kings     A Clas… A Clas… A Clas…\n## 5 Areo Hotah         1166 <chr [3]> A Game of Thrones |… A Game… A Game… A Game…\n## 6 Chett              1267 <chr [2]> A Game of Thrones |… A Game… A Game… A Game…\n## # … with abbreviated variable names ¹​fun_base_res, ²​fun_anon_res,\n## #   ³​fun_formula_res\n```\n:::\n\n\n#### Python Solution\n\nThe equivalent of apply for a single row or column is `transform` - it is applied rowwise (or columnwise).\n\nThen we use `.assign()` to get around the copy-vs-view warnings.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndef collapse_entries(x):\n  if len(x) < 1:\n    return x\n  elif isinstance(x, str):\n    return x\n  else: \n    return ' | '.join(map(str, x))\n  \n  return NULL\n\ngot_df = got_df.assign(books_simple = got_df['books'].transform(collapse_entries))\n```\n:::\n\n\n\n:::\n\n:::\n\n<!-- ## Other Purrr functions -->\n## Beyond `map`: Functions with multiple inputs\n\nSometimes, you might need to map a function over two vectors/lists in parallel. `purrr` has you covered with the `map2` function. As with `map`, the syntax is `map2(thing1, thing2, function, other.args)`; the big difference is that `function` takes two arguments.\n\nIn Python, you can use lambda functions to specify which columns of your data go into which function arguments.\n\n::: callout-caution\n### Example\n\n::: panel-tabset\n\n#### R\n\nLet's create a simple times-table:\n\n::: {.cell}\n\n```{.r .cell-code}\ncrossing(x = 1:10, y = 1:10) %>%\n  mutate(times = map2_int(x, y, `*`)) %>%\n  pivot_wider(names_from = y, names_prefix = 'y=', values_from = times)\n## # A tibble: 10 × 11\n##        x `y=1` `y=2` `y=3` `y=4` `y=5` `y=6` `y=7` `y=8` `y=9` `y=10`\n##    <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>  <int>\n##  1     1     1     2     3     4     5     6     7     8     9     10\n##  2     2     2     4     6     8    10    12    14    16    18     20\n##  3     3     3     6     9    12    15    18    21    24    27     30\n##  4     4     4     8    12    16    20    24    28    32    36     40\n##  5     5     5    10    15    20    25    30    35    40    45     50\n##  6     6     6    12    18    24    30    36    42    48    54     60\n##  7     7     7    14    21    28    35    42    49    56    63     70\n##  8     8     8    16    24    32    40    48    56    64    72     80\n##  9     9     9    18    27    36    45    54    63    72    81     90\n## 10    10    10    20    30    40    50    60    70    80    90    100\n# we could use `multiply_by` instead of `*` if we wanted to\n```\n:::\n\n\nIf you are using formula notation to define functions with `map2`, you will need to refer to your two arguments as `.x` and `.y`. You can determine this from the Usage section when you run `map2`, which shows you `map2(.x, .y, .f, ...)` - that is, the first argument is .x, the second is .y, and the third is the function. \n\nLike `map`, you can specify the type of the output response using `map2`. This makes it very easy to format the output appropriately for your application.\n\nYou can use functions with many arguments with `map` by using the `pmap` variant; here, you pass in a list of functions, which are identified by position (`..1, ..2, ..3,` etc). Note the `..` - you are referencing the list first, and the index within the list argument 2nd. \n\n#### Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nimport itertools as it\n\nx10 = pd.DataFrame(it.product(range(11), range(11)))\nx10.columns = ['x', 'y']\nx10['times'] = x10.apply(lambda x: x['x']*x['y'], axis = 1)\n\nx10.pivot(index = 'x', columns = 'y', values = 'times')\n## y   0   1   2   3   4   5   6   7   8   9    10\n## x                                              \n## 0    0   0   0   0   0   0   0   0   0   0    0\n## 1    0   1   2   3   4   5   6   7   8   9   10\n## 2    0   2   4   6   8  10  12  14  16  18   20\n## 3    0   3   6   9  12  15  18  21  24  27   30\n## 4    0   4   8  12  16  20  24  28  32  36   40\n## 5    0   5  10  15  20  25  30  35  40  45   50\n## 6    0   6  12  18  24  30  36  42  48  54   60\n## 7    0   7  14  21  28  35  42  49  56  63   70\n## 8    0   8  16  24  32  40  48  56  64  72   80\n## 9    0   9  18  27  36  45  54  63  72  81   90\n## 10   0  10  20  30  40  50  60  70  80  90  100\n```\n:::\n\n\n:::\n\n:::\n\n\n::: callout-tip\n### Try it out \n\n::: panel-tabset\n#### Problem\nDetermine if each Game of Thrones character has more titles than aliases. Start with this code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(repurrrsive)\nlibrary(tidyverse)\n\ndata(got_chars)\ngot_names <- tibble(name = purrr::map_chr(got_chars, \"name\"),\n                    titles = purrr::map(got_chars, \"titles\"),\n                    aliases = purrr::map(got_chars, \"aliases\"))\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ngot_names = got_chars[['name', 'titles', 'aliases']]\n```\n:::\n\n\n#### R Solution\n\n::: {.cell}\n\n```{.r .cell-code}\ngot_names %>%\n  mutate(more_titles = map2_lgl(titles, aliases, ~length(.x) > length(.y)))\n## # A tibble: 30 × 4\n##    name               titles    aliases    more_titles\n##    <chr>              <list>    <list>     <lgl>      \n##  1 Theon Greyjoy      <chr [3]> <chr [4]>  FALSE      \n##  2 Tyrion Lannister   <chr [2]> <chr [11]> FALSE      \n##  3 Victarion Greyjoy  <chr [2]> <chr [1]>  TRUE       \n##  4 Will               <chr [1]> <chr [1]>  FALSE      \n##  5 Areo Hotah         <chr [1]> <chr [1]>  FALSE      \n##  6 Chett              <chr [1]> <chr [1]>  FALSE      \n##  7 Cressen            <chr [1]> <chr [1]>  FALSE      \n##  8 Arianne Martell    <chr [1]> <chr [1]>  FALSE      \n##  9 Daenerys Targaryen <chr [5]> <chr [11]> FALSE      \n## 10 Davos Seaworth     <chr [4]> <chr [5]>  FALSE      \n## # … with 20 more rows\n```\n:::\n\n\n#### Python Solution\n\n::: {.cell}\n\n```{.python .cell-code}\n# Because len(list) and len(string) are both valid in python we have to be more careful\n\ndef cflen(i):\n  if isinstance(i, list):\n    return(len(i))\n  return bool(i) # this is 1 if there's something stored in i, 0 otherwise\n\nnewdf = got_names.copy()\nnewdf['more_titles'] = got_names.apply(lambda x: cflen(x['titles']) > cflen(x['aliases']), axis = 1)\n```\n:::\n\n\n:::\n\n:::\n\n\n::: callout-note\n\n## Learn More About Purrr\n\n- The Joy of Functional Programming (for Data Science): Hadley Wickham's talk on purrr and functional programming. [~1h video](https://learning.acm.org/techtalks/functionalprogramming) and [slides](https://learning.acm.org/binaries/content/assets/leaning-center/webinar-slides/2019/hadleywickham_techtalkslides.pdf).     \n(The Joy of Cooking meets Data Science, with illustrations by Allison Horst)\n\n- [Pirating Web Content Responsibly with R and purrr](https://rud.is/b/2017/09/19/pirating-web-content-responsibly-with-r/) (a blog post in honor of international talk like a pirate day) [@rudisPiratingWebContent2017]\n\n- [Happy R Development with purrr](https://colinfay.me/happy-dev-purrr/)\n\n- [Web mining with purrr](https://colinfay.me/purrr-web-mining/)\n\n- [Text Wrangling with purrr](https://colinfay.me/purrr-text-wrangling/)\n\n- [Setting NAs with purrr](https://colinfay.me/purrr-set-na/) (uses the `naniar` package)\n\n- [Mappers with purrr](https://colinfay.me/purrr-mappers/) - handy ways to make your code simpler if you're reusing functions a lot. \n\n- [Function factories - code optimization with purrr](https://colinfay.me/purrr-code-optim/)\n\n- [Stats and Machine Learning examples with purrr](https://colinfay.me/purrr-statistics/)\n\n:::\n",
    "supporting": [
      "functional-programming_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}