# SAS

## Setting up SAS {#setting-up-sas}

In this class, you have several options for how to use SAS:

1. Install SAS on your machine
    - <i class="fab fa-windows"></i> See Steve Westerholt, pay a small fee, and he will install SAS on your machine.
    - <i class="fab fa-apple"></i> Steve Westerholt will help you acquire Parallels desktop (to emulate Windows) and SAS. You'll pay license fees for both products. 
    - <i class="fab fa-linux"></i> Talk with me and I'll help you interface with Steve to get SAS for Linux installed on your system. Steve doesn't support Linux installs, but I can help you get SAS set up if you're using a common distribution like Ubuntu or RedHat/Fedora.
    
2. Use SAS University Edition/SAS OnDemand for Academics. Get more information [here](https://www.sas.com/en_us/software/on-demand-for-academics/references/getting-started-with-sas-ondemand-for-academics-studio.html). 
    - Pros - this is free
    - Cons - limited storage, may cause issues with paths and file upload/download (so it may be hard to ensure your homework assignments are reproducible).

3. ~~Use the Guacamole environment I've set up for the class via HCC. More information will be provided outside the textbook for this option.~~ (This is not an option in Fall 2022)
    - Pros - free, allows you access to SAS and Rstudio on the same machine (so you can use SASmarkdown seamlessly for homework). You can also use this to test the reproducibility of your assignment.
    - Cons - This interface is only available for Stat850 - it will not be available after the class concludes. 

## Finding Your Way around in SAS {#looking-around-sas}

SAS is another extensively used statistical programming language. It is primarily used for mixed models and in the biostatistics community (for e.g. drug trials). 

### Note {- .note}
SAS looks different on different machines. On Linux, SAS looks like you took a time machine back to the early 1990s. Screenshots from SAS will likely look *very* different on your machine than on mine. I will try to integrate screenshots from other OS's where it matters.^[As I write this in late July 2020, I do not yet have access to a Windows or Mac machine. Sigh. XXX TODO: Get Windows/Mac screenshots XXX. 

I still don't have access to a Windows or Mac machine, and it's now April 2021. Sigh.]

### SAS Windows/Panes

![The SAS toolbox has options to create new files, submit code, and more (but I mostly use keyboard shortcuts in the individual windows). This is probably one of the biggest things that's different on Linux...](images/sas/sas_toolbox.png)

![The SAS Log gives you lots of detailed information about how your code ran -- look here for errors and warnings.](images/sas/sas_log_window.png)

![The SAS program editor is where you'll be writing your code. If you want, you can write code in a more advanced text editor and copy/paste it into the log when you're ready to run it.](images/sas/sas_program_editor.png)

There are two different places your output may end up: if you're using the old output system, you'll get text output in the output pane.

![The old output system output pane.](images/sas/sas_output_old.png)

![The new output system uses HTML and will output to your browser.](images/sas/sas_modern_output.png)

![You can navigate through your results using the results window](images/sas/sas_results_window.png)

![The explorer window lets you access documentation, data, and more](images/sas/sas_explorer_1.png)

If you click on libraries, you get to this list:

![This area of the SAS explorer shows all of the libraries you have access to.](images/sas/sas_explorer_2.png)

![Clicking on any one library will show you a list of datasets in that library](images/sas/sas_explorer_3.png)


You can then click on a dataset and you will get a spreadsheet-like view. 


### SAS Modules

SAS is a very large set of programs. In this class, we're primarily working with base SAS (the underlying language and interpreter), SAS/STAT (the statistical procedures, like PROC GLM), and SAS/IML, which is SAS's version of a scripting language. IML allows you to implement your own procedures "from scratch". 

Initially, we'll primarily focus on SAS/IML, because it contains information parallel to what you need to know to start programming in R. It's easier to teach general programming concepts at the same time, even if your typical SAS course would probably introduce you to the DATA step and simple PROC statements first. 

## SAS computer basics

In SAS, you can set your working directory in the Program Editor, Log, or Explorer windows by clicking on Tools > Options > Change Directory, navigating to your preferred directory, and clicking ok.

![](images/sas/sas-screenshot-setwd.gif)

In SAS, you'll want to store your .sas code file in the RStudio project folder as well, and I believe that should be sufficient to set your working directory for any SAS code you may write as part of e.g. a homework assignment.

## Introduction to SAS Programming

A few notes on programming concepts and R vs. SAS

- <details><summary>Historical view</summary>
Both [R](https://bookdown.org/rdpeng/rprogdatascience/history-and-overview-of-r.html) and [SAS](https://en.wikipedia.org/wiki/SAS_(software)#History) have long histories. SAS in particular dates back to the 1960s, and has syntax which is unique compared to more modern languages such as C, python, Java, and R. R's predecessor, S, dates back to 1976 and was designed for internal use at Bell Labs. The histories of both languages are useful in understanding why they are optimized for their respective tasks, but are not essential for this course (so read them at your leisure).</details>

- <details><summary>Difference between R and SAS</summary><p>
The biggest difference between R and SAS (at a fundamental level) is that R is a [**functional** language](http://adv-r.had.co.nz/Functional-programming.html) - it consists mainly of functions, which can (and do) manipulate objects, including other functions. SAS, on the other hand, is a procedural language - most SAS programs follow a specific series of steps, known as "proc"s. Procs are essentially functions (or compositions of multiple functions), but in SAS, it is simpler to think of an analysis as a series of procedural steps; in R, there are steps, but they may be implemented in a more flexible way (depending on the analysis). </p><p>
Another interesting feature of SAS is that it's really several languages - some commands work in PROC IML (interactive matrix language) but not in a DATA step. When looking for help in SAS, make sure you're referencing the correct part of the language documentation.</p>
</details>

- <details><summary>I'm teaching SAS very differently</summary>
<p>I'm definitely teaching SAS differently than it is normally taught. This is so that we don't have to do half the semester in SAS and half in R - I'd rather teach the concepts and show you how they're implemented than split them up by language. BUT, this means that some of the things we're doing first in SAS are things you wouldn't normally do until you were already proficient in SAS. It also means that SAS is probably going to seem even more oddly organized when taught this way than it actually is (and it is oddly organized, in my opinion).</p><p>
We're going to start with SAS IML (programming concepts) and then talk about the DATA step. We'll use some procedures implicitly along the way, but hopefully that will make sense in context. Then, we'll work on the PROCs (SQL, Transpose, and graphing) - in greater detail. </p>
</details>

### Variable Types in SAS

In SAS, there are two basic variable types: numeric and character variables. SAS does not differentiate between integers and floats and doubles. Functionally, though, the same basic operations can be performed in SAS. As with R, SAS does attempt to implicitly convert variable types, and will notify you that the conversion has taken place in the log file.

#### Type Conversions {-}

SAS will attempt to implicitly convert variables when:

- a character value is assigned to a previously defined numeric variable
- a character value is used in arithmetic operations
- a character value is compared to a numeric value using a comparison operator (<, >, <=, >=)
- a character value is specified in a function that takes numeric arguments

::: note
Implicit conversion does not occur in WHERE statements. (This will make more sense later, but is here for reference)
:::

<details><summary>Manual type conversions</summary>
If you want to manually convert a value, use the INPUT statement. Unlike in R, the INPUT statement has the ability to read numbers which are formatted differently. For instance

```
data set1;
  x = 3;
  y = '3.1415';
  z = x * y;
  put z;
run;
```

```
data set2;
  x = 3;
  y = '3.1415';
  z = x * y;
  put z; /* print to log */

  x = '3.14159';
  /* x previously had a number in it, 
     so it will be converted to a number here */
  put x; /* print to log */

  zz = y <= 2;
  /* comparison operator: y will be converted */
  put zz; /* print to log */
  
run;
```


Notice that in SAS, `zz`, which is the result of the logical statement `y<=2`, is a numeric variable. The value 0 signifies that the comparison was false. SAS does not have a logical data type, it uses the numeric variable with 0:=FALSE, 1:=TRUE.

</details>


#### Try it out {- .tryitout}

1. Create variables `string1` and `string2` that each have text/character values. "Bob" and "Jane" might be good options. How does logical operation work with actual character values?

2. What happens if you use `string1` and add 3 to it? 

<details><summary>Solutions</summary>
```
data set1; 
  string1 = 'Bob';
  string2 = 'Jane';
  x = string1 < string2;
  put x=; /* This prints the result to the log */
run;

```

SAS will actually compare strings based on the first letter: Bob comes before Jane, so Bob < Jane. 


```
data set2;
  string1 = 'Bob';
  y = string1 + 3;
  put y=;
run;
```

The `.` in SAS is a missing value (like `NA` in R). So SAS is behaving basically like R does: it complains about the fact that you asked it to add a string to a number, and then it stores the result as a missing value. 

</details>

###  Basic List Syntax in SAS {-}
There are also [lists in SAS IML](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_langref_sect040.htm&docsetVersion=15.1&locale=en) which function similarly to lists in R. To create a named object in a list, precede the name with `#`. In SAS, the `$` operator can be used to get items from a list, using either name or numeric references. 

```

proc iml;
  grocery_list = [
    #dairy  = ["asiago", "fontina", "mozzarella", "blue cheese"], 
    #baking = ["flour", "yeast", "salt"], 
    #canned = ["pepperoni", "pizza sauce", "olives"], 
    #meat   = ["bacon", "sausage", "anchovies"], 
    #veggies= ["bell pepper", "onion", "scallions", "tomatoes", "basil"]
  ];

  /* print only works on matrices and vectors */
  /* so we'll cheat and load another library to print lists */
  
  package load ListUtil;
  
  /* run ListPrint(grocery_list); */ 
  /* This would print the thing, but it's long */
  
  ick = [grocery_list$"canned"$3, grocery_list$4$2, grocery_list$4$3];
  crust = grocery_list$"baking";
  call ListAddItem(crust, "water"); /* add an item to a list */
  essential_toppings = [grocery_list$"dairy"$3, grocery_list$"canned"$2];
  yummy_toppings = [grocery_list$"dairy"$1, grocery_list$"dairy"$2, 
    grocery_list$"dairy"$4, grocery_list$"meat"$1, grocery_list$5$3] ;
  /* The || is a concatenation operator, like c(). */
  /* It is inefficient for large data sets */
  
  run ListPrint(ick);
  run ListPrint(crust);
  run ListPrint(yummy_toppings);
quit;

```

### Data Sets (SAS) {-}

The SAS data set structure is similar to a R data frame.

![This is a schematic of a data set as taken from the SAS documentation](image/02_sas_dataset.png)
<!-- https://documentation.sas.com/api/docsets/basess/9.4/content/images/data-fit.png original source for the image -->

In SAS, missing values are indicated with `.`

SAS datasets also come with a description which is attached to the table. The descriptor portion of the data set records names of variables (and attributes), numbers of observations, and date/time stamps of creation and updates.

<details class="ex"><summary> Creating a SAS data set </summary>
In the next code chunk, we'll create a data set using a SAS Data step. We'll talk more about the anatomy of a SAS command later, but for now, notice that I'm specifying some metadata (the title), telling SAS what the variable names are (Drugs, Score), and then providing some data (indicated by the datalines statement).

```
data mathLSD;
title 'Average math test scores under the influence of LSD';
input Drugs	Score;
datalines;
1.17 78.93
2.97 58.20
3.26 67.47
4.69 37.47
5.83 45.65
6.00 32.92
6.41 29.97
;

/* Describe the dataset */
proc datasets;
  contents data = mathLSD;
run;

proc print data = mathLSD;
run;
```

The last two blocks are SAS procedures (PROCs). In the first block, I'm asking SAS to describe the contents of the mathMJ dataset. In the second block, I'm telling SAS to print the whole mathMJ dataset out. 
</details>


### Indexing in SAS

In SAS, the same basic code works (though matrix definition is a bit more manual). 

```
proc iml; /* Interactive Matrix Language */
  x = {1 2 3 4 5, 6 7 8 9 10, 11 12 13 14 15, 16 17 18 19 20};
  y = x[3:4, 1:2];
  print x; /* Here, print is used instead of put */
  print y;
quit; /* exit proc IML */
```



#### Try it out {- .tryitout}
(From project Euler)

If we list all the natural numbers below 10 that are multiples of 3 or 5,
   we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.


Hint: The modulo operator, `%%`, gives the integer remainder of one number
      divided by another. So `a %% b` gives the integer remainder when
      dividing `a` by `b`. Modular division is often used to find multiples
      of a number.

<details><summary>SAS solution</summary>
```
data tmp;
  do x = 1 to 999;
  output;
  end;
run;

proc summary data=tmp; /* Summarize data */
  where (mod(x, 3) = 0) | (mod(x, 5) = 0); 
  /* Keep only obs where x is divisible by 3 or 5 */
  
  var x; /* what variable we want the summary for */
  
  output out=sum_x sum=; /* output sum_x to a new dataset */
run;

proc print data = sum_x; /* print our sum_x dataset */
run;
```

Note on the SAS code: where statements allow you to select part of the data for further processing. There was a note earlier about the fact that type conversion doesn't happen in where clauses... this is one of those clauses. We'll get into where clauses in more detail later, in module 5. 
</details>

### If Statements

<details><summary>In SAS</summary>
In a data step:
```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;

/* Modify santa_list and make a new dataset, present_list */
data presents;
  set santa;
  if status = "naughty" then present = "coal";
  else present = "toy";
run; /* must end with run if no datalines option */

proc print data=presents;
run;
```

Note that `.`, or missing data is handled the same as 'nice'. That might not be what we wanted... this is the natural thing to do, right?

```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;

/* Modify santa_list and make a new dataset, present_list */
data presents;
  set santa;
  if status = "naughty" then present = "coal";
  else (if status = "nice" then present = "toy" else present = .);
run; /* must end with run if no datalines option */

proc print data=presents;
run;
```


SAS doesn't handle nested if statements very well - they can be ambiguous. Instead, [SAS documentation suggests using `do;` and `end;` to denote the start and end points of each if statement](https://documentation.sas.com/?docsetId=basess&docsetTarget=p0pcj5ajwyngron1wlsq0tet0hce.htm&docsetVersion=9.4&locale=en) (like the `{}` in R). 

```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;
  
data presents;
  set santa;
  if status = "naughty" then 
    do;
      present = "coal";
    end;
  else if status = "nice" then
    do;
      present = "toy";
    end;
  else 
    do;
      present = .;
    end;
run;
          
proc print data=presents;
run;
```


Interestingly, if you set a character variable to be missing, SAS converts it to '.'. So, if we actually want to have the value be missing, we can set it to an empty string.

```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;
data presents; 
  set santa;
  if status = "naughty" then 
    do;
      present = "coal";
    end;
  else if status = "nice" then
    do;
      present = "toy";
    end;
  else 
    do;
      present = '';
    end;
run;
          
proc print data=presents;
run;
```

Now things work the way we expected them to work.
</details>

- Switch statments: [SAS case statement documentation](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=n0a85s0ijz65irn1h3jtariooea5.htm&docsetVersion=9.4&locale=en)


#### Try it out {- .tryitout}
The `sample()` function selects a random sample of entries from a vector. Suppose we sample a random vector $x$ with 10 entries. Write one or more if statements to fulfill the following conditions

- if $x$ is divisible by 2, $y$ should be positive; otherwise, it should be negative.
- if $x$ is divisible by 3, $y$ should have a magnitude of 2; otherwise, it should have a magnitude of 1.

It may be helpful to define separate variables `y_mag` and `y_sign` and then multiply them afterwards. Once you have found the value of $y$ compute $\text{sum}(x * y)$.

You may use the following code skeletons to set the problem up.

````
proc iml;
  call randseed(342502837);
  x = sample(1:50, 20)`;
  create sampledata from x [colname = "x"];
  append from x;
  close;
quit;

data xy;
  set sampledata;


  /* Conditional statements go here */
  
  
  /* Leave this so that the code below works */
  res = x * y;
run;

proc summary data=xy; /* Summarize data */
  var res; /* what variable we want the summary for */
  
  output out=tmpsum sum=; /* output tmpsum to a new dataset */
run;

proc print data = xy; /* print our original dataset to check result */
  var x y res;
  sum res;
run;

proc print data = tmpsum; /* print our tmpsum dataset */
run;
````

<details><summary>SAS Solution</summary>

```
proc iml;
  call randseed(342502837);
  x = sample(1:50, 20)`; 
  create sampledata from x [colname = "x"];
  append from x;
  close;
quit;

data xy;
  set sampledata;

  y_sign = 0 * x;
  y_mag = 0 * x;

  /* Conditional statements go here */
  if MOD(x, 2) = 0 then y_sign = 1; 
    else y_sign = -1;
  if MOD(x, 3) = 0 then y_mag = 2; 
    else y_mag = 1;

  y = y_sign * y_mag;
  res = x * y;
run;

proc summary data=xy; /* Summarize data */
  var res; /* what variable we want the summary for */
  
  output out=tmpsum sum=; /* output tmpsum to a new dataset */
run;


proc print data = xy; /* print our original dataset to check result */
  var x y res;
  sum res;
run;

proc print data = tmpsum; /* print our tmpsum dataset */
run;
```

See [this](https://www.oreilly.com/library/view/sas-certification-prep/9781607649243/p12osnn9d1s4hgn12yf8ffocxhw7.htm) to understand how the print statement works and how to add column summary values. 
</details>


### For Loops


<details class="ex"><summary>"For loops" in SAS IML (using `do`)</summary>
```
/* SAS IML example loop */
proc iml;
  do i = 1 to 10;
    print i; 
  end; /* This ends the loop definition */
quit;
```
</details>

<details class="ex"><summary>"For loops" in a SAS DATA step</summary>
```
data A;
  do i = 1 to 10; 
    put i=;
  end; /* This ends the loop definition */
run;
```

</details>

<details><summary>Other sequence structures in SAS for loops</summary>
We can iterate by non-integer values:
```
data A;
y = 0;
do i = 5 to 0 by -0.5;
    put i=; 
  end;
run;
```

We can even add additional conditions:

```
data A;
y = 0;
do i = 5 to 0 by -0.5 while (i**2 > 1);
    put i=;
  end; 
run;
```
</details>

##### Try it out (in SAS) {- .tryitout}

Write a for loop which will output the first 30 [fibbonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number). You can use the following code as a starting point:

```
/* SAS IML example loop */
proc iml;
  current = 1; 
  prev = 0;

quit;

````

<details><summary>Solution</summary>

```
/* SAS IML example loop */
proc iml;
  current = 1;
  prev = 0;

  do i = 1 to 30;
    new = current + prev;
    prev = current;
    current = new;
    print current; 
  end; /* This ends the loop definition */
quit;

```
</details>


### Condition-controlled loops (WHILE, DO WHILE)

##### Example: The Basel Problem {- .ex}
Let's solve the [Basel problem](https://en.wikipedia.org/wiki/Basel_problem) in SAS using WHILE loops - we'll repeat the calculation until the value changes by less than 0.000001. The Basel problem is the problem of calculating the precise infinite summation $$\sum_{n=1}^\infty \frac{1}{n^2}$$

We'll stick to calculating it computationally.

<details><summary>In SAS</summary>
```
proc iml;
  i = 1;
  basel = 0;
  prev = -1;
  do while((basel - prev) > 1e-6);
    prev = basel;
    basel = basel + 1/i**2; /* ** is the exponent operator */
    i = i + 1;
    
    if i > 1e6 then
      do;
        leave;
    end;
      
    if MOD(i, 200) = 0 then
      do;
        print i, prev, basel;
    end; 
  end;
  
  print i, basel;
quit;
  
```

</details>


##### Try it out {- .tryitout}

Write a while loop in in SAS to calculate $\displaystyle \lim_{x \rightarrow 4} \frac{2 - \sqrt{x}}{4-x}$ by starting at 3 and halving the distance to 4 with each iteration. Exit the loop when you are within 1e-6 of the value computed on the previous iteration, or when you are within 1e-6 from 4. Which exit condition did you hit first? How do you know?

<details><summary>Solution</summary>

```
proc iml;
  x = 3;
  dist = 4 - x;
  fx = 0;
  prev_fx = 1;
  dfx = abs(fx - prev_fx);
  do while(dfx > 1e-6 & dist > 1e-6);
    prev_fx = fx;
    dist = dist/2; 
    x = 4 - dist; 
    fx = (2 - sqrt(x))/(4 - x);
    dfx = abs(fx - prev_fx);
  end;
  
  print x, dist, fx, dfx;
quit;

```
</details>


## References {#refs-sas}


- [SAS quick start guide](https://towardsdatascience.com/getting-started-with-sas-beginner-354a94a48f08)

- [SAS Cheatsheet (from another class like this)](https://sites.ualberta.ca/~ahamann/teaching/renr480/SAS-Cheat.pdf)
- [SAS Cheatsheet (by SAS)](https://support.sas.com/content/dam/SAS/support/en/books/data/base-syntax-ref.pdf)
- [SAS Programming for R Users (free book)](https://support.sas.com/content/dam/SAS/support/en/books/free-books/sas-programming-for-r-users.pdf)


- [SAS Matrix reference](http://www.math.wpi.edu/saspdf/iml/chap4.pdf)
- [SAS Data set documentation](https://documentation.sas.com/?docsetId=basess&docsetTarget=p1f5xhmkdfhyjcn1n6k9wdcacba0.htm&docsetVersion=9.4&locale=en)
- [Creating SAS Data Sets from IML](https://support.sas.com/content/dam/SAS/support/en/books/simulating-data-with-sas/65378_Appendix_A_A_SAS_IML_Primer.pdf) (also [this](https://education.illinois.edu/docs/default-source/carolyn-anderson/edpsy584/SAS_iml.pdf) friendly guide and [this](https://blogs.sas.com/content/iml/2019/07/17/write-numeric-character-matrices-data-set.html) blog post)
- [SAS Data Step options](https://libguides.library.kent.edu/SAS/DataStep)
- [SAS Mathematical Operators](https://www.tutorialspoint.com/sas/sas_operators.htm)
- [Lists and Data Structures in SAS](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_lists_gettingstarted03.htm&docsetVersion=14.3&locale=en)
- [Loops in SAS](https://blogs.sas.com/content/iml/2011/09/07/loops-in-sas.html) and [SAS documentation for DO WHILE](https://support.sas.com/documentation/cdl/en/lestmtsref/63323/HTML/default/viewer.htm#p1awxgleif5wlen1pja0nrn6yi6i.htm) loops
- [Random number generation in SAS](https://www.sas.com/content/dam/SAS/support/en/sas-global-forum-proceedings/2018/1810-2018.pdf)
