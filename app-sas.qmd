# SAS

## Setting up SAS {#setting-up-sas}

In this class, you have several options for how to use SAS:

1. Install SAS on your machine
    - <i class="fab fa-windows"></i> See Steve Westerholt, pay a small fee, and he will install SAS on your machine.
    - <i class="fab fa-apple"></i> Steve Westerholt will help you acquire Parallels desktop (to emulate Windows) and SAS. You'll pay license fees for both products. 
    - <i class="fab fa-linux"></i> Talk with me and I'll help you interface with Steve to get SAS for Linux installed on your system. Steve doesn't support Linux installs, but I can help you get SAS set up if you're using a common distribution like Ubuntu or RedHat/Fedora.
    
2. Use SAS University Edition/SAS OnDemand for Academics. Get more information [here](https://www.sas.com/en_us/software/on-demand-for-academics/references/getting-started-with-sas-ondemand-for-academics-studio.html). 
    - Pros - this is free
    - Cons - limited storage, may cause issues with paths and file upload/download (so it may be hard to ensure your homework assignments are reproducible).

3. ~~Use the Guacamole environment I've set up for the class via HCC. More information will be provided outside the textbook for this option.~~ (This is not an option in Fall 2022)
    - Pros - free, allows you access to SAS and Rstudio on the same machine (so you can use SASmarkdown seamlessly for homework). You can also use this to test the reproducibility of your assignment.
    - Cons - This interface is only available for Stat850 - it will not be available after the class concludes. 

## Finding Your Way around in SAS {#looking-around-sas}

SAS is another extensively used statistical programming language. It is primarily used for mixed models and in the biostatistics community (for e.g. drug trials). 

### Note {- .note}
SAS looks different on different machines. On Linux, SAS looks like you took a time machine back to the early 1990s. Screenshots from SAS will likely look *very* different on your machine than on mine. I will try to integrate screenshots from other OS's where it matters.^[As I write this in late July 2020, I do not yet have access to a Windows or Mac machine. Sigh. XXX TODO: Get Windows/Mac screenshots XXX. 

I still don't have access to a Windows or Mac machine, and it's now April 2021. Sigh.]

### SAS Windows/Panes

![The SAS toolbox has options to create new files, submit code, and more (but I mostly use keyboard shortcuts in the individual windows). This is probably one of the biggest things that's different on Linux...](images/sas/sas_toolbox.png)

![The SAS Log gives you lots of detailed information about how your code ran -- look here for errors and warnings.](images/sas/sas_log_window.png)

![The SAS program editor is where you'll be writing your code. If you want, you can write code in a more advanced text editor and copy/paste it into the log when you're ready to run it.](images/sas/sas_program_editor.png)

There are two different places your output may end up: if you're using the old output system, you'll get text output in the output pane.

![The old output system output pane.](images/sas/sas_output_old.png)

![The new output system uses HTML and will output to your browser.](images/sas/sas_modern_output.png)

![You can navigate through your results using the results window](images/sas/sas_results_window.png)

![The explorer window lets you access documentation, data, and more](images/sas/sas_explorer_1.png)

If you click on libraries, you get to this list:

![This area of the SAS explorer shows all of the libraries you have access to.](images/sas/sas_explorer_2.png)

![Clicking on any one library will show you a list of datasets in that library](images/sas/sas_explorer_3.png)


You can then click on a dataset and you will get a spreadsheet-like view. 


### SAS Modules

SAS is a very large set of programs. In this class, we're primarily working with base SAS (the underlying language and interpreter), SAS/STAT (the statistical procedures, like PROC GLM), and SAS/IML, which is SAS's version of a scripting language. IML allows you to implement your own procedures "from scratch". 

Initially, we'll primarily focus on SAS/IML, because it contains information parallel to what you need to know to start programming in R. It's easier to teach general programming concepts at the same time, even if your typical SAS course would probably introduce you to the DATA step and simple PROC statements first. 

## SAS computer basics

In SAS, you can set your working directory in the Program Editor, Log, or Explorer windows by clicking on Tools > Options > Change Directory, navigating to your preferred directory, and clicking ok.

![](images/sas/sas-screenshot-setwd.gif)

In SAS, you'll want to store your .sas code file in the RStudio project folder as well, and I believe that should be sufficient to set your working directory for any SAS code you may write as part of e.g. a homework assignment.

## Introduction to SAS Programming

A few notes on programming concepts and R vs. SAS

- <details><summary>Historical view</summary>
Both [R](https://bookdown.org/rdpeng/rprogdatascience/history-and-overview-of-r.html) and [SAS](https://en.wikipedia.org/wiki/SAS_(software)#History) have long histories. SAS in particular dates back to the 1960s, and has syntax which is unique compared to more modern languages such as C, python, Java, and R. R's predecessor, S, dates back to 1976 and was designed for internal use at Bell Labs. The histories of both languages are useful in understanding why they are optimized for their respective tasks, but are not essential for this course (so read them at your leisure).</details>

- <details><summary>Difference between R and SAS</summary><p>
The biggest difference between R and SAS (at a fundamental level) is that R is a [**functional** language](http://adv-r.had.co.nz/Functional-programming.html) - it consists mainly of functions, which can (and do) manipulate objects, including other functions. SAS, on the other hand, is a procedural language - most SAS programs follow a specific series of steps, known as "proc"s. Procs are essentially functions (or compositions of multiple functions), but in SAS, it is simpler to think of an analysis as a series of procedural steps; in R, there are steps, but they may be implemented in a more flexible way (depending on the analysis). </p><p>
Another interesting feature of SAS is that it's really several languages - some commands work in PROC IML (interactive matrix language) but not in a DATA step. When looking for help in SAS, make sure you're referencing the correct part of the language documentation.</p>
</details>

- <details><summary>I'm teaching SAS very differently</summary>
<p>I'm definitely teaching SAS differently than it is normally taught. This is so that we don't have to do half the semester in SAS and half in R - I'd rather teach the concepts and show you how they're implemented than split them up by language. BUT, this means that some of the things we're doing first in SAS are things you wouldn't normally do until you were already proficient in SAS. It also means that SAS is probably going to seem even more oddly organized when taught this way than it actually is (and it is oddly organized, in my opinion).</p><p>
We're going to start with SAS IML (programming concepts) and then talk about the DATA step. We'll use some procedures implicitly along the way, but hopefully that will make sense in context. Then, we'll work on the PROCs (SQL, Transpose, and graphing) - in greater detail. </p>
</details>

### Variable Types in SAS

In SAS, there are two basic variable types: numeric and character variables. SAS does not differentiate between integers and floats and doubles. Functionally, though, the same basic operations can be performed in SAS. As with R, SAS does attempt to implicitly convert variable types, and will notify you that the conversion has taken place in the log file.

#### Type Conversions {-}

SAS will attempt to implicitly convert variables when:

- a character value is assigned to a previously defined numeric variable
- a character value is used in arithmetic operations
- a character value is compared to a numeric value using a comparison operator (<, >, <=, >=)
- a character value is specified in a function that takes numeric arguments

::: note
Implicit conversion does not occur in WHERE statements. (This will make more sense later, but is here for reference)
:::

<details><summary>Manual type conversions</summary>
If you want to manually convert a value, use the INPUT statement. Unlike in R, the INPUT statement has the ability to read numbers which are formatted differently. For instance

```
data set1;
  x = 3;
  y = '3.1415';
  z = x * y;
  put z;
run;
```

```
data set2;
  x = 3;
  y = '3.1415';
  z = x * y;
  put z; /* print to log */

  x = '3.14159';
  /* x previously had a number in it, 
     so it will be converted to a number here */
  put x; /* print to log */

  zz = y <= 2;
  /* comparison operator: y will be converted */
  put zz; /* print to log */
  
run;
```


Notice that in SAS, `zz`, which is the result of the logical statement `y<=2`, is a numeric variable. The value 0 signifies that the comparison was false. SAS does not have a logical data type, it uses the numeric variable with 0:=FALSE, 1:=TRUE.

</details>


#### Try it out {- .tryitout}

1. Create variables `string1` and `string2` that each have text/character values. "Bob" and "Jane" might be good options. How does logical operation work with actual character values?

2. What happens if you use `string1` and add 3 to it? 

<details><summary>Solutions</summary>
```
data set1; 
  string1 = 'Bob';
  string2 = 'Jane';
  x = string1 < string2;
  put x=; /* This prints the result to the log */
run;

```

SAS will actually compare strings based on the first letter: Bob comes before Jane, so Bob < Jane. 


```
data set2;
  string1 = 'Bob';
  y = string1 + 3;
  put y=;
run;
```

The `.` in SAS is a missing value (like `NA` in R). So SAS is behaving basically like R does: it complains about the fact that you asked it to add a string to a number, and then it stores the result as a missing value. 

</details>

###  Basic List Syntax in SAS {-}
There are also [lists in SAS IML](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_langref_sect040.htm&docsetVersion=15.1&locale=en) which function similarly to lists in R. To create a named object in a list, precede the name with `#`. In SAS, the `$` operator can be used to get items from a list, using either name or numeric references. 

```

proc iml;
  grocery_list = [
    #dairy  = ["asiago", "fontina", "mozzarella", "blue cheese"], 
    #baking = ["flour", "yeast", "salt"], 
    #canned = ["pepperoni", "pizza sauce", "olives"], 
    #meat   = ["bacon", "sausage", "anchovies"], 
    #veggies= ["bell pepper", "onion", "scallions", "tomatoes", "basil"]
  ];

  /* print only works on matrices and vectors */
  /* so we'll cheat and load another library to print lists */
  
  package load ListUtil;
  
  /* run ListPrint(grocery_list); */ 
  /* This would print the thing, but it's long */
  
  ick = [grocery_list$"canned"$3, grocery_list$4$2, grocery_list$4$3];
  crust = grocery_list$"baking";
  call ListAddItem(crust, "water"); /* add an item to a list */
  essential_toppings = [grocery_list$"dairy"$3, grocery_list$"canned"$2];
  yummy_toppings = [grocery_list$"dairy"$1, grocery_list$"dairy"$2, 
    grocery_list$"dairy"$4, grocery_list$"meat"$1, grocery_list$5$3] ;
  /* The || is a concatenation operator, like c(). */
  /* It is inefficient for large data sets */
  
  run ListPrint(ick);
  run ListPrint(crust);
  run ListPrint(yummy_toppings);
quit;

```

### Data Sets (SAS) {-}

The SAS data set structure is similar to a R data frame.

![This is a schematic of a data set as taken from the SAS documentation](images/sas/02_sas_dataset.png)
<!-- https://documentation.sas.com/api/docsets/basess/9.4/content/images/data-fit.png original source for the image -->

In SAS, missing values are indicated with `.`

SAS datasets also come with a description which is attached to the table. The descriptor portion of the data set records names of variables (and attributes), numbers of observations, and date/time stamps of creation and updates.

<details class="ex"><summary> Creating a SAS data set </summary>
In the next code chunk, we'll create a data set using a SAS Data step. We'll talk more about the anatomy of a SAS command later, but for now, notice that I'm specifying some metadata (the title), telling SAS what the variable names are (Drugs, Score), and then providing some data (indicated by the datalines statement).

```
data mathLSD;
title 'Average math test scores under the influence of LSD';
input Drugs	Score;
datalines;
1.17 78.93
2.97 58.20
3.26 67.47
4.69 37.47
5.83 45.65
6.00 32.92
6.41 29.97
;

/* Describe the dataset */
proc datasets;
  contents data = mathLSD;
run;

proc print data = mathLSD;
run;
```

The last two blocks are SAS procedures (PROCs). In the first block, I'm asking SAS to describe the contents of the mathMJ dataset. In the second block, I'm telling SAS to print the whole mathMJ dataset out. 
</details>


### Indexing in SAS

In SAS, the same basic code works (though matrix definition is a bit more manual). 

```
proc iml; /* Interactive Matrix Language */
  x = {1 2 3 4 5, 6 7 8 9 10, 11 12 13 14 15, 16 17 18 19 20};
  y = x[3:4, 1:2];
  print x; /* Here, print is used instead of put */
  print y;
quit; /* exit proc IML */
```



#### Try it out {- .tryitout}
(From project Euler)

If we list all the natural numbers below 10 that are multiples of 3 or 5,
   we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.


Hint: The modulo operator, `%%`, gives the integer remainder of one number
      divided by another. So `a %% b` gives the integer remainder when
      dividing `a` by `b`. Modular division is often used to find multiples
      of a number.

<details><summary>SAS solution</summary>
```
data tmp;
  do x = 1 to 999;
  output;
  end;
run;

proc summary data=tmp; /* Summarize data */
  where (mod(x, 3) = 0) | (mod(x, 5) = 0); 
  /* Keep only obs where x is divisible by 3 or 5 */
  
  var x; /* what variable we want the summary for */
  
  output out=sum_x sum=; /* output sum_x to a new dataset */
run;

proc print data = sum_x; /* print our sum_x dataset */
run;
```

Note on the SAS code: where statements allow you to select part of the data for further processing. There was a note earlier about the fact that type conversion doesn't happen in where clauses... this is one of those clauses. We'll get into where clauses in more detail later, in module 5. 
</details>

### If Statements

<details><summary>In SAS</summary>
In a data step:
```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;

/* Modify santa_list and make a new dataset, present_list */
data presents;
  set santa;
  if status = "naughty" then present = "coal";
  else present = "toy";
run; /* must end with run if no datalines option */

proc print data=presents;
run;
```

Note that `.`, or missing data is handled the same as 'nice'. That might not be what we wanted... this is the natural thing to do, right?

```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;

/* Modify santa_list and make a new dataset, present_list */
data presents;
  set santa;
  if status = "naughty" then present = "coal";
  else (if status = "nice" then present = "toy" else present = .);
run; /* must end with run if no datalines option */

proc print data=presents;
run;
```


SAS doesn't handle nested if statements very well - they can be ambiguous. Instead, [SAS documentation suggests using `do;` and `end;` to denote the start and end points of each if statement](https://documentation.sas.com/?docsetId=basess&docsetTarget=p0pcj5ajwyngron1wlsq0tet0hce.htm&docsetVersion=9.4&locale=en) (like the `{}` in R). 

```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;
  
data presents;
  set santa;
  if status = "naughty" then 
    do;
      present = "coal";
    end;
  else if status = "nice" then
    do;
      present = "toy";
    end;
  else 
    do;
      present = .;
    end;
run;
          
proc print data=presents;
run;
```


Interestingly, if you set a character variable to be missing, SAS converts it to '.'. So, if we actually want to have the value be missing, we can set it to an empty string.

```
data santa;
  input name $ status $;
  datalines;
  Edison nice
  Alex naughty
  Susan .
  Ryan neutral
;
data presents; 
  set santa;
  if status = "naughty" then 
    do;
      present = "coal";
    end;
  else if status = "nice" then
    do;
      present = "toy";
    end;
  else 
    do;
      present = '';
    end;
run;
          
proc print data=presents;
run;
```

Now things work the way we expected them to work.
</details>

- Switch statments: [SAS case statement documentation](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=n0a85s0ijz65irn1h3jtariooea5.htm&docsetVersion=9.4&locale=en)


#### Try it out {- .tryitout}
The `sample()` function selects a random sample of entries from a vector. Suppose we sample a random vector $x$ with 10 entries. Write one or more if statements to fulfill the following conditions

- if $x$ is divisible by 2, $y$ should be positive; otherwise, it should be negative.
- if $x$ is divisible by 3, $y$ should have a magnitude of 2; otherwise, it should have a magnitude of 1.

It may be helpful to define separate variables `y_mag` and `y_sign` and then multiply them afterwards. Once you have found the value of $y$ compute $\text{sum}(x * y)$.

You may use the following code skeletons to set the problem up.

````
proc iml;
  call randseed(342502837);
  x = sample(1:50, 20)`;
  create sampledata from x [colname = "x"];
  append from x;
  close;
quit;

data xy;
  set sampledata;


  /* Conditional statements go here */
  
  
  /* Leave this so that the code below works */
  res = x * y;
run;

proc summary data=xy; /* Summarize data */
  var res; /* what variable we want the summary for */
  
  output out=tmpsum sum=; /* output tmpsum to a new dataset */
run;

proc print data = xy; /* print our original dataset to check result */
  var x y res;
  sum res;
run;

proc print data = tmpsum; /* print our tmpsum dataset */
run;
````

<details><summary>SAS Solution</summary>

```
proc iml;
  call randseed(342502837);
  x = sample(1:50, 20)`; 
  create sampledata from x [colname = "x"];
  append from x;
  close;
quit;

data xy;
  set sampledata;

  y_sign = 0 * x;
  y_mag = 0 * x;

  /* Conditional statements go here */
  if MOD(x, 2) = 0 then y_sign = 1; 
    else y_sign = -1;
  if MOD(x, 3) = 0 then y_mag = 2; 
    else y_mag = 1;

  y = y_sign * y_mag;
  res = x * y;
run;

proc summary data=xy; /* Summarize data */
  var res; /* what variable we want the summary for */
  
  output out=tmpsum sum=; /* output tmpsum to a new dataset */
run;


proc print data = xy; /* print our original dataset to check result */
  var x y res;
  sum res;
run;

proc print data = tmpsum; /* print our tmpsum dataset */
run;
```

See [this](https://www.oreilly.com/library/view/sas-certification-prep/9781607649243/p12osnn9d1s4hgn12yf8ffocxhw7.htm) to understand how the print statement works and how to add column summary values. 
</details>


### For Loops


<details class="ex"><summary>"For loops" in SAS IML (using `do`)</summary>
```
/* SAS IML example loop */
proc iml;
  do i = 1 to 10;
    print i; 
  end; /* This ends the loop definition */
quit;
```
</details>

<details class="ex"><summary>"For loops" in a SAS DATA step</summary>
```
data A;
  do i = 1 to 10; 
    put i=;
  end; /* This ends the loop definition */
run;
```

</details>

<details><summary>Other sequence structures in SAS for loops</summary>
We can iterate by non-integer values:
```
data A;
y = 0;
do i = 5 to 0 by -0.5;
    put i=; 
  end;
run;
```

We can even add additional conditions:

```
data A;
y = 0;
do i = 5 to 0 by -0.5 while (i**2 > 1);
    put i=;
  end; 
run;
```
</details>

##### Try it out (in SAS) {- .tryitout}

Write a for loop which will output the first 30 [fibbonacci numbers](https://en.wikipedia.org/wiki/Fibonacci_number). You can use the following code as a starting point:

```
/* SAS IML example loop */
proc iml;
  current = 1; 
  prev = 0;

quit;

````

<details><summary>Solution</summary>

```
/* SAS IML example loop */
proc iml;
  current = 1;
  prev = 0;

  do i = 1 to 30;
    new = current + prev;
    prev = current;
    current = new;
    print current; 
  end; /* This ends the loop definition */
quit;

```
</details>


### Condition-controlled loops (WHILE, DO WHILE)

##### Example: The Basel Problem {- .ex}
Let's solve the [Basel problem](https://en.wikipedia.org/wiki/Basel_problem) in SAS using WHILE loops - we'll repeat the calculation until the value changes by less than 0.000001. The Basel problem is the problem of calculating the precise infinite summation $$\sum_{n=1}^\infty \frac{1}{n^2}$$

We'll stick to calculating it computationally.

<details><summary>In SAS</summary>
```
proc iml;
  i = 1;
  basel = 0;
  prev = -1;
  do while((basel - prev) > 1e-6);
    prev = basel;
    basel = basel + 1/i**2; /* ** is the exponent operator */
    i = i + 1;
    
    if i > 1e6 then
      do;
        leave;
    end;
      
    if MOD(i, 200) = 0 then
      do;
        print i, prev, basel;
    end; 
  end;
  
  print i, basel;
quit;
  
```

</details>


##### Try it out {- .tryitout}

Write a while loop in in SAS to calculate $\displaystyle \lim_{x \rightarrow 4} \frac{2 - \sqrt{x}}{4-x}$ by starting at 3 and halving the distance to 4 with each iteration. Exit the loop when you are within 1e-6 of the value computed on the previous iteration, or when you are within 1e-6 from 4. Which exit condition did you hit first? How do you know?

<details><summary>Solution</summary>

```
proc iml;
  x = 3;
  dist = 4 - x;
  fx = 0;
  prev_fx = 1;
  dfx = abs(fx - prev_fx);
  do while(dfx > 1e-6 & dist > 1e-6);
    prev_fx = fx;
    dist = dist/2; 
    x = 4 - dist; 
    fx = (2 - sqrt(x))/(4 - x);
    dfx = abs(fx - prev_fx);
  end;
  
  print x, dist, fx, dfx;
quit;

```
</details>

## EDA in SAS

1. [Proc Freq](https://go.documentation.sas.com/?docsetId=procstat&docsetTarget=procstat_freq_toc.htm&docsetVersion=9.4&locale=en) generates frequency tables for variables or interactions of variables.    
    
<details class="ex"><summary>PROC FREQ demo</summary>
This can help you to see whether there is missing information. Using those frequency tables, you can create frequency plots and set up chi squared tests.

```
libname classdat "sas/";

ODS GRAPHICS ON;
PROC FREQ DATA=classdat.poke ORDER=FORMATTED;
  TABLES generation / CHISQ PLOTS=freqplot(type=dotplot);
RUN;
PROC FREQ DATA=classdat.poke ORDER=FREQ;
  TABLES type_1 status / MAXLEVELS=10 PLOTS=freqplot(type=dotplot scale=percent);
RUN;
ODS GRAPHICS OFF;
```

</details>

2. Proc Means can be used to get more useful summary statistics for numeric variables.     
    
<details class="ex"><summary> PROC MEANS demo</summary>Note that the Class statement identifies a categorical variable; the summary statistics are computed for each level of this variable. 

```
ODS HTML style= HTMLBlue; 
libname classdat "sas/";

PROC MEANS DATA = classdat.poke;
run;

proc means data = classdat.poke;
class status;
run;
```
</details>

3. For even higher levels of detail, [Proc Univariate](https://go.documentation.sas.com/?docsetId=procstat&docsetTarget=procstat_univariate_toc.htm&docsetVersion=9.4&locale=en) will provide variability, tests for location, quantiles, skewness, and will identify the extreme observations for you.     
    
<details class="ex"><summary>PROC UNIVARIATE demo</summary>
You can also get histograms for variables, even specifying distributions you'd like to be fit to the data (if that's something you want). 
```
ODS HTML style= HTMLBlue; 
libname classdat "sas/";

ODS GRAPHICS ON;
PROC UNIVARIATE DATA = classdat.poke;
VAR attack defense sp_attack sp_defense speed;
HISTOGRAM attack defense sp_attack sp_defense speed;
RUN;
ODS GRAPHICS OFF;
```
</details>

4. Proc Corr allows you to examine the relationship between two quantitative variables.     
    
<details class="ex"><summary>PROC CORR demo</summary>

```
libname classdat "sas/";

ODS GRAPHICS ON;
PROC CORR DATA = classdat.poke PLOTS( MAXPOINTS=200000)=MATRIX(HISTOGRAM);
VAR attack defense sp_attack sp_defense speed ;
RUN;
ODS GRAPHICS OFF;
```

The plot here is called a scatterplot matrix. It contains histograms on the diagonal, and pairwise scatterplots on off-diagonals. It can be useful for spotting strong correlations among multiple variables which may affect the way you build a model. 
</details>

### Try it out {- .tryitout #police-violence-eda-sas}

One of the datasets we read in above records incidents of police violence around the country. Explore the variables present in [this dataset](data/police_violence.xlsx) (see code in the spreadsheets section to read it in). Note that some variables may be too messy to handle with the things that you have seen thus far - that is ok. As you find irregularities, document them - these are things you may need to clean up in the dataset before you conduct a formal analysis.

It is useful to memorize the SAS PROC options you use most frequently, but it's also a good idea to reference the SAS documentation - it provides a list of all viable options for each procedure, and generally has decent examples to show how those options are used.

<details><summary>Solution</summary>
```
ODS HTML style= HTMLBlue; 

libname classdat "sas/";

ODS GRAPHICS ON;
PROC CONTENTS DATA = classdat.police; /* see what's in the dataset */
RUN;

PROC FREQ DATA = classdat.police ORDER=FREQ; /* Examine Freq of common vars */
TABLES Victim_s_gender Victim_s_race State Cause_of_death 
        Unarmed Geography__via_Trulia_methodolog / MAXLEVELS = 10;
RUN;

PROC FREQ DATA = classdat.police ORDER=FREQ; /* Combinations of vars */
TABLES Unarmed * Criminal_Charges_ / NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;
RUN;

PROC MEANS DATA = classdat.police; /* Numeric variable exploration */
VAR num_age; /* Only numeric variable in this set */
RUN;

PROC UNIVARIATE DATA = classdat.police; /* Investigating age/date info */
HISTOGRAM num_age date;
RUN;
ODS GRAPHICS OFF;
```

Oddities to note:

- Gender - Unknown should be recoded as missing (' ')
- Victim\_s\_race - Unknown race and Unknown Race should be recoded as missing
- State - might need to check to make sure all states are valid (but top 10 are, at least)
- Cause of death - sometimes, there are multiple causes. Also, varying capitalizations...
- Geography - #N/A should be recoded as missing 
- Criminal_Charges_ - What does No/NO mean? (would need to look up in the codebook)
- Age - the maximum age recorded is 107, which bears some investigation... other extreme observations between 89 and 95 are also fairly interesting and could be investigated further. There are also several infants/young children included, which is horribly sad, but believable.
- Date - PROC UNIVARIATE doesn't display date results with a meaningful format, even though format is specified.


Conclusions (ok, probably obvious before this analysis):

- It's much more likely for charges to be filed if the suspect was unarmed (but still very rare)
- Data is relatively evenly distributed between 2013 and 2019.
- It's fairly rare for police to kill female or transgender individuals - around 5% of all victims
- California, Texas, and Florida, while populous, seem to have a disproportionate number of killings, especially compared to e.g. NY, which is also a high population state. To really make the state numbers meaningful, though, we'd need to know population counts. There's also an issue of accurate comparisons - some states may not report police killings with the same standards as other states. 
</details>

## Data Cleaning in SAS



In SAS, as in SQL, the `filter()` operation is accomplished using a `where` clause. Multiple clauses can be connected using `and`, and compound statements can be grouped with parentheses. 

### Demonstration of `where` in SAS
Rather than output the whole data table (which would take up a lot of space), I've linked the log file from each chunk below the chunk. If you are running this code in SAS, you should NOT copy the `proc printto` line. 

```
libname classdat "sas/";

/* SAS limits dataset names to 8 characters, which is super annoying. */
/* Sorry the names aren't descriptive... */

DATA tmp1; /* this is the out dataset */
/* By not having a library attached, SAS places this in WORK */
/* It's a temporary dataset */
  set classdat.starwars;
  where (species = 'Human');
  run;
```
See the log file [here](other/05-filter-1.log)

```
libname classdat "sas/";

DATA tmp2; 
  set classdat.starwars;
  where (species = 'Human') and (homeworld = 'Tatooine');
  run;
```
See the log file [here](other/05-filter-2.log)


At this point, you've seen the traditional SAS Data step options, but there is another SAS PROC that may be more useful (and more similar to `dplyr`). `dplyr` was developed to provide SQL-like syntax while enabling the use of more advanced computations than are supported in SQL. While SAS doesn't have anything quite the same as `dplyr`, it does have [PROC SQL](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=p07v6ho0hymhfvn1jboqfe38jnox.htm&docsetVersion=9.4&locale=en).

#### Try it out

Using the pokemon data, can you create a new data frame that has only water type pokemon? Can you write a filter statement that looks for any pokemon which has water type for either type1 or type2?

```
libname classdat "sas/";

DATA water1;
SET classdat.poke;
WHERE type_1 = "Water";
RUN;

DATA water2;
SET classdat.poke;
WHERE (type_1 = "Water" OR type_2 = "Water");
RUN;
```

In the interests of only showing the parts of the log that are useful, I've just pasted them into this chunk. Not reproducible, but faster to read.

````
NOTE: There were 134 observations read from the data set CLASSDAT.POKE.
      WHERE type_1='Water';
NOTE: The data set WORK.WATER1 has 134 observations and 49 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds

NOTE: There were 153 observations read from the data set CLASSDAT.POKE.
      WHERE (type_1='Water') or (type_2='Water');
NOTE: The data set WORK.WATER2 has 153 observations and 49 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
````

#### SAS PROC SQL
In SQL, as in the SAS DATA step, `filter()` operations are performed using the keyword `WHERE`.

To limit the output I'm going to cheat a bit and use SELECT statements before I officially teach them to you - this is mostly so you don't get a table with all 49 variables in it. Similarly, I'm limiting the dataset to the first 5 observations that meet the condition so that we don't have to see *all* the water type pokemon.
```
libname classdat "sas/";

PROC SQL;
SELECT pokedex_number, name, type_1, type_number FROM classdat.poke (obs=5)
WHERE type_1 = "Water";
```

If we want to store the output of our query to a new table, we can do that by starting our query with CREATE TABLE \<table name\> AS - this creates a table with our results.

```
libname classdat "sas/";

PROC SQL;
CREATE TABLE aquapoke AS
SELECT pokedex_number, name, type_1, type_2, type_number FROM classdat.poke
WHERE (type_1 = "Water" OR type_2 = "Water");

PROC PRINT DATA=aquapoke (obs=10);
RUN;
```

### Common Cleaning Tasks

#### Keeping only certain rows

In SAS, to use a variable, you have to define it in one data step, then make another data step in order to use that variable. But, like `dplyr`, SAS has a row number counter that we can use for this purpose.
```
libname classdat "sas/";

DATA tmp;
SET classdat.poke;
  rownum=_n_; /* SAS shorthand for row number */
RUN;

DATA evenrow;
  SET WORK.tmp;
  WHERE MOD(rownum, 2) = 0;
  DROP rownum; /* ditch temp variable */
RUN;
```

#### Top N values

We're going to want to use PROC SORT to get the data arranged before we take the top N values.
According to [this](https://communities.sas.com/t5/General-SAS-Programming/if-and-where-statement-for-n/td-p/237647), we can't use `_n_` in a where statement, and the proposed solution isn't reliable. So we'll do it the long way.
```
libname classdat "sas/";

PROC SORT DATA = classdat.poke
  OUT = pokesort;
  BY descending total_points;
RUN;

DATA poken;
  SET WORK.pokesort;
  rownum = _n_;
RUN;

DATA poken;
  SET WORK.poken;
  WHERE rownum <= 5;
  DROP rownum;
RUN;

PROC PRINT DATA = poken;
  VAR pokedex_number name status species type_1 total_points;
RUN;
```

In both cases, the SAS statements required to perform the task require a WHERE clause, but also a few other statements to get things working. The equivalent base R code would be about the same (though tricky in different spots).

#### PROC SQL filter statements 
SQL doesn't have an intrinsic notion of ordered rows, so in order to select even rows, we need to create a temporary dataset with `_n_` copied into a variable (just like last time).
```
libname classdat "sas/";

DATA poke;
  SET classdat.poke;
  rownum=_n_;
RUN;

PROC SQL;
SELECT * FROM poke(obs=5)
WHERE mod(rownum, 2) = 0;
```

SELECT \* says to select all variables. We'll talk about SELECT in the next section, but with SQL it's not really possible to avoid using SELECT.

If we want the 5 pokemon with the highest total points, we can use ORDER BY to sort the table, and then specify that we only want 5 rows.

```
libname classdat "sas/";

PROC SQL;
SELECT pokedex_number, name, status, species, type_1, total_points
FROM classdat.poke(obs=5)
ORDER BY total_points DESC;
```

As a reminder, if we want to store this new data into a new dataset, we have to start our statement with CREATE TABLE <tablename> AS, and then follow the statement with our query.

```
libname classdat "sas/";

PROC SQL;
CREATE TABLE poketmp AS
SELECT pokedex_number, name, status, species, type_1, total_points
FROM classdat.poke(obs=5)
ORDER BY total_points DESC;

PROC PRINT DATA=poketmp;
RUN;
```

### Column Selection
Unfortunately, SAS doesn't make column selection *quite* as easy. It's still not hard, but it can be tedious. In SAS, there are two primary methods to select variables: KEEP selects variables, DROP removes variables.

```{r export-data-sas, eval = F}
# Export flights data for SAS
flights %>%
sample_frac(size = .25) %>% # Keep file from being too big
write_csv("data/flights.csv", na = ".")
```

```
/* Read in data */
libname classdat "sas/";
filename fileloc '~/Projects/Class/unl-stat850/2020-stat850/data/flights.csv';
PROC IMPORT  datafile = fileloc out=classdat.flights
DBMS = csv; /* comma delimited file */
GETNAMES = YES;
RUN;
```

In SAS, a partial variable name either preceded or followed by `:` serves as  a wildcard.
Ranges of variables can be specified with two dashes, e.g. `var3 -- var5`.

Unfortunately, the wildcard doesn't work on both ends, so to get the equivalent of `matches("dep")`, we have to use two different options in our KEEP statement (plus the extra variables that don't have dep in them).

```
libname classdat "sas/";

DATA tmpfly;
  KEEP flight year--day tailnum origin dep: sched_dep:;
  SET classdat.flights;
RUN;

PROC PRINT DATA = tmpfly (obs=10);
RUN;
```

Note also that SAS doesn't reorder the columns for us like `select()` does.

If we'd prefer to carve out columns (rather than assembling a new dataset with the columns we want to keep), we can use a DROP statement, which works exactly the same way. Let's see what columns we removed implicitly last time by dropping everything we'd previously kept:

```
libname classdat "sas/";

DATA tmpfly;
  DROP flight year--day tailnum origin dep: sched_dep:;
  SET classdat.flights;
RUN;

PROC PRINT DATA = tmpfly (obs=10);
RUN;
```
  As with the filter statements, we can also use PROC SQL instead of a SAS DATA step. There are even ways to (sort-of) use elements of both.

#### SAS PROC SQL SELECT statement
```
libname classdat "sas/";

PROC SQL;
CREATE TABLE tmpfly
AS
SELECT flight, year, month, day, tailnum, origin
FROM classdat.flights;

PROC PRINT DATA = tmpfly(obs=10);
RUN;
```
Note that PROC SQL doesn't have a RUN statement - it is executed immediately. But, using the PROC SQL syntax, we still have to list out all of the variables, and that's a drag.

Luckily, PROC SQL will also let us use some of the DATA step options, if we're careful about it:
```
libname classdat "sas/";

PROC SQL;
CREATE TABLE tmpfly
AS
SELECT *
FROM classdat.flights(drop=year--day flight tailnum origin dep: sched_dep:);

PROC PRINT DATA = tmpfly(obs=10);
RUN;
```

Note the difference - we're selecting everything (in SQL) but dropping columns when we tell SQL where to look for the data.


For the most part, that is what you need to functionally replicate `select()` syntax. It may be a bit more work because there aren't the same convenience functions, but it'll do and you don't have to remember as many keywords, so that's a plus.

### Creating New Variables


#### SAS DATA STEP 
We can create our variable a couple of different ways in SAS:
- Use the [TRANWRD function](https://v8doc.sas.com/sashtml/lgref/z0215027.htm) for find and replace.
- Use an if statement and define the replacement ourselves

Both are demonstrated below:
```
libname classdat "sas/";

DATA pvtmp;
  SET classdat.police;
  race = tranwrd(victim_s_race, "Race", "race");
  race2 = victim_s_race; /* initialize it to current value */
  IF victim_s_race='Unknown Race' THEN race2 = 'Unknown race';
RUN;

PROC FREQ DATA = pvtmp ORDER=FREQ; /* Combinations of vars */
TABLES victim_s_race * race victim_s_race * race2 /
  NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;
RUN;
```
In both cases we can see that the recode worked the way we wanted and we've now gotten rid of the extra "unknown" category".


#### Proc SQL

We can also use PROC SQL to create new variables using relatively complex logic if necessary.

In SQL, you define new variables using AS. In SELECT statements, this definition has the computation on the left and the variable on the right^[This is equivalent to using right assignment in R with `->`, which you shouldn't do unless you have a *really* good reason, because it's hard to read.].

CASE WHEN is the if-else statement in SQL. When (`victim_s_race` = 'Unknown Race'), our variable value will be "Unknown race", otherwise it will be what ever value is in `victim_s_race`.

```
libname classdat "sas/";

PROC SQL;
CREATE TABLE WORK.pvtmp AS
SELECT * ,
CASE WHEN victim_s_race='Unknown Race' THEN 'Unknown race' ELSE victim_s_race END AS race
FROM classdat.police;


PROC FREQ DATA = pvtmp ORDER=FREQ; /* Combinations of vars */
TABLES victim_s_race * race /
  NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;
RUN;
```

#### Comparison

The choice of which method to use (DATA step or PROC SQL) involves weighing these competing factors:

- computational time
- code readability
- programmer time


Personally, I find PROC SQL easier to work with, but I think the code is ugly. There are similar sql-syntax packages in R, but I don't feel the need to use them, because (for me) dplyr code is much easier to read (and thus, easier to maintain). dplyr code is not as efficient as SQL (or other packages, like `data.table`) on big datasets, but there are variants such as `dbplyr` to handle some of those cases, and I find that they don't come up very often in my work or research. If I were working at Google or Amazon, my opinion might be very different

<!-- The fundamentals of `mutate` are very similar to the approaches above; the power of the dplyr approach is only really evident when you are doing multiple operations in the same step. Once you're working at that level, the `dplyr` approach produces much more readable code. -->

### Summarize


In SAS, we can do something similar:
```
libname classdat "sas/";

DATA pv;
  SET classdat.police;
  age = INPUT(victim_s_age, 3.);
  name_len = LENGTH(victim_s_name);
RUN;

PROC MEANS DATA=pv;
VAR age name_len;
RUN;
```

By default, with SAS, we get a bit more than we bargained for; we can turn the extra output off with options.

Another option is to use PROC SQL in SAS, which will have a logical flow similar to `dplyr`. 

```

libname classdat "sas/";

DATA pv;
  SET classdat.police;
  age = INPUT(victim_s_age, 3.);
  name_len = LENGTH(victim_s_name);
RUN;

PROC SQL;
SELECT AVG(age) as age, AVG(name_len) as name_len
FROM pv;
```

### Group By + (?) = Power

```
libname classdat "sas/";

DATA pv;
  SET classdat.police;
  age = INPUT(victim_s_age, 3.);
  IF victim_s_gender=' ' THEN victim_s_gender='Unknown';
  race = victim_s_race; /* initialize it to current value */
  IF victim_s_race='Unknown Race' THEN race = 'Unknown race';
RUN;

PROC SQL;
  SELECT victim_s_gender AS gender, race, count(*) AS n
  FROM pv
  GROUP BY race;

PROC SQL;
  SELECT victim_s_gender AS gender, race, count(*) AS n, min(age) AS min_age, max(age) AS max_age
  FROM pv
  GROUP BY gender, race;
```

### Storm Example


```
libname classdat "sas/";
filename fileloc 'data/storms.csv';
PROC IMPORT  datafile = fileloc out=classdat.storms REPLACE
DBMS = csv; /* comma delimited file */
GUESSINGROWS=500;
GETNAMES = YES;
RUN;

DATA classdat.storms;
SET classdat.storms;
date = MDY(month, day, year);
time = DHMS(date, hour, 0, 0);
FORMAT time DATETIME.;
RUN;
```
<details><summary>Proc SQL in SAS</summary> 
In SAS, this is going to require some work. Specifically, while dplyr commands are stated in recipe order (do this, then this), SQL statements... aren't. WHERE comes after SELECT xxx FROM yyy, and GROUP BY comes after that again. 

There are a couple of ways to handle that: sub-queries, and creating temporary tables. I think the temporary tables approach will be easier to demonstrate, read, and understand, so lets go with that. 

Another challenge will be the fact that SAS PROC SQL doesn't handle missing data quite as easily as dplyr does (na.rm is a very nice function, all things considered). 
We can think through the steps we need to take: 
1. Create a table where wind and pressure observations aren't missing. We'll call that tmp1. 
2. Filter tmp1, keeping only rows with minimum pressure and maximum wind for each storm/year combination (HAVING is like WHERE, but after the GROUP BY clause has been applied). We'll call that tmp2. We can also select the variables we care about in this step. 
3. Summarize tmp2, keeping columns name, year, pressure, wind, category, status, and time, where time is the mean of all maximum-power observations. The other variables should have only one value each. We can accomplish this task using the combination of SELECT and DISTINCT. DISTINCT says "keep only rows with new combinations of these values". 

(Note also that we can format values inline in proc SQL Select statements. That forces SAS to treat time as a date-time variable, which will force it to format correctly in e.g. plots.)

```
libname classdat "sas/";


PROC SQL;
  CREATE TABLE tmp1 AS
  SELECT *
  FROM classdat.storms
  WHERE (NOT missing(pressure)) AND (NOT missing(wind));
  
  CREATE TABLE tmp2 AS 
  SELECT name, year, pressure, wind, category, status, time, 
         min(pressure) AS minpressure, max(wind) AS maxwind
  FROM tmp1 
  GROUP BY year, name
  HAVING pressure = minpressure AND wind = maxwind;
  
  CREATE TABLE maxpwr AS
  SELECT DISTINCT name, year, pressure, wind, category, status, 
                  mean(time) AS time format=DATETIME.
  FROM tmp2
  GROUP BY year, name;
  
QUIT;
  
PROC PRINT DATA=maxpwr (obs=5);
  RUN;

ODS GRAPHICS ON;
ODS TRACE ON; /* this allows us to select only the plot and not tables */
ODS SELECT HISTOGRAM;
PROC UNIVARIATE DATA=maxpwr;
  VAR pressure;
  HISTOGRAM;
  RUN;
ODS TRACE OFF;
  
PROC SGPLOT DATA=maxpwr;
  scatter X = time Y = pressure;
RUN;
  
ODS GRAPHICS OFF;
QUIT;
```
</details>




In SAS, we have to know that [datetimes are stored in seconds](https://documentation.sas.com/?docsetId=ds2pg&docsetTarget=n02zpqz4j5u3j9n1t0i95ncqep5g.htm&docsetVersion=3.1&locale=en).  So if we subtract two date time values, and we want our answer in days, then we need to divide by the number of seconds in a day: 24\*60\*60 = 86400. R has helper functions to do this for us, but it's not that much harder to just do the computuation ourselves. 

```
libname classdat "sas/";
PROC SQL;
CREATE TABLE stormlencat AS
SELECT name, year, (max(time) - min(time))/86400 AS duration, max(category) AS max_strength
FROM classdat.storms
GROUP BY year, name
ORDER BY max_strength;

PROC BOXPLOT DATA=stormlencat;
  PLOT duration * max_strength;
RUN;
QUIT;
```


```
/* Clean log and output */
dm log "clear";
dm output "clear";
ods html close;
ods html;
```

We can do something similar in SAS; this time, I decided to get rid of any storm which never had hurricane-force winds - that will get rid of a lot of lines that never leave the x-axis.

```
libname classdat "sas/";
PROC SQL;
CREATE TABLE stormevo AS
SELECT name, year, (time - min(time))/86400 AS time_since_start, category, status, hu_diameter, ts_diameter, max(hu_diameter) AS max_hu_diameter
FROM classdat.storms
WHERE NOT MISSING(hu_diameter)
GROUP BY year, name
HAVING max_hu_diameter > 0
ORDER BY year, name, time_since_start;

PROC SGPANEL DATA=stormevo;
PANELBY year / COLUMNS = 4 ROWS = 3;
SERIES X = time_since_start Y = hu_diameter / GROUP = name;
RUN;
QUIT;
```

PROC SGPANEL in SAS does essentially the same thing as facet_wrap() in R - it allows you to select one or more variables to create sub-plots for. We do have to manually specify how many rows and columns (or SAS will give us 3 separate plots with 4 panels each). The essential components of the graph specification are the same - instead of specifying the use of a line, we specify "series" (which means plot a line). We specify the same x, y, and group variables, though the syntax differs a bit.

The SAS code for this is fairly similar (though I'll admit to not having the finesse with SAS to get a truly nice looking plot). At this point, we're going for quick-and-dirty graphics that show us what we want to know - we can figure out how to customize things later. 

```
ODS HTML style= HTMLBlue; /* needed for color graphs in bookdown */

libname classdat "sas/";

PROC SQL;
CREATE TABLE ike AS
SELECT * FROM classdat.storms WHERE name = "Ike"
ORDER BY time;

PROC SGPLOT DATA=ike;
SCATTER X = time Y = hu_diameter / 
  COLORRESPONSE=category /* color by another variable */
  MARKERATTRS=(symbol=CircleFilled) /* use circles for points */
  DATALABEL=category; /* label the circles with the value */
RUN;
QUIT;
```

While I'm tempted to plot out the diameter and location on a map, it's a bit excessive for this particular problem. Luckily, Wikipedia has us covered: 
![Hurricane Ike's path and strength over time](https://upload.wikimedia.org/wikipedia/commons/5/5f/Ike_2008_track.png)

It looks like Ike went long-ways across Cuba, which weakened it. When hurricanes weaken, often their wind fields expand (as they no longer have the angular momentum to maintain a tight structure). Ike crossed into the Gulf of Mexico, restrengthened, and then hit Houston just about dead-on. I was living just northwest of Houston when it hit (in College Station), and I can verify that it was not a fun time. 

### Gapminder: Try it Out


```{r include = T}
readr::write_csv(gapminder_unfiltered, "data/gapminder.csv", na = '.')
```

```
libname classdat "sas/";

filename fileloc 'data/gapminder.csv';
PROC IMPORT  datafile = fileloc out=classdat.gapminder REPLACE
DBMS = csv; /* comma delimited file */
GUESSINGROWS=500;
GETNAMES = YES;
RUN;
````

```
libname classdat "sas/";

PROC SQL;
CREATE TABLE gapsummary AS
SELECT DISTINCT country, COUNT(*) AS n, 
SUM(MISSING(lifeExp)) AS missinglifeExp, 
SUM(MISSING(pop)) AS missingpop,
SUM(MISSING(gdpPercap)) AS missingGDP
FROM classdat.gapminder
GROUP BY country;

/* Print the problem countries only */
PROC PRINT DATA = gapsummary;
WHERE n ^= 12;
RUN;
```

```
libname classdat "sas/";

PROC SQL;
CREATE TABLE gap5 AS
SELECT *
FROM classdat.gapminder
WHERE MOD(year, 5) = 2;

/* Aus had too much data, so use it to see if the command worked */
PROC PRINT DATA = gap5;
WHERE country = "Australia";
RUN;
```

```
libname classdat "sas/";

PROC SQL;
CREATE TABLE gap5 AS
SELECT *
FROM classdat.gapminder
WHERE MOD(year, 5) = 2;

CREATE TABLE gap_clean AS
SELECT *, COUNT(*) as n 
FROM gap5
GROUP BY country
HAVING n = 12;

/* Clean up extra column */
ALTER TABLE gap_clean 
DROP n;

PROC PRINT DATA = gap_clean;
RUN;
```

## Graphics


<details><summary>SAS Examples</summary>
Original SAS graphics engine

Note: This code runs, but it causes every other sas chunk in this document to go haywire... so you'll have to copy the code and run it on your own to see what it looks like. 

```
libname classdat "sas/";

/* This step creates a constant variable in the data frame, 
so that all generations can be stacked in one bar */
  DATA poketmp;
SET classdat.poke;
i = 1;
RUN;

PROC GCHART data=poketmp;
pie generation / other = 0;
RUN;
QUIT; 

PROC GCHART data=poketmp;
VBAR i / SUBGROUP = generation;
RUN;
QUIT; 
```



</details>
  
<details><summary>ODS Graphics</summary>
Note: This is a terrible example in SAS because there isn't an easy way to create a pie chart^[It's not often you'll find me approving of SAS graphics, but making it hard to make pie charts is definitely a point in SAS's favor]. We have to resort to using SAS Graph Template Language. 


```
libname classdat "sas/";

DATA poketmp;
SET classdat.poke;
i = 1;
RUN;

/* Define a pie chart template */
  PROC TEMPLATE;
DEFINE STATGRAPH WORK.simplepie;
BEGINGRAPH;
LAYOUT REGION;
PIECHART category=generation;
ENDLAYOUT;
ENDGRAPH;
END;
RUN;

/* Make the pie chart */ 
  PROC SGRENDER data=classdat.poke template=WORK.simplepie;
RUN;
QUIT; 

/* Use SGPLOT to make a stacked bar chart */
  PROC SGPLOT data=poketmp;
VBAR i / GROUP = generation;
RUN;
QUIT; 
```
As in base R, the syntax between the two types of charts is different, even though the underlying operations required to make the plots are very similar.  This is one example of why I don't agree with the assertion that ODS graphics is like ggplot2 syntax - the functionality may be similar, but the structure is not. 
</details>


## References {#refs-sas}


- [SAS quick start guide](https://towardsdatascience.com/getting-started-with-sas-beginner-354a94a48f08)

- [SAS Cheatsheet (from another class like this)](https://sites.ualberta.ca/~ahamann/teaching/renr480/SAS-Cheat.pdf)
- [SAS Cheatsheet (by SAS)](https://support.sas.com/content/dam/SAS/support/en/books/data/base-syntax-ref.pdf)
- [SAS Programming for R Users (free book)](https://support.sas.com/content/dam/SAS/support/en/books/free-books/sas-programming-for-r-users.pdf)


- [SAS Matrix reference](http://www.math.wpi.edu/saspdf/iml/chap4.pdf)
- [SAS Data set documentation](https://documentation.sas.com/?docsetId=basess&docsetTarget=p1f5xhmkdfhyjcn1n6k9wdcacba0.htm&docsetVersion=9.4&locale=en)
- [Creating SAS Data Sets from IML](https://support.sas.com/content/dam/SAS/support/en/books/simulating-data-with-sas/65378_Appendix_A_A_SAS_IML_Primer.pdf) (also [this](https://education.illinois.edu/docs/default-source/carolyn-anderson/edpsy584/SAS_iml.pdf) friendly guide and [this](https://blogs.sas.com/content/iml/2019/07/17/write-numeric-character-matrices-data-set.html) blog post)
- [SAS Data Step options](https://libguides.library.kent.edu/SAS/DataStep)
- [SAS Mathematical Operators](https://www.tutorialspoint.com/sas/sas_operators.htm)
- [Lists and Data Structures in SAS](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_lists_gettingstarted03.htm&docsetVersion=14.3&locale=en)
- [Loops in SAS](https://blogs.sas.com/content/iml/2011/09/07/loops-in-sas.html) and [SAS documentation for DO WHILE](https://support.sas.com/documentation/cdl/en/lestmtsref/63323/HTML/default/viewer.htm#p1awxgleif5wlen1pja0nrn6yi6i.htm) loops
- [Random number generation in SAS](https://www.sas.com/content/dam/SAS/support/en/sas-global-forum-proceedings/2018/1810-2018.pdf)


### Data Files


- [Reading JSON in SAS](https://support.sas.com/resources/papers/proceedings17/0856-2017.pdf) -- You know SAS documentation is getting weird when they advertise a method as "the sexiest way to import JSON data into SAS". 
- [Reading Rdata files in SAS](http://proc-x.com/2015/05/import-rdata-to-sas-along-with-labels/)
- [Common problems with SAS data files](https://blogs.sas.com/content/sgf/2015/04/17/turning-text-files-into-sas-data-sets-6-common-problems-and-their-solutions/)


### Data Cleaning

- [SAS Dates and Times](https://documentation.sas.com/?docsetId=lrcon&docsetTarget=p1wj0wt2ebe2a0n1lv4lem9hdc0v.htm&docsetVersion=9.4&locale=en).
- [Common String operations in SAS](https://www.listendata.com/2014/12/sas-character-functions.html)
- [Regular Expressions in SAS](https://support.sas.com/resources/papers/proceedings/proceedings/sugi29/265-29.pdf)

- [Using WHERE with SAS Procedures](https://stats.idre.ucla.edu/sas/modules/using-where-with-sas-procedures/)
- [PROC SQL documentation](https://documentation.sas.com/?docsetId=sqlproc&docsetTarget=n1oihmdy7om5rmn1aorxui3kxizl.htm&docsetVersion=9.4&locale=en)
- [SAS data manipulation](https://vknight.org/SAS-R/Content/SAS-Chapter-03/)
