[["intro-prog.html", "Module 2 Introduction to Statistical Programming Module Objectives Definitions Statistical Programming Languages 2.1 Breaking Problems Down 2.2 Variable types 2.3 Data structures 2.4 Control structures 2.5 Overgrown Calculators References and Links", " Module 2 Introduction to Statistical Programming The only way to learn how to program effectively is to take something that works, break it, and then fix it again. There’s plenty of theory and you should definitely learn that, but fundamentally, if you are not regularly breaking code, you’re probably not programming. Figure 2.1: This is basically the class summarized. The goal for this chapter (and several chapters to come) is that you can modify example code and adapt it to the problem at hand. This is the best way to learn how to program, but it means you may break the code and not know how to fix it. If that happens, please try the following steps: Google the error and see if you can understand why it happened. Consult with a classmate to see if they can understand where things broke. Post to the discussion board and see if anyone in the class can understand where things broke. (When you do this, post all of the code relevant to the problem, and the error you’re getting, so that your classmates can replicate the problem) If you do not hopelessly break code during this chapter, then please do your best to help others who may not have previously programmed (or previously programmed in these languages). While writing this chapter, I came across about 10 errors in SAS that I’d never encountered before. If all else fails, while you’re waiting for someone to help you figure out what an error message means… try this approach. Module Objectives Create a program flow map by breaking a problem down into smaller steps Write basic scripts to solve mathematical problems with variables, control structures, and scalar/matrix algebra More informally, the goal is to get familiar with the basics of each programming language, and to show you where to find references for how to use each command – because (at least) half of programming is knowing where to look something up. Definitions Many programming resources talk about 3, or 5, or 10 core concepts in any programming language. In this module, we’re going to discuss the generic concepts, and then how these concepts are implemented in R and SAS. Interestingly, the “core concepts” aren’t necessarily the same across lists. Here is a consensus list of concepts which are generic across languages and usually important Variables - a symbolic name or reference to some kind of information. In the expression a + b &gt; a, both a and b are variables. Variables may have a specific type (what data can be stored in the variable), scope (where the variable can be accessed), location (in memory). Here is a nice explanation of the difference between variables in programming and variables in math. Conditional statements (if statements) - These statements allow the program to handle information adaptively - if a statement is true, one set of instructions will be used, and if the statement is false, a different set of instructions will be used. Looping and iteration - An iteration is any time a sequence of steps is executed. Most languages have several different types of loops or iteration: for loops, which allow for the sequence of steps to be executed a specific number of times, while loops, which allow for the sequence of steps to be executed while a conditional statement is true, recursion, where a block of code calls itself. Data types and data structures - these concepts determine what information a variable can hold. Data types are lower-level, simple objects (floating-point numbers, integers, boolean T/F, characters, strings). Data structures may include lists (sequences of many objects) and vectors (sequences of many objects of the same type), dictionaries (a list of key-value pairs), objects (data structures which may hold multiple related pieces of information). Functions, or self-contained modules of code that accomplish a particular task. Syntax, the set of rules that define which combinations of symbols consist of correctly structured and interpretable commands in the language. Tools, the set of external programs which may help with development and writing code. Some common tools are IDEs (Integrated Development Environments), which may correct syntax and typos, organize files for you, allow you to keep track of which variables you have defined, and assist you with code organization and navigation. Other tools include compilers (which take human-written code and translate it into efficient machine code), version control systems (which help you track changes to code over time), debuggers, and documentation generators. Not all of these tools are necessary for all languages - scripting languages such as python and R do not require compilers by default, for instance. Sequence of commands: It’s important to have the right commands in the right order. Some recipes, like bread dough, are flexible, and you can add the ingredients in almost any order, but in other recipes, the order matters as much as the correct quantity of ingredients (try putting the cheese powder in before the noodles are boiled when making macaroni and cheese. Yuck.). Programming tends to be like these less flexible recipes. Statistical Programming Languages Having established the generic definitions of the concepts which apply to almost any programming language, we now must examine how R and SAS implement these concepts. R and SAS are both statistical programming languages - they are specifically designed to work with data, which means that they make compromises that other languages do not in order to make it easier to write code where the data (rather than the functions, classes, methods, or objects) are the primary concern. With that said, there are a few notes which are worth mentioning – Historical view Both R and SAS have long histories. SAS in particular dates back to the 1960s, and has syntax which is unique compared to more modern languages such as C, python, Java, and R. R’s predecessor, S, dates back to 1976 and was designed for internal use at Bell Labs. The histories of both languages are useful in understanding why they are optimized for their respective tasks, but are not essential for this course (so read them at your leisure). Difference between R and SAS The biggest difference between R and SAS (at a fundamental level) is that R is a functional language - it consists mainly of functions, which can (and do) manipulate objects, including other functions. SAS, on the other hand, is a procedural language - most SAS programs follow a specific series of steps, known as “proc”s. Procs are essentially functions (or compositions of multiple functions), but in SAS, it is simpler to think of an analysis as a series of procedural steps; in R, there are steps, but they may be implemented in a more flexible way (depending on the analysis). Another interesting feature of SAS is that it’s really several languages - some commands work in PROC IML (interactive matrix language) but not in a DATA step. When looking for help in SAS, make sure you’re referencing the correct part of the language documentation. I’m teaching SAS very differently I’m definitely teaching SAS differently than it is normally taught. This is so that we don’t have to do half the semester in SAS and half in R - I’d rather teach the concepts and show you how they’re implemented than split them up by language. BUT, this means that some of the things we’re doing first in SAS are things you wouldn’t normally do until you were already proficient in SAS. It also means that SAS is probably going to seem even more oddly organized when taught this way than it actually is (and it is oddly organized, in my opinion). We’re going to start with SAS IML (programming concepts) and then talk about the DATA step. We’ll use some procedures implicitly along the way, but hopefully that will make sense in context. Then, we’ll work on the PROCs (SQL, Transpose, and graphing) - in greater detail. If you’ve used R or SAS a lot in the past Note: If you’ve programmed before, this chapter is going to seem very … boring. Sorry, there’s no help for that. Some of your classmates haven’t ever so much as written “Hello World,” and we have to get them up to speed. If you’re bored, or feel like you know this material, skim through it anyways just to confirm (and if I’m doing something that’s really out there, or there’s an easier way to do it, tell me!). Then you can either find something in the references that you don’t know already (the book Advanced R is always a great place to start if you want to be quickly confused), or help your classmates that are less experienced. Basic Syntax and Cheatsheets SAS Cheatsheet (from another class like this) SAS Cheatsheet (by SAS) R Cheatsheet - this is a simplified cheat sheet offered by RStudio. R Cheatsheet (classic) SAS Programming for R Users (free book) I kept the classic R reference card by my computer for about 5 years, and referenced it at least once or twice a day for that entire period. There will be other cheat sheets and reference cards scattered through this book because if you can’t remember something’s name, you might be able to remember where it is on the reference card (or at least, that’s how I learned R). 2.1 Breaking Problems Down The most fundamental part of programming that you will need to learn in this class is how to break down a big problem into smaller (hopefully solvable) problems. This post is a great example of the process of breaking things down for programming, but the same concept applies outside of programming too! Breaking problems down - remodeling edition My spouse and I recently decided to replace our shower curtain with glass doors because the curtain didn’t really prevent water from getting all over the floor. We went to the store and picked out the parts, and the installation instructions broke the steps down like this: Install the base of the track Install the top of the track Hang shower doors Add hardware to shower doors So we started in on the instructions, only to find out that when our house was built, our shower wasn’t leveled properly. The instructions had a solution - we could send off for a $300 custom part that would level our floor, but we’d have to wait at least 4-6 weeks for them to make and ship the part to us. We’re both programmer-adjacent, so we started thinking through how we could deal with our problem a different way. We considered ignoring the instructions – our shower was about 1/8\" off of level, surely that couldn’t be so important, right? My spouse is a bit more … detail oriented … than I am, so he wasn’t good with that suggestion. We considered adding a ton of caulk or plaster to try to level the shower out. But we figured that 1) probably wouldn’t work, and 2) would look awful. Finally, I suggested that my spouse 3D print sections of track-leveler using our 3D printer. Now, this isn’t an option for most people, but it is for us - we have a small 3D printer, and spouse knows how to use OpenSCAD to create very accurate, custom dimension 3D printer files. He tested things out a few times, and printed up a series of 12 ~5\" sections that when assembled were equivalent to the $300 custom part we could have ordered. Then, he proceeded with the rest of the installation as the instructions listed. Essentially, because we had a list of subproblems (steps for installation), we could focus our efforts on debugging the one problem we had (not level shower ledge) and we didn’t have to get bogged down in “it’s impossible to get this job done” - we knew that if we could solve the little problem, we’d be able to get the bigger job done. Programming is just like this - if you can break your problem down into steps (and not steps with code), you can think through how to solve a single step of the problem before you worry about the next step. One tool that is often used to help break a problem down is a flowchart. Try it out The biggest advantage to breaking problems down into smaller steps is that it allows you to focus on solving a small, approachable problem. Let’s think through an example: suppose I want you to write a program to print out a pyramid of stars, 10 lines high. Yes, I remember, I haven’t taught you how to write any code yet. Don’t worry about code right now - let’s just think about how we might create a pyramid of stars. Start by writing some instructions to yourself. Solution First, we have to think about what we would need to make a pyramid of stars. So let’s make a miniature one by hand (I’m using - for spaces here to make things visible): ---*--- --***-- -*****- To make my miniature star pyramid, I started out by adding space on the first line, then a star, then more space. When I moved to the next line, I added space, but one less space than I’d added before, and then 3 stars, and then more space. So we can break our problem down into two components: How much space? (one side) How many stars? (redundant piece) How much space (the other side). Thinking my way through how I created my manual pyramid, I realized that I was adding \\(n\\) spaces (where \\(n\\) is the total number of rows) on the first line, and then \\(n - i\\) spaces on subsequent lines, if we start with i=0. But I am an R programmer, so we start with \\(i=1\\), which means I need to have \\(n - i + 1\\) spaces on each row first. Then, for \\(i=1\\) the first row, we have \\(2*i - 1\\) stars - i = 1, stars = 1, then i = 2, stars = 3, then i = 3, stars = 5…. you can do the regression if you want to, but it’s pretty easy to see the relationship. Finally, we have to (in theory) add the same amount of space on the other side – strictly speaking, this is optional, but it makes the lines the same length, so it is nice. So we’ve thought through the problem step by step, and now we just need to summarize it: If we want a pyramid that is \\(n\\) rows high, we might think of creating it by using the following line-by-line formula, where \\(i\\) is our current line: \\(n - i +1\\) spaces, \\(2i - 1\\) stars, \\(n - i + 1\\) spaces Working this out in a small example helped me come up with that formula; now, I can write a “loop”: line 1: i = 1, n = 10, 10 spaces, 1 star, 10 spaces line 2: i = 2, n = 10, 9 spaces, 3 stars, 9 spaces line 3: i = 3, n = 10, 8 spaces, 5 stars, 8 spaces line 4: i = 4, n = 10, 7 spaces, 7 stars, 7 spaces … line n: i = n, n = 10, 1 space, 19 stars, 1 space Our program flow map would look something like this: 2.2 Variable types Variable types are sufficiently different in R and SAS that we will cover R first, then SAS. For a general overview, though, this video, titled ‘Why TRUE + TRUE = 2’ is an excellent introduction. 2.2.1 R In R, there are 4 commonly-used types: Type Description character holds text-based information: “abcd” or “3.24a” are examples of values which would be stored as characters in R logical holds binary information: 0/1, or FALSE/TRUE. Logical variables are stored as single bit information (e.g. either a 0 or 1), but display as TRUE and FALSE (which are reserved words and constants). integer holds (as you might expect) integers. Note that integers are handled differently than doubles (floating point numbers), but in general, R will implicitly convert integers to doubles to avoid common pitfalls with integer divison (which does not allow for decimals). double holds floating point numbers. By default, most numeric variables in R are doubles. You can test to see whether a variable holds a value of a specific type using the is.xxx() functions, which are demonstrated below. You can convert a variable of one type to another with as.xxx() functions. You can test what type a variable is using typeof(). Note that &lt;- is used for assigning a value to a variable. So x &lt;- \"R is awesome\" is read “x gets ‘R is awesome’” or “x is assigned the value ‘R is awesome’.” Character variables x &lt;- &quot;R is awesome&quot; typeof(x) [1] &quot;character&quot; is.character(x) [1] TRUE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] FALSE Logical Variables x &lt;- FALSE typeof(x) [1] &quot;logical&quot; is.character(x) [1] FALSE is.logical(x) [1] TRUE is.integer(x) [1] FALSE is.double(x) [1] FALSE It is possible to use the shorthand F and T, but be careful with this, because F and T are not reserved, and other information can be stored within them. See this discussion for pros and cons of using F and T as variables vs. shorthand for true and false.1 Integer Variables x &lt;- 2 typeof(x) [1] &quot;double&quot; is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] TRUE Wait, 2 is an integer, right? 2 is an integer, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically. x &lt;- 2L # The L immediately after the 2 indicates that it is an integer. typeof(x) [1] &quot;integer&quot; is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] TRUE is.double(x) [1] FALSE is.numeric(x) [1] TRUE Double Variables x &lt;- 2.45 typeof(x) [1] &quot;double&quot; is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] TRUE is.numeric(x) [1] TRUE Numeric Variables A fifth common “type”2, numeric is really the union of two types: integer and double, and you may come across it when using str() or mode(), which are similar to typeof() but do not quite do the same thing. The numeric category exists because when doing math, we can add an integer and a double, but adding an integer and a string is … trickier. Testing for numeric variables guarantees that we’ll be able to do math with those variables. is.numeric() and as.numeric() work as you would expect them to work. The general case of this property of a language is called implicit type conversion - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double. Type Conversions R will generally work hard to seamlessly convert variables to different types. So, for instance, TRUE + 2 [1] 3 2L + 3.1415 [1] 5.1415 &quot;abcd&quot; + 3 Error in &quot;abcd&quot; + 3: non-numeric argument to binary operator This conversion doesn’t always work - there’s no clear way to make “abcd” into a number we could use in addition. So instead, R will issue an error. This error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops. When you want to, you can also use as.xxx() to make the type conversion explicit. So, the analogue of the code above, with explicit conversions would be: as.double(TRUE) + 2 [1] 3 as.double(2L) + 3.1415 [1] 5.1415 as.numeric(&quot;abcd&quot;) + 3 Warning: NAs introduced by coercion [1] NA When we make our intent explicit (convert “abcd” to a numeric variable) we get an NA - a missing value. There’s still no easy way to figure out where “abcd” is on a number line, but our math will still have a result - NA + 3 is NA. If you are unsure what the type of a variable is, use the typeof() function to find out. w &lt;- &quot;a string&quot; x &lt;- 3L y &lt;- 3.1415 z &lt;- FALSE typeof(w) [1] &quot;character&quot; typeof(x) [1] &quot;integer&quot; typeof(y) [1] &quot;double&quot; typeof(z) [1] &quot;logical&quot; Factors In R, there is one other type of variable to know about, and that is a factor. Factors are basically labeled integers. Instead of storing the data as a string or character, R instead stores the data as a series of integers, and then stores a separate table mapping the integers to labels. This is technically more efficient (which was important when computers had extremely limited memory), but it is also a pain in the rear (that’s a technical term). Factors are the default way to store characters for most base R functions. Or rather, they were. In R 4.0, the default way to read data in will change from stringsAsFactors = T to stringsAsFactors = F. You can read about why factors aren’t ideal here, which helps explain why this change was made. Depending on what version of R you have installed, you may run into errors related to factors, or not. Because R 4.0 is so new (released in May 2020) most of the tutorials online will probably have behavior that isn’t matched by your R installation. I’m new enough to R 4.0 that I’m not sure when factor related errors will pop up. Other reasons to learn factors besides for debugging purposes: They allow you to control the order of things in graphs, tables, and models They allow you to easily change category labels without having to sort through an entire data table … I’m sure there are more, but I’m drawing a blank at the moment Factors example In this example, we’ll use a data.frame, which you can think of as a spreadsheet-type table. We’ll work with data frames later in much more detail, but for now, I’m mostly trying to show you a real-life situation that happens ALL the time, with the hopes that you’ll recognize the error when/if you encounter it. The data frame isn’t the important part. Let’s look at the names of the months: month.name [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; df &lt;- data.frame(num = 1:12, name = month.name, stringsAsFactors = T) # I&#39;m putting the argument in so that this is still relevant when everyone # switches to R 4.0. Even with stringsAsFactors = F, factors are still useful # and we still need to work with them. # # Any time you create a data frame in base R, you should be watchful for errors # that are based on strings being converted to factors. str(df) &#39;data.frame&#39;: 12 obs. of 2 variables: $ num : int 1 2 3 4 5 6 7 8 9 10 ... $ name: Factor w/ 12 levels &quot;April&quot;,&quot;August&quot;,..: 5 4 8 1 9 7 6 2 12 11 ... Notice that as soon as we make that data.frame, the months are converted into a factor variable? The other big problem is that the order of the factor levels is … not what we’d normally want. We don’t want alphabetical ordering of month names - they have a different, implicit, and natural order. We could get this same behavior without the data.frame, but this is where it shows up most often. month_fct &lt;- factor(month.name) # the order is still not exactly what we&#39;d want it to be To fix this, we can explicitly specify that we’re dealing with a factor, and what we want the levels to be. If you specify the levels manually (instead of letting R do the work for you) then you get to determine the order. month_fct &lt;- factor(month.name, levels = month.name) str(month_fct) Factor w/ 12 levels &quot;January&quot;,&quot;February&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... We can even be more explicit: month_fct &lt;- factor(month.name, levels = month.name, ordered = T) str(month_fct) Ord.factor w/ 12 levels &quot;January&quot;&lt;&quot;February&quot;&lt;..: 1 2 3 4 5 6 7 8 9 10 ... Making the factor ordered lets us explicitly say which levels are less than other levels. Factors are technically integers, with labels that are stored as an attribute. That doesn’t mean you can do math with them, though. month_fct[1] + month_fct[2] Warning in Ops.ordered(month_fct[1], month_fct[2]): &#39;+&#39; is not meaningful for ordered factors [1] NA Often, years or dates or other numeric-like information will end up as factor variables. When this happens, you need to be a little bit careful. # This works pretty naturally for months, right? as.numeric(month_fct) [1] 1 2 3 4 5 6 7 8 9 10 11 12 yfact &lt;- factor(2000:2020, levels = 2000:2020) yfact [1] 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 [16] 2015 2016 2017 2018 2019 2020 21 Levels: 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 ... 2020 # But, this does not... as.numeric(yfact) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 as.character(yfact) # gets the labels [1] &quot;2000&quot; &quot;2001&quot; &quot;2002&quot; &quot;2003&quot; &quot;2004&quot; &quot;2005&quot; &quot;2006&quot; &quot;2007&quot; &quot;2008&quot; &quot;2009&quot; [11] &quot;2010&quot; &quot;2011&quot; &quot;2012&quot; &quot;2013&quot; &quot;2014&quot; &quot;2015&quot; &quot;2016&quot; &quot;2017&quot; &quot;2018&quot; &quot;2019&quot; [21] &quot;2020&quot; as.numeric(as.character(yfact)) # gets the info we want [1] 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 [16] 2015 2016 2017 2018 2019 2020 When converting factors with numeric labels, you need to first convert the factor to a character, and then to a numeric variable. That will get the information you actually want back out. Try It Out Create variables string, integer, decimal, and logical, with types that match the relevant variable names. string &lt;- integer &lt;- decimal &lt;- logical &lt;- Can you get rid of the error that occurs when this chunk is run? logical + decimal integer + decimal string + integer What happens when you add string to string? logical to logical? Solutions string &lt;- &quot;hi, I&#39;m a string&quot; integer &lt;- 4L decimal &lt;- 5.412 logical &lt;- TRUE logical + decimal [1] 6.412 integer + decimal [1] 9.412 as.numeric(string) + integer Warning: NAs introduced by coercion [1] NA &quot;abcd&quot; + &quot;defg&quot; Error in &quot;abcd&quot; + &quot;defg&quot;: non-numeric argument to binary operator TRUE + TRUE [1] 2 In R, adding a string to a string creates an error (“non-numeric argument to binary operator”). Adding a logical to a logical, e.g. TRUE + TRUE, results in 2, which is a numeric value. 2.2.2 SAS In SAS, there are two basic variable types: numeric and character variables. SAS does not differentiate between integers and floats and doubles. Functionally, though, the same basic operations can be performed in SAS. As with R, SAS does attempt to implicitly convert variable types, and will notify you that the conversion has taken place in the log file. Type Conversions SAS will attempt to implicitly convert variables when: a character value is assigned to a previously defined numeric variable a character value is used in arithmetic operations a character value is compared to a numeric value using a comparison operator (&lt;, &gt;, &lt;=, &gt;=) a character value is specified in a function that takes numeric arguments Implicit conversion does not occur in WHERE statements. (This will make more sense later, but is here for reference) Manual type conversions If you want to manually convert a value, use the INPUT statement. Unlike in R, the INPUT statement has the ability to read numbers which are formatted differently. For instance 2 data set1; 3 x = 3; 4 y = &#39;3.1415&#39;; 5 z = x * y; 6 put z; 7 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 5:11 NOTE: The data set WORK.SET1 has 0 observations and 3 variables. WARNING: Data set WORK.SET1 was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,40. The SAS System 1 15:37 Monday, April 26, 2021 --------- List = ick--------- Item 1 olives Item 2 sausage Item 3 anchovies --------- List = crust--------- Item 1 flour Item 2 yeast Item 3 salt Item 4 water --------- List = yummy_toppings--------- Item 1 asiago Item 2 fontina The SAS System 2 15:37 Monday, April 26, 2021 Item 3 blue cheese Item 4 bacon Item 5 scallions Average math test scores under the influence of LSD 3 15:37 Monday, April 26, 2021 The DATASETS Procedure Data Set Name WORK.MATHLSD Observations 7 Member Type DATA Variables 2 Engine V9 Indexes 0 Created 04/26/2021 15:37:01 Observation Length 16 Last Modified 04/26/2021 15:37:01 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 1 First Data Page 1 Max Obs per Page 4061 Obs in First Data Page 7 Number of Data Set Repairs 0 Filename /tmp/SAS_workA66C000B51CF_ silicon/mathlsd.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 11275515 Access Permission rw-rw-r-- Owner Name susan File Size 128KB File Size (bytes) 131072 Alphabetic List of Variables and Attributes # Variable Type Len 1 Drugs Num 8 2 Score Num 8 Average math test scores under the influence of LSD 4 15:37 Monday, April 26, 2021 Obs Drugs Score 1 1.17 78.93 2 2.97 58.20 3 3.26 67.47 4 4.69 37.47 5 5.83 45.65 6 6.00 32.92 7 6.41 29.97 Average math test scores under the influence of LSD 5 15:37 Monday, April 26, 2021 x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 y 11 12 16 17 Average math test scores under the influence of LSD 6 15:37 Monday, April 26, 2021 Obs _TYPE_ _FREQ_ x 1 0 466 233168 Average math test scores under the influence of LSD 7 15:37 Monday, April 26, 2021 Obs name status present 1 Edison nice toy 2 Alex naughty coal 3 Susan toy 4 Ryan neutral toy Fundamental Step in the Koch Snowflake Construction 8 15:37 Monday, April 26, 2021 The CONTENTS Procedure Data Set Name CLASSDAT.SQUIRREL Observations 3023 Member Type DATA Variables 36 Engine V9 Indexes 0 Created 04/21/2021 11:42:03 Observation Length 656 Last Modified 04/21/2021 11:42:03 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 31 First Data Page 1 Max Obs per Page 99 Obs in First Data Page 89 Number of Data Set Repairs 0 Filename /home/susan/Projects/Class/unl-stat850/ stat850-textbook/sas/squirrel.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 39064960 Access Permission rw-rw-r-- Owner Name susan File Size 2MB File Size (bytes) 2097152 Alphabetic List of Variables and Attributes # Variable Type Len Format Informat 14 Above_Ground_Sighter_Measurement Char 5 $5. $5. 8 Age Char 8 $8. $8. 27 Approaches Char 5 $5. $5. 34 Borough_Boundaries Num 8 BEST12. BEST32. 17 Chasing Char 5 $5. $5. 35 City_Council_Districts Num 8 BEST12. BEST32. 18 Climbing Char 5 $5. $5. 12 Color_notes Char 110 $110. $110. 11 Combination_of_Primary_and_Highl Char 29 $29. $29. 33 Community_Districts Num 8 BEST12. BEST32. 6 Date Num 8 BEST12. BEST32. 19 Eating Char 5 $5. $5. 20 Foraging Char 5 $5. $5. 4 Hectare Char 3 $3. $3. 7 Hectare_Squirrel_Number Num 8 BEST12. BEST32. 10 Highlight_Fur_Color Char 24 $24. $24. Koch Snowflake Fundamental Step in the Koch Snowflake Construction 9 15:37 Monday, April 26, 2021 The CONTENTS Procedure Alphabetic List of Variables and Attributes # Variable Type Len Format Informat 28 Indifferent Char 5 $5. $5. 22 Kuks Char 5 $5. $5. 31 Lat_Long Char 45 $45. $45. 13 Location Char 12 $12. $12. 24 Moans Char 5 $5. $5. 21 Other_Activities Char 134 $134. $134. 30 Other_Interactions Char 70 $70. $70. 36 Police_Precincts Num 8 BEST12. BEST32. 9 Primary_Fur_Color Char 8 $8. $8. 23 Quaas Char 5 $5. $5. 16 Running Char 5 $5. $5. 29 Runs_from Char 5 $5. $5. 5 Shift Char 2 $2. $2. 15 Specific_Location Char 58 $58. $58. 25 Tail_flags Char 5 $5. $5. 26 Tail_twitches Char 5 $5. $5. 3 Unique_Squirrel_ID Char 14 $14. $14. 1 X Num 8 BEST12. BEST32. 2 Y Num 8 BEST12. BEST32. 32 Zip_Codes Char 1 $1. $1. Koch Snowflake 2 data set2; 3 x = 3; 4 y = &#39;3.1415&#39;; 5 z = x * y; 6 put z; /* print to log */ 7 8 x = &#39;3.14159&#39;; 9 /* x previously had a number in it, 10 so it will be converted to a number here */ 11 put x; /* print to log */ 12 13 zz = y &lt;= 2; 14 /* comparison operator: y will be converted */ 15 put zz; /* print to log */ 16 17 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 5:11 8:7 13:8 NOTE: The data set WORK.SET2 has 0 observations and 4 variables. WARNING: Data set WORK.SET2 was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,40. The SAS System 1 15:37 Monday, April 26, 2021 --------- List = ick--------- Item 1 olives Item 2 sausage Item 3 anchovies --------- List = crust--------- Item 1 flour Item 2 yeast Item 3 salt Item 4 water --------- List = yummy_toppings--------- Item 1 asiago Item 2 fontina The SAS System 2 15:37 Monday, April 26, 2021 Item 3 blue cheese Item 4 bacon Item 5 scallions Average math test scores under the influence of LSD 3 15:37 Monday, April 26, 2021 The DATASETS Procedure Data Set Name WORK.MATHLSD Observations 7 Member Type DATA Variables 2 Engine V9 Indexes 0 Created 04/26/2021 15:37:02 Observation Length 16 Last Modified 04/26/2021 15:37:02 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 1 First Data Page 1 Max Obs per Page 4061 Obs in First Data Page 7 Number of Data Set Repairs 0 Filename /tmp/SAS_work7574000B52E2_ silicon/mathlsd.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 11275515 Access Permission rw-rw-r-- Owner Name susan File Size 128KB File Size (bytes) 131072 Alphabetic List of Variables and Attributes # Variable Type Len 1 Drugs Num 8 2 Score Num 8 Average math test scores under the influence of LSD 4 15:37 Monday, April 26, 2021 Obs Drugs Score 1 1.17 78.93 2 2.97 58.20 3 3.26 67.47 4 4.69 37.47 5 5.83 45.65 6 6.00 32.92 7 6.41 29.97 Average math test scores under the influence of LSD 5 15:37 Monday, April 26, 2021 x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 y 11 12 16 17 Average math test scores under the influence of LSD 6 15:37 Monday, April 26, 2021 Obs _TYPE_ _FREQ_ x 1 0 466 233168 Average math test scores under the influence of LSD 7 15:37 Monday, April 26, 2021 Obs name status present 1 Edison nice toy 2 Alex naughty coal 3 Susan toy 4 Ryan neutral toy Fundamental Step in the Koch Snowflake Construction 8 15:37 Monday, April 26, 2021 The CONTENTS Procedure Data Set Name CLASSDAT.SQUIRREL Observations 3023 Member Type DATA Variables 36 Engine V9 Indexes 0 Created 04/21/2021 11:42:03 Observation Length 656 Last Modified 04/21/2021 11:42:03 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 31 First Data Page 1 Max Obs per Page 99 Obs in First Data Page 89 Number of Data Set Repairs 0 Filename /home/susan/Projects/Class/unl-stat850/ stat850-textbook/sas/squirrel.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 39064960 Access Permission rw-rw-r-- Owner Name susan File Size 2MB File Size (bytes) 2097152 Alphabetic List of Variables and Attributes # Variable Type Len Format Informat 14 Above_Ground_Sighter_Measurement Char 5 $5. $5. 8 Age Char 8 $8. $8. 27 Approaches Char 5 $5. $5. 34 Borough_Boundaries Num 8 BEST12. BEST32. 17 Chasing Char 5 $5. $5. 35 City_Council_Districts Num 8 BEST12. BEST32. 18 Climbing Char 5 $5. $5. 12 Color_notes Char 110 $110. $110. 11 Combination_of_Primary_and_Highl Char 29 $29. $29. 33 Community_Districts Num 8 BEST12. BEST32. 6 Date Num 8 BEST12. BEST32. 19 Eating Char 5 $5. $5. 20 Foraging Char 5 $5. $5. 4 Hectare Char 3 $3. $3. 7 Hectare_Squirrel_Number Num 8 BEST12. BEST32. 10 Highlight_Fur_Color Char 24 $24. $24. Koch Snowflake Fundamental Step in the Koch Snowflake Construction 9 15:37 Monday, April 26, 2021 The CONTENTS Procedure Alphabetic List of Variables and Attributes # Variable Type Len Format Informat 28 Indifferent Char 5 $5. $5. 22 Kuks Char 5 $5. $5. 31 Lat_Long Char 45 $45. $45. 13 Location Char 12 $12. $12. 24 Moans Char 5 $5. $5. 21 Other_Activities Char 134 $134. $134. 30 Other_Interactions Char 70 $70. $70. 36 Police_Precincts Num 8 BEST12. BEST32. 9 Primary_Fur_Color Char 8 $8. $8. 23 Quaas Char 5 $5. $5. 16 Running Char 5 $5. $5. 29 Runs_from Char 5 $5. $5. 5 Shift Char 2 $2. $2. 15 Specific_Location Char 58 $58. $58. 25 Tail_flags Char 5 $5. $5. 26 Tail_twitches Char 5 $5. $5. 3 Unique_Squirrel_ID Char 14 $14. $14. 1 X Num 8 BEST12. BEST32. 2 Y Num 8 BEST12. BEST32. 32 Zip_Codes Char 1 $1. $1. Koch Snowflake Notice that in SAS, zz, which is the result of the logical statement y&lt;=2, is a numeric variable. The value 0 signifies that the comparison was false. SAS does not have a logical data type, it uses the numeric variable with 0:=FALSE, 1:=TRUE. Try it out Create variables string1 and string2 that each have text/character values. “Bob” and “Jane” might be good options. How does logical operation work with actual character values? What happens if you use string1 and add 3 to it? Solutions 6 data set1; 7 string1 = &#39;Bob&#39;; 8 string2 = &#39;Jane&#39;; 9 x = string1 &lt; string2; 10 put x=; /* This prints the result to the log */ 11 run; NOTE: The data set WORK.SET1 has 0 observations and 3 variables. WARNING: Data set WORK.SET1 was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 12 ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,40. SAS will actually compare strings based on the first letter: Bob comes before Jane, so Bob &lt; Jane. 6 data set2; 7 string1 = &#39;Bob&#39;; 8 y = string1 + 3; 9 put y=; 10 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 8:7 NOTE: The data set WORK.SET2 has 0 observations and 2 variables. WARNING: Data set WORK.SET2 was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,41. The . in SAS is a missing value (like NA in R). So SAS is behaving basically like R does: it complains about the fact that you asked it to add a string to a number, and then it stores the result as a missing value. 2.3 Data structures Data structures are more complex arrangements of information than single variables. Of primary interest in statistical programming are the following types of structures:   Homogeneous Heterogeneous 1d vector list 2d matrix data frame (R) or data set (SAS) nd array (R) In the table above, homogeneous means that all entries in the structure must be of the same type. Heterogeneous means that the entries are allowed to be of different types. Figuring out what to call these types with two languages is hard - in SAS, an array is a group of columns of a data set, but in R, it’s a multi-dimensional matrix. In this section, we’ll discuss the generic concepts relevant to both languages. The differences between the two languages will be discussed as appropriate. As there are more similarities than differences, it’s easier to do this in a single section rather than duplicating half of the content. 2.3.1 Homogeneous data structures (R and SAS) R does not have scalar types - even single-value variables are technically vectors of length 1. SAS does have scalar types. If we try to create a heterogeneous vector in R, using the concatenate function, c(), which combines scalar entries into a vector, what happens? c(1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) [1] &quot;1&quot; &quot;2&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; Because there were 3 character entries, the entire vector is now a character vector. This behavior can cause some errors - for instance, R does not read in numeric data formatted with commas as numeric data. You may thus get the result x &lt;- c(356, 452, &quot;1,325&quot;) mean(x) Warning in mean.default(x): argument is not numeric or logical: returning NA [1] NA If you are reading in data from a file, this will cause some issues - the whole column of data will be formatted as characters. Keep an eye out for errors of this type. Jenny Bryan has an excellent set of images to demonstrate R data types as legos. She’s released them under an open license, so I am shamelessly stealing them. Logical vector Factor vector Integer and Numeric vectors These correspond to the 1-dimensional homogeneous data structures. Similarly, models can be made for 2-dimensional and 3-dimensional homogeneous data structures3: Vector (1D) Matrix (2D) Array (3D) 2.3.2 Heterogeneous data structures The heterogeneous data types are not much harder to grasp, as they’re mostly different ways to combine various homogeneous data types. 2.3.2.1 Lists A list is, well, a list - a sequence of potentially different-typed values. Unlike when concatenating values, the list() command in R allows each value to keep its natural type. You can access elements of a list using [] (this will extract a subset of the list items) or [[]], which will extract a single item from the list. (there will be more on this in the Indexing section below) Basic List Syntax in R x &lt;- list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3) x [[1]] [1] &quot;a&quot; [[2]] [1] &quot;b&quot; [[3]] [1] &quot;c&quot; [[4]] [1] 1 [[5]] [1] 2 [[6]] [1] 3 x[[3]] [1] &quot;c&quot; x[[4]] + x[[5]] [1] 3 x[1:2] # This will work [[1]] [1] &quot;a&quot; [[2]] [1] &quot;b&quot; x[[1:2]] # This won&#39;t work Error in x[[1:2]]: subscript out of bounds The lego version of a list looks like this: Figure 2.2: A list of 4 vectors. Even though the vectors in the list are all the same size in this case, they don’t have to be, because they’re not organized in any sort of cohesive rectangle shape. A data frame (see below) is essentially a list where all of the components are vectors or lists of the same length. Indexing in Lists Some lists (and data frames) consist of named variables. These list components can be accessed either by index (as above) or by name, using the $ operator. Names which have spaces or special characters must be enclosed in backticks (next to the 1 on the keyboard). Named components can also be accessed using the [[ ]] operator. dog &lt;- list(name = &quot;Edison Vanderplas&quot;, age = 8, breed = &quot;Jack Russell Terrorist&quot;, `favorite toy` = &quot;a blue and orange stuffed duck. Or rawhide.&quot;, `link(video)` = &quot;https://youtu.be/zVeoQTOTIuQ&quot;) dog $name [1] &quot;Edison Vanderplas&quot; $age [1] 8 $breed [1] &quot;Jack Russell Terrorist&quot; $`favorite toy` [1] &quot;a blue and orange stuffed duck. Or rawhide.&quot; $`link(video)` [1] &quot;https://youtu.be/zVeoQTOTIuQ&quot; dog$name [1] &quot;Edison Vanderplas&quot; dog$breed [1] &quot;Jack Russell Terrorist&quot; dog$`favorite toy` [1] &quot;a blue and orange stuffed duck. Or rawhide.&quot; dog[[&quot;link(video)&quot;]] [1] &quot;https://youtu.be/zVeoQTOTIuQ&quot; You can get a sense of the structure of a list (or any other object) in R using the str() command. str(dog) List of 5 $ name : chr &quot;Edison Vanderplas&quot; $ age : num 8 $ breed : chr &quot;Jack Russell Terrorist&quot; $ favorite toy: chr &quot;a blue and orange stuffed duck. Or rawhide.&quot; $ link(video) : chr &quot;https://youtu.be/zVeoQTOTIuQ&quot; Recursive lists Lists can also contain other lists. When accessing a list-within-a-list, just add another index or name reference (see below). grocery_list &lt;- list( dairy = list(&quot;asiago&quot;, &quot;fontina&quot;, &quot;mozzarella&quot;, &quot;blue cheese&quot;), baking = list(&quot;flour&quot;, &quot;yeast&quot;, &quot;salt&quot;), canned_goods = list(&quot;pepperoni&quot;, &quot;pizza sauce&quot;, &quot;olives&quot;), meat = list(&quot;bacon&quot;, &quot;sausage&quot;, &quot;anchovies&quot;), veggies = list(&quot;bell pepper&quot;, &quot;onion&quot;, &quot;scallions&quot;, &quot;tomatoes&quot;, &quot;basil&quot;) ) ick &lt;- c(grocery_list[[4]][2:3], grocery_list$canned_goods[[3]]) ick [[1]] [1] &quot;sausage&quot; [[2]] [1] &quot;anchovies&quot; [[3]] [1] &quot;olives&quot; crust_ingredients &lt;- c(grocery_list$baking, &quot;water&quot;) crust_ingredients [[1]] [1] &quot;flour&quot; [[2]] [1] &quot;yeast&quot; [[3]] [1] &quot;salt&quot; [[4]] [1] &quot;water&quot; essential_toppings &lt;- c(grocery_list$dairy[3], grocery_list$canned_goods[2]) essential_toppings [[1]] [1] &quot;mozzarella&quot; [[2]] [1] &quot;pizza sauce&quot; yummy_toppings &lt;- c(grocery_list$dairy[c(1, 2, 4)], grocery_list$meat[1], grocery_list[[5]][c(3, 5)]) yummy_toppings [[1]] [1] &quot;asiago&quot; [[2]] [1] &quot;fontina&quot; [[3]] [1] &quot;blue cheese&quot; [[4]] [1] &quot;bacon&quot; [[5]] [1] &quot;scallions&quot; [[6]] [1] &quot;basil&quot; Basic List Syntax in SAS There are also lists in SAS IML which function similarly to lists in R. To create a named object in a list, precede the name with #. In SAS, the $ operator can be used to get items from a list, using either name or numeric references. 6 7 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 8 grocery_list = [ 9 #dairy = [&quot;asiago&quot;, &quot;fontina&quot;, &quot;mozzarella&quot;, &quot;blue 9 ! cheese&quot;], 10 #baking = [&quot;flour&quot;, &quot;yeast&quot;, &quot;salt&quot;], 11 #canned = [&quot;pepperoni&quot;, &quot;pizza sauce&quot;, &quot;olives&quot;], 12 #meat = [&quot;bacon&quot;, &quot;sausage&quot;, &quot;anchovies&quot;], 13 #veggies= [&quot;bell pepper&quot;, &quot;onion&quot;, &quot;scallions&quot;, &quot;tomatoes&quot;, 13 ! &quot;basil&quot;] 14 ]; 15 16 /* print only works on matrices and vectors */ 17 /* so we&#39;ll cheat and load another library to print lists */ 18 19 package load ListUtil; 20 21 /* run ListPrint(grocery_list); */ 22 /* This would print the thing, but it&#39;s long */ 23 24 ick = [grocery_list$&quot;canned&quot;$3, grocery_list$4$2, 24 ! grocery_list$4$3]; 25 crust = grocery_list$&quot;baking&quot;; 26 call ListAddItem(crust, &quot;water&quot;); 26 ! /* add an item to a list */ 27 essential_toppings = [grocery_list$&quot;dairy&quot;$3, 27 ! grocery_list$&quot;canned&quot;$2]; 28 yummy_toppings = [grocery_list$&quot;dairy&quot;$1, 28 ! grocery_list$&quot;dairy&quot;$2, 29 grocery_list$&quot;dairy&quot;$4, grocery_list$&quot;meat&quot;$1, 29 ! grocery_list$5$3] ; 30 /* The || is a concatenation operator, like c(). */ 31 /* It is inefficient for large data sets */ 32 33 run ListPrint(ick); 34 run ListPrint(crust); 35 run ListPrint(yummy_toppings); 36 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 37 ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,41. Try it out Using the list of pizza toppings above as a starting point, make your own list of pizza toppings organized by grocery store section (approximately). Create your own vectors of yummy, essential, and ick toppings, using R and SAS. 2.3.2.2 Data frames (R only) A data frame is a special type of list - one in which each element in the list is a vector of the same length. If you put these vectors side-by-side, you get a table of data that looks like a spreadsheet. The lego version of a data frame looks like this: Figure 2.3: A data frame with data frame 4 columns. A data frame is essentially a list where all of the components are vectors or lists, and are constrained to have the same length. Basic Data Frame Syntax When you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The head() command shows the first 6 rows of a data frame (enough to see what’s there, not enough to overflow your screen). head(mtcars) ## A data frame included in base R mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 str(mtcars) &#39;data.frame&#39;: 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... $ disp: num 160 160 108 258 360 ... $ hp : num 110 110 93 110 175 105 245 62 95 123 ... $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... $ wt : num 2.62 2.88 2.32 3.21 3.44 ... $ qsec: num 16.5 17 18.6 19.4 17 ... $ vs : num 0 0 1 1 0 1 0 1 1 1 ... $ am : num 1 1 1 0 0 0 0 0 0 0 ... $ gear: num 4 4 4 3 3 3 3 4 4 4 ... $ carb: num 4 4 1 1 2 1 4 2 2 4 ... You can change column values or add new columns easily using assignment. It’s also easy to access specific columns to perform summary operations. mtcars$gpm &lt;- 1/mtcars$mpg # gpm is sometimes used to assess efficiency summary(mtcars$gpm) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.02950 0.04386 0.05208 0.05423 0.06483 0.09615 summary(mtcars$mpg) Min. 1st Qu. Median Mean 3rd Qu. Max. 10.40 15.43 19.20 20.09 22.80 33.90 Often, it is useful to know the dimensions of a data frame. The number of rows can be obtained by using nrow(df) and similarly, the columns can be obtained using ncol(df) (or, get both with dim()). There is also an easy way to get a summary of each column in the data frame, using summary(). summary(mtcars) mpg cyl disp hp Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 Median :19.20 Median :6.000 Median :196.3 Median :123.0 Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 drat wt qsec vs Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 Median :3.695 Median :3.325 Median :17.71 Median :0.0000 Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 am gear carb gpm Min. :0.0000 Min. :3.000 Min. :1.000 Min. :0.02950 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 1st Qu.:0.04386 Median :0.0000 Median :4.000 Median :2.000 Median :0.05208 Mean :0.4062 Mean :3.688 Mean :2.812 Mean :0.05423 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 3rd Qu.:0.06483 Max. :1.0000 Max. :5.000 Max. :8.000 Max. :0.09615 dim(mtcars) [1] 32 12 nrow(mtcars) [1] 32 ncol(mtcars) [1] 12 Missing variables in an R data frame are indicated with NA. Creating an R data frame math_and_lsd &lt;- data.frame(lsd_conc = c(1.17, 2.97, 3.26, 4.69, 5.83, 6.00, 6.41), test_score = c(78.93, 58.20, 67.47, 37.47, 45.65, 32.92, 29.97)) math_and_lsd lsd_conc test_score 1 1.17 78.93 2 2.97 58.20 3 3.26 67.47 4 4.69 37.47 5 5.83 45.65 6 6.00 32.92 7 6.41 29.97 # add a column - character vector math_and_lsd$subjective &lt;- c(&quot;finally coming back&quot;, &quot;getting better&quot;, &quot;it&#39;s totally better&quot;, &quot;really tripping out&quot;, &quot;is it over?&quot;, &quot;whoa, man&quot;, &quot;I can taste color, but I can&#39;t do math&quot;) math_and_lsd lsd_conc test_score subjective 1 1.17 78.93 finally coming back 2 2.97 58.20 getting better 3 3.26 67.47 it&#39;s totally better 4 4.69 37.47 really tripping out 5 5.83 45.65 is it over? 6 6.00 32.92 whoa, man 7 6.41 29.97 I can taste color, but I can&#39;t do math Try it out The dataset state.x77 contains information on US state statistics in the 1970s. By default, it is a matrix, but we can easily convert it to a data frame, as shown below. data(state) state_facts &lt;- data.frame(state.x77) state_facts &lt;- cbind(state = row.names(state_facts), state_facts, stringsAsFactors = F) # State names were stored as row labels # Store them in a variable instead, and add it to the data frame row.names(state_facts) &lt;- NULL # get rid of row names head(state_facts) state Population Income Illiteracy Life.Exp Murder HS.Grad Frost Area 1 Alabama 3615 3624 2.1 69.05 15.1 41.3 20 50708 2 Alaska 365 6315 1.5 69.31 11.3 66.7 152 566432 3 Arizona 2212 4530 1.8 70.55 7.8 58.1 15 113417 4 Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 51945 5 California 21198 5114 1.1 71.71 10.3 62.6 20 156361 6 Colorado 2541 4884 0.7 72.06 6.8 63.9 166 103766 How many rows and columns does it have? Can you find at least 3 ways to get that information? The Illiteracy column contains the percent of the population of each state that is illiterate. Calculate the number of people in each state who are illiterate, and store that in a new column called TotalNumIlliterate. Note: Population contains the population in thousands. Calculate the average population density of each state (population per square mile) and store it in a new column PopDensity. Using the R reference card, can you find functions that you can combine to get the state with the minimum population density? Solutions # 3 ways to get rows and columns str(state_facts) &#39;data.frame&#39;: 50 obs. of 9 variables: $ state : chr &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ... $ Population: num 3615 365 2212 2110 21198 ... $ Income : num 3624 6315 4530 3378 5114 ... $ Illiteracy: num 2.1 1.5 1.8 1.9 1.1 0.7 1.1 0.9 1.3 2 ... $ Life.Exp : num 69 69.3 70.5 70.7 71.7 ... $ Murder : num 15.1 11.3 7.8 10.1 10.3 6.8 3.1 6.2 10.7 13.9 ... $ HS.Grad : num 41.3 66.7 58.1 39.9 62.6 63.9 56 54.6 52.6 40.6 ... $ Frost : num 20 152 15 65 20 166 139 103 11 60 ... $ Area : num 50708 566432 113417 51945 156361 ... dim(state_facts) [1] 50 9 nrow(state_facts) [1] 50 ncol(state_facts) [1] 9 # Illiteracy state_facts$TotalNumIlliterate &lt;- state_facts$Population * 1e3 * (state_facts$Illiteracy/100) # Population Density state_facts$PopDensity &lt;- state_facts$Population * 1e3/state_facts$Area # in people per square mile # minimum population state_facts$state[which.min(state_facts$PopDensity)] [1] &quot;Alaska&quot; Advanced Data Frames: Tibbles and List-columns If at this point you’re bored because you’ve seen this material before, keep reading to find out about tibbles, list columns and other ways to make data frames even more powerful. A tibble is a fancy data frame that is optimized to work with the tidyverse, which is a collection of R packages that make data wrangling (getting the data clean and ready for analysis) easier. You can read about tibbles here. You like data frames? Lists? Let’s put some lists inside a data frame! (All about list columns) Let’s start with the lego picture: (The full explanation is available in slide form here). A list is just another object that could be stored in a data frame! It is a “generalized vector” in that each entry in a list can be thought of as another list - so a list is really a vector of lists. List-columns make it possible to store e.g. whole data sets in a nested, organized way. Another useful feature is that each entry in a list-column doesn’t have to be the same length, which makes it easier to store “ragged” data. You can see a couple of examples here (but they assume that you know things that you’ll only learn in a few modules). It is worth coming back to this link later in the book. I will try to remind you. Data Sets (SAS) The SAS data set structure is similar to a R data frame. In SAS, missing values are indicated with . SAS datasets also come with a description which is attached to the table. The descriptor portion of the data set records names of variables (and attributes), numbers of observations, and date/time stamps of creation and updates. Creating a SAS data set In the next code chunk, we’ll create a data set using a SAS Data step. We’ll talk more about the anatomy of a SAS command later, but for now, notice that I’m specifying some metadata (the title), telling SAS what the variable names are (Drugs, Score), and then providing some data (indicated by the datalines statement). 6 /* Data source: http://blog.yhat.com/posts/7-funny-datasets.html 6 ! */ 7 8 data mathLSD; 9 title &#39;Average math test scores under the influence of LSD&#39;; 10 input Drugs Score; 11 datalines; NOTE: The data set WORK.MATHLSD has 0 observations and 2 variables. WARNING: Data set WORK.MATHLSD was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 19 ; 20 21 /* Describe the dataset */ 22 proc datasets; 23 contents data = mathLSD; 24 run; 25 NOTE: PROCEDURE DATASETS used (Total process time): real time 0.01 seconds cpu time 0.02 seconds 26 proc print data = mathLSD; 27 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,41. Average math test scores under the influence of LSD Directory Libref WORK Engine V9 Physical Name /tmp/SAS_work966F000B5724_silicon Filename /tmp/SAS_work966F000B5724_silicon Inode Number 11275497 Access Permission rwx—— Owner Name susan File Size 4KB File Size (bytes) 4096 # Name Member Type File Size Last Modified 1 A DATA 128KB 04/26/2021 15:37:05 2 AGEMEANS DATA 128KB 04/26/2021 15:37:05 3 AGEMEANST DATA 128KB 04/26/2021 15:37:05 4 CATS DATA 128KB 04/26/2021 15:37:05 5 COLLEGENAME DATA 128KB 04/26/2021 15:37:05 6 COLLEGETMP DATA 128KB 04/26/2021 15:37:05 7 DIS_LONG DATA 128KB 04/26/2021 15:37:05 8 DUCKS DATA 128KB 04/26/2021 15:37:05 9 FBITMP DATA 128KB 04/26/2021 15:37:06 10 FORMATS CATALOG 20KB 04/26/2021 15:37:05 11 GAS_PRICES DATA 128KB 04/26/2021 15:37:05 12 GAS_RAW DATA 128KB 04/26/2021 15:37:05 13 HIVTMP DATA 256KB 04/26/2021 15:37:05 14 INFO DATA 128KB 04/26/2021 15:37:05 15 INNER DATA 128KB 04/26/2021 15:37:05 16 LEFT DATA 128KB 04/26/2021 15:37:05 17 MATHLSD DATA 128KB 04/26/2021 15:37:05 18 MESODATA DATA 128KB 04/26/2021 15:37:05 19 OUTER DATA 128KB 04/26/2021 15:37:05 20 POKETMP DATA 128KB 04/26/2021 15:37:06 21 PRESENTS DATA 128KB 04/26/2021 15:37:05 22 PV DATA 144KB 04/26/2021 15:37:05 23 PVTMP DATA 176KB 04/26/2021 15:37:05 24 RIGHT DATA 128KB 04/26/2021 15:37:05 25 SANTA DATA 128KB 04/26/2021 15:37:05 26 SASMAC3 CATALOG 20KB 04/26/2021 15:37:06 27 SET1 DATA 128KB 04/26/2021 15:37:05 28 SET2 DATA 128KB 04/26/2021 15:37:05 29 SPLIT2 DATA 128KB 04/26/2021 15:37:05 30 SPLIT_LONG1 DATA 128KB 04/26/2021 15:37:05 31 SPLIT_LONG2 DATA 128KB 04/26/2021 15:37:05 32 SQUIRRELCOLOR DATA 128KB 04/26/2021 15:37:05 33 STRINGS DATA 128KB 04/26/2021 15:37:05 34 SUM_X DATA 128KB 04/26/2021 15:37:05 35 T1 DATA 128KB 04/26/2021 15:37:05 36 T2 DATA 128KB 04/26/2021 15:37:05 37 TABLE2 DATA 128KB 04/26/2021 15:37:05 38 TABLE2TMP DATA 128KB 04/26/2021 15:37:05 39 TABLE3 DATA 128KB 04/26/2021 15:37:05 40 TABLE3SPLIT DATA 128KB 04/26/2021 15:37:05 41 TABLE4 DATA 128KB 04/26/2021 15:37:05 42 TABLE4A DATA 128KB 04/26/2021 15:37:05 43 TABLE4ATMP DATA 128KB 04/26/2021 15:37:05 44 TABLE4B DATA 128KB 04/26/2021 15:37:05 45 TABLE4BTMP DATA 128KB 04/26/2021 15:37:05 46 TABLE4CLEAN DATA 128KB 04/26/2021 15:37:05 47 TABLE4TMP DATA 128KB 04/26/2021 15:37:05 48 TABLE5 DATA 128KB 04/26/2021 15:37:05 49 TABLE5SPLIT DATA 128KB 04/26/2021 15:37:05 50 TMP DATA 128KB 04/26/2021 15:37:05 51 TMPFLY DATA 128KB 04/26/2021 15:37:05 52 TMPSUM DATA 128KB 04/26/2021 15:37:05 53 WATER1 DATA 128KB 04/26/2021 15:37:05 54 WATER2 DATA 128KB 04/26/2021 15:37:05 55 WHO_DIS_TMP DATA 128KB 04/26/2021 15:37:05 56 XY DATA 128KB 04/26/2021 15:37:05 Koch Snowflake Average math test scores under the influence of LSD Data Set Name WORK.MATHLSD Observations 7 Member Type DATA Variables 2 Engine V9 Indexes 0 Created 04/26/2021 15:37:06 Observation Length 16 Last Modified 04/26/2021 15:37:06 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 1 First Data Page 1 Max Obs per Page 4061 Obs in First Data Page 7 Number of Data Set Repairs 0 Filename /tmp/SAS_work966F000B5724_silicon/mathlsd.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 11275515 Access Permission rw-rw-r– Owner Name susan File Size 128KB File Size (bytes) 131072 Alphabetic List of Variables and Attributes # Variable Type Len 1 Drugs Num 8 2 Score Num 8 Koch Snowflake The last two blocks are SAS procedures (PROCs). In the first block, I’m asking SAS to describe the contents of the mathMJ dataset. In the second block, I’m telling SAS to print the whole mathMJ dataset out. 2.3.3 Indexing The 1, 2, and multi-dimensional homogeneous data types should be familiar from e.g. linear algebra and calculus. Single elements of a vector can be extracted using single square brackets, e.g. x[1] will get the first element of the vector x. In a matrix, elements are indexed as row, column, so to get the (2, 2) entry of a matrix x, you would use x[2,2]. This is extended for multi-dimensional arrays in R, with each dimension added, e.g. x[3,1,2] or x[4, 3, 2, 1]. To get a full row or column from a matrix (in both SAS and R) you would use x[1,] (get the first row) or x[,3] (get the 3rd column). To select multiple rows or columns from a matrix, you would use x[, c(1, 3)] in R or x[,{1 3}] in SAS - both options get the first and third column of the matrix, with all rows of data included. In both R and SAS, a:b where a and b are numbers will form a sequence from a to b by 1s. So 1:4 is 1, 2, 3, 4. This is often used to get a set of rows or columns: x[3:4, 1:2]. R matrix example x &lt;- matrix(1:20, nrow = 5, byrow = T) # Create a matrix with values 1 to 20, 5 rows, and fill by row x [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 [4,] 13 14 15 16 [5,] 17 18 19 20 x[3:4, 1:2] [,1] [,2] [1,] 9 10 [2,] 13 14 # Gets a submatrix SAS matrix example In SAS, the same basic code works (though matrix definition is a bit more manual). 2 proc iml; /* Interactive Matrix Language */ NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 3 x = {1 2 3 4 5, 6 7 8 9 10, 11 12 13 14 15, 16 17 18 19 20}; 4 y = x[3:4, 1:2]; 5 print x; 5 ! /* Here, print is used instead of put */ 6 print y; 7 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 7 ! /* exit proc IML */ ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,43. The SAS System 1 15:37 Monday, April 26, 2021 --------- List = ick--------- Item 1 olives Item 2 sausage Item 3 anchovies --------- List = crust--------- Item 1 flour Item 2 yeast Item 3 salt Item 4 water --------- List = yummy_toppings--------- Item 1 asiago Item 2 fontina The SAS System 2 15:37 Monday, April 26, 2021 Item 3 blue cheese Item 4 bacon Item 5 scallions Average math test scores under the influence of LSD 3 15:37 Monday, April 26, 2021 The DATASETS Procedure Data Set Name WORK.MATHLSD Observations 7 Member Type DATA Variables 2 Engine V9 Indexes 0 Created 04/26/2021 15:37:07 Observation Length 16 Last Modified 04/26/2021 15:37:07 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 1 First Data Page 1 Max Obs per Page 4061 Obs in First Data Page 7 Number of Data Set Repairs 0 Filename /tmp/SAS_work3C24000B5838_ silicon/mathlsd.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 11275515 Access Permission rw-rw-r-- Owner Name susan File Size 128KB File Size (bytes) 131072 Alphabetic List of Variables and Attributes # Variable Type Len 1 Drugs Num 8 2 Score Num 8 Average math test scores under the influence of LSD 4 15:37 Monday, April 26, 2021 Obs Drugs Score 1 1.17 78.93 2 2.97 58.20 3 3.26 67.47 4 4.69 37.47 5 5.83 45.65 6 6.00 32.92 7 6.41 29.97 Average math test scores under the influence of LSD 5 15:37 Monday, April 26, 2021 x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 y 11 12 16 17 Average math test scores under the influence of LSD 6 15:37 Monday, April 26, 2021 Obs _TYPE_ _FREQ_ x 1 0 466 233168 Average math test scores under the influence of LSD 7 15:37 Monday, April 26, 2021 Obs name status present 1 Edison nice toy 2 Alex naughty coal 3 Susan toy 4 Ryan neutral toy Fundamental Step in the Koch Snowflake Construction 8 15:37 Monday, April 26, 2021 The CONTENTS Procedure Data Set Name CLASSDAT.SQUIRREL Observations 3023 Member Type DATA Variables 36 Engine V9 Indexes 0 Created 04/21/2021 11:42:03 Observation Length 656 Last Modified 04/21/2021 11:42:03 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 31 First Data Page 1 Max Obs per Page 99 Obs in First Data Page 89 Number of Data Set Repairs 0 Filename /home/susan/Projects/Class/unl-stat850/ stat850-textbook/sas/squirrel.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 39064960 Access Permission rw-rw-r-- Owner Name susan File Size 2MB File Size (bytes) 2097152 Alphabetic List of Variables and Attributes # Variable Type Len Format Informat 14 Above_Ground_Sighter_Measurement Char 5 $5. $5. 8 Age Char 8 $8. $8. 27 Approaches Char 5 $5. $5. 34 Borough_Boundaries Num 8 BEST12. BEST32. 17 Chasing Char 5 $5. $5. 35 City_Council_Districts Num 8 BEST12. BEST32. 18 Climbing Char 5 $5. $5. 12 Color_notes Char 110 $110. $110. 11 Combination_of_Primary_and_Highl Char 29 $29. $29. 33 Community_Districts Num 8 BEST12. BEST32. 6 Date Num 8 BEST12. BEST32. 19 Eating Char 5 $5. $5. 20 Foraging Char 5 $5. $5. 4 Hectare Char 3 $3. $3. 7 Hectare_Squirrel_Number Num 8 BEST12. BEST32. 10 Highlight_Fur_Color Char 24 $24. $24. Koch Snowflake Fundamental Step in the Koch Snowflake Construction 9 15:37 Monday, April 26, 2021 The CONTENTS Procedure Alphabetic List of Variables and Attributes # Variable Type Len Format Informat 28 Indifferent Char 5 $5. $5. 22 Kuks Char 5 $5. $5. 31 Lat_Long Char 45 $45. $45. 13 Location Char 12 $12. $12. 24 Moans Char 5 $5. $5. 21 Other_Activities Char 134 $134. $134. 30 Other_Interactions Char 70 $70. $70. 36 Police_Precincts Num 8 BEST12. BEST32. 9 Primary_Fur_Color Char 8 $8. $8. 23 Quaas Char 5 $5. $5. 16 Running Char 5 $5. $5. 29 Runs_from Char 5 $5. $5. 5 Shift Char 2 $2. $2. 15 Specific_Location Char 58 $58. $58. 25 Tail_flags Char 5 $5. $5. 26 Tail_twitches Char 5 $5. $5. 3 Unique_Squirrel_ID Char 14 $14. $14. 1 X Num 8 BEST12. BEST32. 2 Y Num 8 BEST12. BEST32. 32 Zip_Codes Char 1 $1. $1. Koch Snowflake Average math test scores under the influence of LSD 10 15:37 Monday, April 26, 2021 The DATASETS Procedure Data Set Name WORK.MATHLSD Observations 7 Member Type DATA Variables 2 Engine V9 Indexes 0 Created 04/26/2021 15:37:07 Observation Length 16 Last Modified 04/26/2021 15:37:07 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 1 First Data Page 1 Max Obs per Page 4061 Obs in First Data Page 7 Number of Data Set Repairs 0 Filename /tmp/SAS_work3C24000B5838_ silicon/mathlsd.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 11275515 Access Permission rw-rw-r-- Owner Name susan File Size 128KB File Size (bytes) 131072 Alphabetic List of Variables and Attributes # Variable Type Len 1 Drugs Num 8 2 Score Num 8 Koch Snowflake Both R and SAS are 1-indexed languages, so the elements of a list or vector are indexed as 1, 2, 3, 4, …4 As R has logical vectors, it is possible to index a vector using a logical vector of the same length. Try it out (From project Euler) If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. Hint: The modulo operator, %%, gives the integer remainder of one number divided by another. So a %% b gives the integer remainder when dividing a by b. Modular division is often used to find multiples of a number. R solution x &lt;- 1:999 # all nums below 1000 m3 &lt;- (x %% 3) == 0 # multiple of 3 m5 &lt;- (x %% 5) == 0 # multiple of 5 m3or5 &lt;- m3 | m5 sum(x[m3or5]) [1] 233168 SAS solution 6 data tmp; 7 do x = 1 to 999; 8 output; 9 end; 10 run; NOTE: The data set WORK.TMP has 0 observations and 1 variables. WARNING: Data set WORK.TMP was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 11 12 proc summary data=tmp; /* Summarize data */ 13 where (mod(x, 3) = 0) | (mod(x, 5) = 0); 14 /* Keep only obs where x is divisible by 3 or 5 */ 15 16 var x; /* what variable we want the summary for */ 17 18 output out=sum_x sum=; /* output sum_x to a new dataset */ 19 run; NOTE: The SAS System stopped processing this step because of errors. WARNING: The data set WORK.SUM_X may be incomplete. When this step was stopped there were 0 observations and 0 variables. WARNING: Data set WORK.SUM_X was not replaced because this step was stopped. NOTE: PROCEDURE SUMMARY used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 20 21 proc print data = sum_x; /* print our sum_x dataset */ 22 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,43. Note on the SAS code: where statements allow you to select part of the data for further processing. There was a note earlier about the fact that type conversion doesn’t happen in where clauses… this is one of those clauses. We’ll get into where clauses in more detail later, in module 5. Most complicated structures in R are actually lists underneath. You should be able to access any of the pieces of a list using a combination of named references and indexing. If you have trouble distinguishing between $, [, and [[, you’re not alone. The R for Data Science book has an excellent illustration, which I will summarize for you here in abbreviated form (pictures directly lifted from the book). R4DS indexing illustration x x[1] x[[1]] x[[1]][[1]] 2.4 Control structures 2.4.1 If statements If statements are just about as simple in programming as they are in real life. Figure 2.4: Source. I’ve actually met some programmers who talk like this in real life. General structure of an if statement In general, the structure of an if statement is if (condition) then { # do something here } If the condition is true, the inner code will be executed. Otherwise, nothing happens. You can add an else statement that will execute if the condition is not true if (condition) then { # do something } else { # do a different thing } And in some languages, you can even have many sets of if statements: if (condition) { # do something } else if (condition 2) { # do something else } else { # do a third thing } Note that this could also be written (perhaps more clearly) as: if (condition) { # do something } else { if (condition 2) { # do something else } else { # do a third thing } } That is, condition 2 is only checked once it is known that condition is false. Often, programmers use logic flow maps, like the one shown below, to map out a logical sequence and ensure that every possible value is handled appropriately. Example: If/then logic in SAS and R The syntax for conditional statements using if/then logic is shown below using an example where Santa must determine which members of a household will receive a toy for Christmas and which members will receive coal.5 In R tmp &lt;- data.frame(name = c(&quot;Alex&quot;, &quot;Edison&quot;, &quot;Susan&quot;, &quot;Ryan&quot;), status = c(&quot;naughty&quot;, &quot;nice&quot;, NA, &quot;neutral&quot;), stringsAsFactors = F) # Santa&#39;s decision process if (tmp$status == &quot;naughty&quot;) { tmp$present &lt;- &quot;coal&quot; } else { tmp$present &lt;- &quot;toy&quot; } Warning in if (tmp$status == &quot;naughty&quot;) {: the condition has length &gt; 1 and only the first element will be used tmp name status present 1 Alex naughty coal 2 Edison nice coal 3 Susan &lt;NA&gt; coal 4 Ryan neutral coal What happened? When evaluating if statements, R does not evaluate each entry in the vector tmp$status separately. Instead, it takes the first value and issues a warning message. One option would be to use a loop, and examine each row in the data set separately. We’ll talk about loops in the next subsection. Another option is to use the ifelse() function, which is ifelse(condition, thing to do if condition is true, thing to do if condition is false) tmp$present &lt;- ifelse(tmp$status == &quot;naughty&quot;, &quot;coal&quot;, &quot;toy&quot;) tmp name status present 1 Alex naughty coal 2 Edison nice toy 3 Susan &lt;NA&gt; &lt;NA&gt; 4 Ryan neutral toy When R evaluates a missing value, (so ? NA == “naughty”), the result is NA. This is fine for us - if we don’t have data on whether someone is naughty or nice, maybe we don’t need to give them a present at all. But “neutral” is evaluated as getting a toy. Do we want that to happen? Maybe not. We might have to nest ifelse statements to solve this issue… tmp$present &lt;- ifelse(tmp$status == &quot;naughty&quot;, &quot;coal&quot;, ifelse(tmp$status == &quot;nice&quot;, &quot;toy&quot;, NA)) tmp name status present 1 Alex naughty coal 2 Edison nice toy 3 Susan &lt;NA&gt; &lt;NA&gt; 4 Ryan neutral &lt;NA&gt; In SAS In a data step: 6 data santa; 7 input name $ status $; 8 datalines; NOTE: The data set WORK.SANTA has 0 observations and 2 variables. WARNING: Data set WORK.SANTA was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 13 ; 14 15 /* Modify santa_list and make a new dataset, present_list */ 16 data presents; 17 set santa; 18 if status = &quot;naughty&quot; then present = &quot;coal&quot;; 19 else present = &quot;toy&quot;; 20 run; NOTE: The data set WORK.PRESENTS has 0 observations and 3 variables. WARNING: Data set WORK.PRESENTS was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 20 ! /* must end with run if no datalines option */ 21 22 proc print data=presents; 23 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,43. Note that ., or missing data is handled the same as ‘nice.’ That might not be what we wanted… this is the natural thing to do, right? 6 data santa; 7 input name $ status $; 8 datalines; NOTE: The data set WORK.SANTA has 0 observations and 2 variables. WARNING: Data set WORK.SANTA was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 13 ; 14 15 /* Modify santa_list and make a new dataset, present_list */ 16 data presents; 17 set santa; 18 if status = &quot;naughty&quot; then present = &quot;coal&quot;; 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = ______ 22 19 ! .); ERROR: Undeclared array referenced: else. 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = ____ 388 19 ! .); ERROR 22-322: Syntax error, expecting one of the following: !, !!, &amp;, (, *, **, +, &#39;,&#39;, -, /, &lt;, &lt;=, &lt;&gt;, =, &gt;, &gt;&lt;, &gt;=, AND, EQ, GE, GT, IN, LE, LT, MAX, MIN, NE, NG, NL, NOTIN, OR, [, ^=, {, |, ||, ~=. ERROR 388-185: Expecting an arithmetic operator. 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = ____ 202 19 ! .); ERROR 202-322: The option or parameter is not recognized and will be ignored. 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = ____ 388 19 ! .); ERROR 388-185: Expecting an arithmetic operator. 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = ____ 202 19 ! .); ERROR 202-322: The option or parameter is not recognized and will be ignored. 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = 19 ! .); _ 22 ERROR 22-322: Syntax error, expecting one of the following: +, =. 19 else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = 19 ! .); _ 76 ERROR 76-322: Syntax error, statement will be ignored. 20 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 19:54 NOTE: The SAS System stopped processing this step because of errors. WARNING: The data set WORK.PRESENTS may be incomplete. When this step was stopped there were 0 observations and 4 variables. WARNING: Data set WORK.PRESENTS was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 20 ! /* must end with run if no datalines option */ 21 22 proc print data=presents; 23 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44. SAS doesn’t handle nested if statements very well - they can be ambiguous. Instead, SAS documentation suggests using do; and end; to denote the start and end points of each if statement (like the {} in R). 6 data santa; 7 input name $ status $; 8 datalines; NOTE: The data set WORK.SANTA has 0 observations and 2 variables. WARNING: Data set WORK.SANTA was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 13 ; 14 data presents; 15 set santa; 16 if status = &quot;naughty&quot; then 17 do; 18 present = &quot;coal&quot;; 19 end; 20 else if status = &quot;nice&quot; then 21 do; 22 present = &quot;toy&quot;; 23 end; 24 else 25 do; 26 present = .; 27 end; 28 run; NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column). 26:17 NOTE: The data set WORK.PRESENTS has 0 observations and 3 variables. WARNING: Data set WORK.PRESENTS was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 29 30 proc print data=presents; 31 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45. Interestingly, if you set a character variable to be missing, SAS converts it to ‘.’ So, if we actually want to have the value be missing, we can set it to an empty string. 6 data santa; 7 input name $ status $; 8 datalines; NOTE: The data set WORK.SANTA has 0 observations and 2 variables. WARNING: Data set WORK.SANTA was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.01 seconds 13 ; 14 data presents; 15 set santa; 16 if status = &quot;naughty&quot; then 17 do; 18 present = &quot;coal&quot;; 19 end; 20 else if status = &quot;nice&quot; then 21 do; 22 present = &quot;toy&quot;; 23 end; 24 else 25 do; 26 present = &#39;&#39;; 27 end; 28 run; NOTE: The data set WORK.PRESENTS has 0 observations and 3 variables. WARNING: Data set WORK.PRESENTS was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 29 30 proc print data=presents; 31 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46. Now things work the way we expected them to work. There are more complicated if-statement like control structures, such as switch statements, which can save time and typing. In the interests of simplicity, we will skip these for now, as any conditional can be implemented with sequences of if statements in the proper order. If you would like to read about switch statements, here are links to SAS case statement documentation and base R switch statement explanation and documentation. Try it out The sample() function selects a random sample of entries from a vector. Suppose we sample a random vector \\(x\\) with 10 entries. Write one or more if statements to fulfill the following conditions if \\(x\\) is divisible by 2, \\(y\\) should be positive; otherwise, it should be negative. if \\(x\\) is divisible by 3, \\(y\\) should have a magnitude of 2; otherwise, it should have a magnitude of 1. It may be helpful to define separate variables y_mag and y_sign and then multiply them afterwards. Once you have found the value of \\(y\\) compute \\(\\text{sum}(x * y)\\). You may use the following R and SAS code skeletons to set the problem up. set.seed(342502837) x &lt;- sample(1:50, size = 20, replace = F) # Conditional statements go here sum(x * y) [1] 1567.609 proc iml; call randseed(342502837); x = sample(1:50, 20)`; create sampledata from x [colname = &quot;x&quot;]; append from x; close; quit; data xy; set sampledata; /* Conditional statements go here */ /* Leave this so that the code below works */ res = x * y; run; proc summary data=xy; /* Summarize data */ var res; /* what variable we want the summary for */ output out=tmpsum sum=; /* output tmpsum to a new dataset */ run; proc print data = xy; /* print our original dataset to check result */ var x y res; sum res; run; proc print data = tmpsum; /* print our tmpsum dataset */ run; R Solution set.seed(342502837) x &lt;- sample(1:50, size = 20, replace = F) y_sign &lt;- ifelse(x %% 2 == 0, 1, -1) y_mag &lt;- ifelse(x %% 3 == 0, 2, 1) y &lt;- y_sign * y_mag sum(x * y) [1] 157 SAS Solution 6 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 7 call randseed(342502837); 8 x = sample(1:50, 20)`; 9 create sampledata from x [colname = &quot;x&quot;]; 10 append from x; 11 close; 12 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 13 14 data xy; 15 set sampledata; ERROR: File WORK.SAMPLEDATA.DATA does not exist. 16 17 y_sign = 0 * x; 18 y_mag = 0 * x; 19 20 /* Conditional statements go here */ 21 if MOD(x, 2) = 0 then y_sign = 1; 22 else y_sign = -1; 23 if MOD(x, 3) = 0 then y_mag = 2; 24 else y_mag = 1; 25 26 y = y_sign * y_mag; 27 res = x * y; 28 run; NOTE: The SAS System stopped processing this step because of errors. WARNING: The data set WORK.XY may be incomplete. When this step was stopped there were 0 observations and 5 variables. WARNING: Data set WORK.XY was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 29 30 proc summary data=xy; /* Summarize data */ 31 var res; /* what variable we want the summary for */ 32 33 output out=tmpsum sum=; /* output tmpsum to a new dataset */ 34 run; NOTE: The SAS System stopped processing this step because of errors. WARNING: The data set WORK.TMPSUM may be incomplete. When this step was stopped there were 0 observations and 0 variables. WARNING: Data set WORK.TMPSUM was not replaced because this step was stopped. NOTE: PROCEDURE SUMMARY used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 35 36 37 proc print data = xy; /* print our original dataset to check 37 ! result */ 38 var x y res; 39 sum res; 40 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 41 42 proc print data = tmpsum; /* print our tmpsum dataset */ 43 run; NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46. See this to understand how the print statement works and how to add column summary values. 2.4.2 Loops Often, we need to do a single task many times - for instance, we may need to calculate the average data value for each week, using daily data. Rather than typing out 52 different iterations of the same code, it is likely easier to type out one single block of code which contains the steps necessary to complete one instance of the task, and then leverage variables to ensure that each task is completed the correct number of times, using the correct inputs. Let us start with the most generic loop written in pseudocode (code that won’t work, but provides the general idea of the steps which are taken) loop_invocation(iteration variable, exit condition) { # Steps to repeat } We use the loop_invocation function to indicate what type of loop we use. We have at least one iteration variable that indicates where in the looping process we currently are. This may be an index (if we want to do something 500 times, it would take values from 1 to 500), or it may take a more complicated sequence of values (for instance, if we are testing convergence, we might put some sort of delta variable as the iteration variable). Most loops also have an explicit exit condition that is part of the loop invocation; more rarely, a loop may depend on break statements that cause the control flow of the code to exit. Without some sort of exit condition, our program would run forever, which is… not optimal. 2.4.2.1 Count controlled loops (FOR loops) In a for loop, the steps in the loop body repeat a specified number of times. That is, for each value in a sequence, the steps within the loop are repeated. Example: Santa and if/else + loops in R (plus some debugging strategies) For instance, suppose we want to revisit our R Santa example from the previous section. The original if/else code we wrote in R didn’t work, because R evaluates if statements using a single (scalar or vector of length 1) condition. If we add a loop around that code, we can evaluate only one row at a time. We need to check every row, so we’ll iterate over 1:nrow(tmp) - it’s better to get the upper bound from the data frame, rather than just using 4 - if we add another entry, the code will still work if we’re using nrow(tmp) to define how many iterations we need. We start by defining our data frame: tmp &lt;- data.frame(name = c(&quot;Alex&quot;, &quot;Edison&quot;, &quot;Susan&quot;, &quot;Ryan&quot;), status = c(&quot;naughty&quot;, &quot;nice&quot;, NA, &quot;neutral&quot;), stringsAsFactors = F) And then we add the basic loop syntax: for (i in 1:nrow(tmp)) { } For some reason, i is often used as the iteration variable (with j and k for nested loops). What this loop says is that i will first take on the value 1, then 2, then 3, then 4. On each iteration, i will advance to the next value in the vector of options we have provided. Now we need to add the middle part by adapting the conditional statement we used before so that it looks at only the ith row. I’ve also added the catch-all else condition that assigns NA for any value that isn’t “naughty” or “nice.” It’s good practice to initialize your variable (create a column for it) ahead of time and set the variable to a default value. tmp$present &lt;- NA # Initialize column and set to NA by default for (i in 1:nrow(tmp)) { # Santa&#39;s decision process if (tmp$status[i] == &quot;naughty&quot;) { tmp$present[i] &lt;- &quot;coal&quot; } else if (tmp$status[i] == &quot;nice&quot;) { tmp$present[i] &lt;- &quot;toy&quot; } else { tmp$present[i] &lt;- NA_character_ # use a special NA value that has # character type to avoid any issues } } Error in if (tmp$status[i] == &quot;naughty&quot;) {: missing value where TRUE/FALSE needed Well, that didn’t work! We can see that the loop stopped at i = 3 by printing out the value of i - because the loop failed, i will still contain the value which caused the loop to stop. i [1] 3 tmp[i,] # print tmp at that point name status present 3 Susan &lt;NA&gt; &lt;NA&gt; Combining this information with the error above, we can guess that R stopped evaluating the loop because the if statement returned NA (missing) instead of TRUE or FALSE. if/else statements in R can’t evaluate to NA, so we need to restructure our conditional statement - first, we’ll test for NA values, then, we can test for naughty and nice, and we’ll keep the catch-all statement at the bottom. We’ll test for an NA value using the function is.na(). tmp$present &lt;- NA # Initialize column and set to NA by default for (i in 1:nrow(tmp)) { # Santa&#39;s decision process if (is.na(tmp$status[i])) { tmp$present[i] &lt;- NA_character_ } else if (tmp$status[i] == &quot;naughty&quot;) { tmp$present[i] &lt;- &quot;coal&quot; } else if (tmp$status[i] == &quot;nice&quot;) { tmp$present[i] &lt;- &quot;toy&quot; } else { tmp$present[i] &lt;- NA_character_ } } tmp name status present 1 Alex naughty coal 2 Edison nice toy 3 Susan &lt;NA&gt; &lt;NA&gt; 4 Ryan neutral &lt;NA&gt; Now the if/else logic works exactly as intended. This is longer than the version using ifelse(), but it is perhaps more readable. In most cases in R and SAS, it is possible to write code without needing loops at all, because both languages are vector-based - they will often use vectorized functions which implicitly loop over each row without having to write a loop to do so. ifelse() is a vectorized version of if() {} else {}. Here is an example of the most basic for loop logic - printing the numbers 1 through 10 - in both R and SAS. SAS code is provided for both PROC IML and DATA steps. For loops in R # R Example loop for (i in 1:10) { print(i) } [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 [1] 6 [1] 7 [1] 8 [1] 9 [1] 10 “For loops” in SAS IML (using do) 6 /* SAS IML example loop */ 7 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 8 do i = 1 to 10; 9 print i; 10 end; 10 ! /* This ends the loop definition */ 11 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,47. “For loops” in a SAS DATA step 6 data A; 7 do i = 1 to 10; 8 put i=; 9 end; /* This ends the loop definition */ 10 run; NOTE: The data set WORK.A has 0 observations and 1 variables. WARNING: Data set WORK.A was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,47. Another explanation of for loops is available at Khan Academy. While the most straighforward (and common) case of for-loop use in practice is to count from 1 to N, both R and SAS allow for loops to use other sequence structures. Other sequences in loops in R R allows loops to occur over any vector… even randomly generated numbers, or nonnumeric vectors (say, a character vector of URLs). x &lt;- rnorm(5) # Generate 5 normal (0,1) samples for (i in x) { print(i^2) } [1] 4.500349 [1] 3.820737 [1] 2.656216 [1] 1.120775 [1] 2.10086 We can also iterate by non-integer values using seq(from = , to = , by = ) # This loop counts down in 1/2 units from 5 to 0 for (i in seq(5, 0, -.5)) { # do nothing } Other sequence structures in SAS for loops We can iterate by non-integer values: 6 data A; 7 y = 0; 8 do i = 5 to 0 by -0.5; 9 put i=; 10 end; 11 run; NOTE: The data set WORK.A has 0 observations and 2 variables. WARNING: Data set WORK.A was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,47. We can even add additional conditions: 6 data A; 7 y = 0; 8 do i = 5 to 0 by -0.5 while (i**2 &gt; 1); 9 put i=; 10 end; 11 run; NOTE: The data set WORK.A has 0 observations and 2 variables. WARNING: Data set WORK.A was not replaced because this step was stopped. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,47. Try it out (in R) The beepr package plays sounds in R to alert you when your code has finished running (or just to annoy your friends and classmates). (Documentation) We’ll learn more about packages in the next chapter, but for now, just go with it. You can install the package using the following command: install.packages(&quot;beepr&quot;) (if you are using Linux you will also need to make sure one of paplay, aplay, or vlc is installed) Load the library and write a for loop which plays the 10 different sounds corresponding to integers 1 through 10. library(beepr) # load the beepr library beep(sound = 1) # sound is any integer between 1 and 10. It may be helpful to add the command Sys.sleep(5) into your loop to space out the noises so that they can be heard individually. Solution library(beepr) for (i in 1:10) { beep(sound = i) Sys.sleep(5) } Try it out (in SAS) Write a for loop which will output the first 30 fibbonacci numbers. You can use the following code as a starting point: 6 /* SAS IML example loop */ 7 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 8 current = 1; 9 prev = 0; 10 11 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.02 seconds 12 ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,47. Solution 6 /* SAS IML example loop */ 7 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 8 current = 1; 9 prev = 0; 10 11 do i = 1 to 30; 12 new = current + prev; 13 prev = current; 14 current = new; 15 print current; 16 end; 16 ! /* This ends the loop definition */ 17 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 18 ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,47. 2.4.2.2 Condition-controlled loops (WHILE, DO WHILE) Frequently, we do not know how many times a loop will need to execute a priori. We might be converging on a value, and want to repeat the calculation until the new value is within an acceptably epsilon of the previous iteration. In these cases, it can be helpful to use a WHILE loop, which loops while the condition is true (another variant, the do-while loop, is similar, except that a do-while loop will always execute once, and checks the condition at the end of the iteration). If a WHILE loop condition is never falsified, the loop will continue forever. Thus, it is usually wise to include a loop counter as well, and a condition to terminate the loop if the counter value is greater than a certain threshold. Example: Let’s solve the Basel problem in R and SAS using WHILE loops - we’ll repeat the calculation until the value changes by less than 0.000001. The Basel problem is the problem of calculating the precise infinite summation \\[\\sum_{n=1}^\\infty \\frac{1}{n^2}\\] We’ll stick to calculating it computationally. In R # Start out by defining your starting values outside of the loop i &lt;- 1 basel_value &lt;- 0 # initial guess prev_basel_value &lt;- -Inf # previous value while (abs(basel_value - prev_basel_value) &gt; 0.000001) { prev_basel_value &lt;- basel_value # update condition basel_value &lt;- basel_value + 1/i^2 i &lt;- i + 1 # Prevent infinite loops if (i &gt; 1e6) { break } # Monitor the loop to know that it&#39;s behaving if (i %% 200 == 0) { print(c(&#39;i = &#39; = i, &#39;prev&#39; = prev_basel_value, &#39;current&#39; = basel_value, diff = basel_value - prev_basel_value)) } } i = prev current diff 2.000000e+02 1.639896e+00 1.639922e+00 2.525189e-05 i = prev current diff 4.000000e+02 1.642425e+00 1.642431e+00 6.281368e-06 i = prev current diff 6.000000e+02 1.643263e+00 1.643266e+00 2.787060e-06 i = prev current diff 8.000000e+02 1.643682e+00 1.643683e+00 1.566414e-06 i = prev current diff 1.000000e+03 1.643933e+00 1.643934e+00 1.002003e-06 i [1] 1001 basel_value [1] 1.643935 prev_basel_value [1] 1.643934 In SAS 6 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 7 i = 1; 8 basel = 0; 9 prev = -1; 10 do while((basel - prev) &gt; 1e-6); 11 prev = basel; 12 basel = basel + 1/i**2; 12 ! /* ** is the exponent operator */ 13 i = i + 1; 14 15 if i &gt; 1e6 then 16 do; 17 leave; 18 end; 19 20 if MOD(i, 200) = 0 then 21 do; 22 print i, prev, basel; 23 end; 24 end; 25 26 print i, basel; 27 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 28 ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,48. Another explanation of while loops is available at Khan Academy. Try it out Write a while loop in R and in SAS to calculate \\(\\displaystyle \\lim_{x \\rightarrow 4} \\frac{2 - \\sqrt{x}}{4-x}\\) by starting at 3 and halving the distance to 4 with each iteration. Exit the loop when you are within 1e-6 of the value computed on the previous iteration, or when you are within 1e-6 from 4. Which exit condition did you hit first? How do you know? Solutions x &lt;- 3 dist &lt;- 4 - x current_value &lt;- 0 prev_value &lt;- -Inf while (abs(current_value - prev_value) &gt; 1e-6 &amp; dist &gt; 1e-6) { prev_value &lt;- current_value dist &lt;- dist/2 x &lt;- 4 - dist current_value &lt;- (2 - sqrt(x))/(4-x) } c(x = x, dist = dist, current_value = current_value, d_value = abs(current_value - prev_value)) x dist current_value d_value 3.999939e+00 6.103516e-05 2.500010e-01 9.536961e-07 Before \\(x\\) got to 4 - 1e-6, the change in f(x) became less than 1e-6. 6 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 7 x = 3; 8 dist = 4 - x; 9 fx = 0; 10 prev_fx = 1; 11 dfx = abs(fx - prev_fx); 12 do while(dfx &gt; 1e-6 &amp; dist &gt; 1e-6); 13 prev_fx = fx; 14 dist = dist/2; 15 x = 4 - dist; 16 fx = (2 - sqrt(x))/(4 - x); 17 dfx = abs(fx - prev_fx); 18 end; 19 20 print x, dist, fx, dfx; 21 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 22 ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,48. 2.4.2.3 Other Loops and Interative Structures There are many different ways to implement iteration in any language, including very low-level controls like repeat (in R). Higher level iteration may include a FOREACH loop, where a series of commands is applied to a list or vector (the *apply commands in R are examples of this). An additional method of iteration that requires functions is the recursion (where a function calls itself). In every case, these alternative loop structures can be translated to for or while loops. 2.5 Overgrown Calculators While R and SAS are both extremely powerful statistical programming languages, the core of both languages is the ability to do basic calculations and matrix arithmetic. As almost every dataset is stored as a matrix-like structure (data sets and data frames both allow for multiple types, which isn’t quite compatible with more canonical matrices), it is useful to know how to do matrix-level calculations in R and SAS. In this section, we will essentially be using both R and SAS as overgrown calculators. Operation R SAS Addition + + Subtraction - - Elementwise Multiplication * # Matrix/Vector Multiplication %*% * Division \\ \\ Elementwise Exponentiation ^ ## Matrix Exponentiation ^ ** Matrix Transpose t(A) `A\\`` R basic mathematical operators # transpose these to make row vectors to match SAS x &lt;- t(1:10) y &lt;- t(seq(3, 30, by = 3)) x + y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 4 8 12 16 20 24 28 32 36 40 x - y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] -2 -4 -6 -8 -10 -12 -14 -16 -18 -20 x * y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 3 12 27 48 75 108 147 192 243 300 x / y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [1,] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 [,8] [,9] [,10] [1,] 0.3333333 0.3333333 0.3333333 x^2 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 1 4 9 16 25 36 49 64 81 100 t(x) %*% y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 3 6 9 12 15 18 21 24 27 30 [2,] 6 12 18 24 30 36 42 48 54 60 [3,] 9 18 27 36 45 54 63 72 81 90 [4,] 12 24 36 48 60 72 84 96 108 120 [5,] 15 30 45 60 75 90 105 120 135 150 [6,] 18 36 54 72 90 108 126 144 162 180 [7,] 21 42 63 84 105 126 147 168 189 210 [8,] 24 48 72 96 120 144 168 192 216 240 [9,] 27 54 81 108 135 162 189 216 243 270 [10,] 30 60 90 120 150 180 210 240 270 300 SAS basic mathematical operators By default, SAS creates row vectors with do(a, b, by = c) syntax. The transpose operator (a single backtick) can be used to transform A into A`. 6 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 7 x = do(1, 10, 1); 8 y = do(3, 30, 3); 9 10 z = x + y; 11 z2 = x - y; 12 z3 = x # y; 13 z4 = x/y; 14 z5 = x##2; 15 z6 = x` * y; 16 print z, z2, z3, z4, z5, z6; 17 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,48. Other matrix operations, such as determinants and extraction of the matrix diagonal, are similarly easy: R matrix operations mat &lt;- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T) t(mat) # transpose [,1] [,2] [,3] [1,] 1 6 7 [2,] 2 4 8 [3,] 3 5 9 det(mat) # get the determinant [1] 18 diag(mat) # get the diagonal [1] 1 4 9 diag(diag(mat)) # get a square matrix with off-diag 0s [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 4 0 [3,] 0 0 9 diag(1:3) # diag() also will create a diagonal matrix if given a vector [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 2 0 [3,] 0 0 3 SAS matrix operations 6 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 7 mat = {1 2 3, 6 4 5, 7 8 9}; 8 tmat = mat`; 8 ! /* transpose */ 9 determinant = det(mat); 9 ! /* get the determinant */ 10 diagonal_vector = vecdiag(mat); 10 ! /* get the diagonal as a 10 ! vector */ 11 diagonal_mat = diag(mat); 11 ! /* get the diagonal as a square 11 ! matrix */ 12 /* with 0 on off-diagonal entries */ 13 14 dm = diag({1 2 3}); 14 ! /* make a square matrix with vector as the 14 ! diagonal */ 15 16 print tmat, determinant, diagonal_vector, diagonal_mat, dm; 17 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,48. The other important matrix-related function is the inverse. In R, A^-1 will get you the elementwise reciprocal of the matrix. Not exactly what we’d like to see… Instead, in both languages, we use the solve() function. The inverse is defined as the matrix B such that AB = I where I is the identity matrix (1’s on diagonal, 0’s off-diagonal). So if we solve(A) (in R) or solve(A, diag(n)) in SAS (where n is a vector of 1s the size of A), we will get the inverse matrix. Invert a matrix in R mat &lt;- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T) minv &lt;- solve(mat) # get the inverse minv [,1] [,2] [,3] [1,] -0.2222222 0.3333333 -0.1111111 [2,] -1.0555556 -0.6666667 0.7222222 [3,] 1.1111111 0.3333333 -0.4444444 mat %*% minv [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 1 0 [3,] 0 0 1 Invert a matrix in SAS Documentation 6 proc iml; NOTE: IML Ready WARNING: IML is now in syntax-check-only mode due to errors in previous steps. No statements will be executed. 7 mat = {1 2 3, 6 4 5, 7 8 9}; 8 9 mat_inv = solve(mat, diag({1 1 1})); 9 ! /* get the inverse */ 10 mat_inv2 = inv(mat); 10 ! /* less efficient and less accurate */ 11 print mat_inv, mat_inv2; 12 13 id = mat * mat_inv; 14 id2 = mat * mat_inv2; 15 print id, id2; 16 quit; NOTE: Exiting IML. NOTE: PROCEDURE IML used (Total process time): real time 0.00 seconds cpu time 0.00 seconds ERROR: Errors printed on pages 4,5,7,11,12,16,17,18,19,24,25,27,28,29,30, 33,34,35,36,37,38,44,45,46,48. References and Links Non-exhaustive list of general R and SAS references used in this chapter: SAS Matrix reference SAS Data set documentation Creating SAS Data Sets from IML (also this friendly guide and this blog post) SAS Data Step options SAS Mathematical Operators Lists and Data Structures in SAS Loops in SAS and SAS documentation for DO WHILE loops Random number generation in SAS SAS and R compared (by SAS) Repeatable random number generation in R Data structures in Advanced R 2.5.1 Cheat Sheets and Reference Cards SAS Cheatsheet (from another class like this) SAS Cheatsheet (by SAS) R Cheatsheet - this is a simplified cheat sheet offered by RStudio. R Cheatsheet (classic) SAS Programming for R Users (free book) and github site with training materials R programming for SAS users - site for the book, plus link to a free early version of the book (the book is now published) 2.5.2 SAS (as taught in other places) Introduction to SAS - Undergraduate course at Penn State Intermediate SAS - Undergraduate course at Penn State Advanced SAS - Undergraduate course at Penn State 2.5.3 R courses (as taught elsewhere) and Textbooks Stat 579 at Iowa State (as taught by Heike Hofmann) Stat 545 at Univ. British Columbia (developed by Jenny Bryan) R for Data Science - R textbook (free) by Hadley Wickham and Garret Grolemund Advanced R by Hadley Wickham 2.5.4 Combination of R and SAS courses Stat 850 as taught by Chris Bilder at UNL 2.5.5 Non-Exhaustive List of Sources used to aggregate “core programming concepts”: https://blog.upperlinecode.com/computer-language-fundamentals-five-core-concepts-1aa43e929f40 https://howtoprogramwithjava.com/programming-101-the-5-basic-concepts-of-any-programming-language/ https://dev.to/lucpattyn/basic-programming-concepts-for-beginners-2o73 http://livecode.byu.edu/programmingconcepts/ControlStruct.php http://holowczak.com/programming-concepts-tutorial-programmers/ There is also an R package dedicated to pure evil that will set F and T randomly on startup. Use this information wisely.↩︎ numeric is not really a type, it’s a mode. Run ?mode for more information.↩︎ While there are both Duplo and Lego in my house, my toddler is a lot more willing to share than my husband, so Duplo will have to do.↩︎ Most languages are 0-indexed languages: C, C++, python, Java, javascript. Vectors in these languages are indexed as 0, 1, 2, 3. Other 1-indexed languages include FORTRAN, Matlab, Julia, Mathematica, and Lua, many of which were intended for mathematical processing or data analysis.↩︎ Traditionally, naughty children get coal, while nice children get toys or candy.↩︎ "]]
