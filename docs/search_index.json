[["data-programming-basics.html", "Module 4 Basics of Programming with Data Module Objectives 4.1 Introduction 4.2 Example 1: Art 4.3 Example 2: Dogs of NYC", " Module 4 Basics of Programming with Data Module Objectives Write basic functions and procedures to create simple plots and data summaries Apply syntax knowledge to reference variables and observations in common data structures Create new variables and columns or reformat existing columns in provided data structures 4.1 Introduction At this point in the course, you’ve learned how to write functions. You know the basics of how to create new variables, how data frames and lists work, and how to use markdown. And yet… these are skills that take some practice when applied to new data. So this week, we’re going to focus on working with datasets, but we’re not going to learn much in the way of new material (though I’ll provide sample code for tasks like basic plots and tables). This week is about reinforcing the skills you’ve already learned, and helping you find your feet a bit as you work through a data analysis. It will also provide a preview of some of the packages we’re going to work with in the coming weeks (because I’m going to show you how to e.g. summarize a dataset and plot a few things, even without having covered that material). As you’ve probably guessed by now, this week’s reading will primarily be focused on examples. 4.2 Example 1: Art The Tate Art Museum assembled a collection of 70,000 artworks (last updated in 2014). They catalogued information including accession number, artwork dimensions, units, title, date, medium, inscription, and even URLs for images of the art. library(readr) library(skimr) artwork &lt;- read_csv(&#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-01-12/artwork.csv&#39;) ── Column specification ──────────────────────────────────────────────────────── cols( .default = col_character(), id = col_double(), artistId = col_double(), year = col_double(), acquisitionYear = col_double(), width = col_double(), height = col_double(), depth = col_double(), thumbnailCopyright = col_logical() ) ℹ Use `spec()` for the full column specifications. skim(artwork) Table 4.1: Data summary Name artwork Number of rows 69201 Number of columns 20 _______________________ Column type frequency: character 12 logical 1 numeric 7 ________________________ Group variables None Variable type: character skim_variable n_missing complete_rate min max empty n_unique whitespace accession_number 0 1.00 6 7 0 69201 0 artist 0 1.00 4 120 0 3336 0 artistRole 0 1.00 5 24 0 19 0 title 0 1.00 1 320 0 43529 0 dateText 0 1.00 4 75 0 2736 0 medium 6384 0.91 3 120 0 3401 0 creditLine 3 1.00 14 820 0 3209 0 dimensions 2433 0.96 4 248 0 25575 0 units 3341 0.95 2 2 0 1 0 inscription 62895 0.09 14 14 0 1 0 thumbnailUrl 10786 0.84 55 57 0 58415 0 url 0 1.00 48 134 0 69201 0 Variable type: logical skim_variable n_missing complete_rate mean count thumbnailCopyright 69201 0 NaN : Variable type: numeric skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist id 0 1.00 39148.03 25980.47 3 19096.00 37339 54712 129068 ▇▇▅▁▁ artistId 0 1.00 1201.06 2019.42 0 558.00 558 1137 19232 ▇▁▁▁▁ year 5397 0.92 1867.23 72.01 1545 1817.00 1831 1953 2012 ▁▁▇▆▆ acquisitionYear 45 1.00 1910.65 64.20 1823 1856.00 1856 1982 2013 ▇▁▁▁▅ width 3367 0.95 323.47 408.81 3 118.00 175 345 11960 ▇▁▁▁▁ height 3342 0.95 346.44 538.04 6 117.00 190 359 37500 ▇▁▁▁▁ depth 66687 0.04 479.20 1051.14 1 48.25 190 450 18290 ▇▁▁▁▁ When you first access a new dataset, it’s fun to explore it a bit. I’ve shown a summary of the variables (character variables summarized with completion rates and # unique values, numeric variables summarized with quantiles and mean/sd) generated using the skimr package (which we’ll talk about next week). First, let’s pull out the year for each piece of artwork in the dataset and see what we can do with it… head(artwork$year) [1] NA NA 1785 NA 1826 1826 We reference a column of the dataset by name using dataset_name$column_name, and since our data is stored in artwork, and we want the column named year, we use artwork$year to get access to the data we want. I’ve used the head command to show only the first few values (so that the output isn’t overwhelming). When we have output like this, it is useful to summarize the output in some way: summary(artwork$year) Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s 1545 1817 1831 1867 1953 2012 5397 That’s much less output, but we might want to instead make a chart: hist(artwork$year) Personally, I much prefer the graphical version. It’s informative (though it does leave out NA values) and shows that there are pieces going back to the 1500s, but that most pieces were made in the early 1800s or late 1900s. We might be interested in the aspect ratio of the artwork - let’s take a look at the input variables and define new variables related to aspect ratio(s) hist(artwork$width) hist(artwork$depth) hist(artwork$height) So all of our variables are skewed quite a bit, and we know from the existence of the units column that they may not be in the same unit, either… table(artwork$units) mm 65860 Except apparently they are, so … cool. That does make life easier. To define a new variable that exists on its own, we might do something like this: aspect_hw &lt;- artwork$height/artwork$width hist(aspect_hw) hist(log(aspect_hw)) Ok, interesting. Most things are pretty square-ish, but there are obviously quite a few exceptions in both directions. The one problem with how we’ve done this is that we now have a data frame with all of our data in it, and a separate variable aspect_hw, that is not attached to our data frame. That’s not ideal - it’s easy to lose track of the variable, it’s easy to accidentally “sort” the variable so that the row order isn’t the same as in the original data frame… there are all sorts of potential issues. So, the better way to define a new variable is to add a new column to the data frame: artwork$aspect_hw &lt;- artwork$height/artwork$width (We’ll learn an easier way to do this later, but this is functional, if not pretty, for now). The downside to this is that we have to write out artwork$aspect_hw each time we want to reference the variable. That is a pain, but one that’s relatively temporary (we’ll get to a better way to do this in a couple of weeks). A little bit of extra typing is definitely worth it if you don’t lose data you want to keep. One mistake I see people make frequently is to calculate artwork$height/artwork$width, but then not assign that value to a variable. If you’re not using &lt;- (or = or -&gt; if you’re a total heathen) then you’re not saving that information to be referenced later - you’re just calculating values temporarily. It’s important to keep track of where you’re putting the pieces you create during an analysis - just as important as keeping track of the different sub-components when you’re putting a lego set together or making a complex recipe in the kitchen. Forgetting to assign your calculation to a variable is like dumping your mixture down the sink or throwing that small lego component into the trash. 4.3 Example 2: Dogs of NYC New York City provides a whole host of open-data resources, including a dataset of dogs licensed in the city on an annual basis (link is to the NYC Open Data Page). CSV link (this data is ~23 MB) library(readr) if (!file.exists(&quot;data/NYC_dogs.csv&quot;)) { # if the file doesn&#39;t exist, download it! download.file( &quot;https://data.cityofnewyork.us/api/views/nu7n-tubp/rows.csv?accessType=DOWNLOAD&quot;, # url for download destfile = &quot;data/NYC_dogs.csv&quot;, # location to store the file mode = &quot;wb&quot; # need this to get downloads to work on windows ) } dogs &lt;- read_csv(&quot;data/NYC_dogs.csv&quot;) ── Column specification ──────────────────────────────────────────────────────── cols( RowNumber = col_double(), AnimalName = col_character(), AnimalGender = col_character(), AnimalBirthMonth = col_double(), BreedName = col_character(), Borough = col_logical(), ZipCode = col_double(), LicenseIssuedDate = col_character(), LicenseExpiredDate = col_character(), `Extract Year` = col_double() ) head(dogs) # A tibble: 6 x 10 RowNumber AnimalName AnimalGender AnimalBirthMonth BreedName Borough ZipCode &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;dbl&gt; 1 1 PAIGE F 2014 American P… NA 10035 2 2 YOGI M 2010 Boxer NA 10465 3 3 ALI M 2014 Basenji NA 10013 4 4 QUEEN F 2013 Akita Cros… NA 10013 5 5 LOLA F 2009 Maltese NA 10028 6 6 IAN M 2006 Unknown NA 10013 # … with 3 more variables: LicenseIssuedDate &lt;chr&gt;, LicenseExpiredDate &lt;chr&gt;, # Extract Year &lt;dbl&gt; One thing we might want to do first is to transform the license dates (LicenseIssuedDate, LicenseExpiredDate) into actual dates instead of characters. We will use the lubridate package to do this, because it is designed to make working with dates and times very easy. library(lubridate) Attaching package: &#39;lubridate&#39; The following objects are masked from &#39;package:base&#39;: date, intersect, setdiff, union head(dogs$LicenseExpiredDate) # Dates are in month-day-year format [1] &quot;09/12/2017&quot; &quot;10/02/2017&quot; &quot;09/12/2019&quot; &quot;09/12/2017&quot; &quot;10/09/2017&quot; [6] &quot;10/30/2019&quot; dogs$LicenseExpiredDate &lt;- mdy(dogs$LicenseExpiredDate) dogs$LicenseIssuedDate &lt;- mdy(dogs$LicenseIssuedDate) It might be interesting to see when licenses have been issued over time, so let’s make a histogram: library(ggplot2) ggplot( data = dogs, aes(x = LicenseIssuedDate) # Specify we want LicenseIssueDate on the x-axis ) + geom_histogram() # Create a histogram `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. There is an interesting periodicity to the license issue dates. I’m also curious about how long a license tends to be held for - we can get this information by subtracting the issue date from the expiration date. dogs$LicenseLength &lt;- dogs$LicenseExpiredDate - dogs$LicenseIssuedDate summary(dogs$LicenseLength) Length Class Mode 345727 difftime numeric head(dogs$LicenseLength) Time differences in days [1] 1096 1116 1826 1096 1123 1874 We can see that directly subtracting date-times gives us a license length in days. That’s useful enough, I guess, but it might be more useful in years… unfortunately, that’s not an option for difftime() dogs$LicenseLength &lt;- difftime(dogs$LicenseExpiredDate, dogs$LicenseIssuedDate, units = &quot;weeks&quot;) # 52 weeks in a year so we&#39;ll just convert as we plot ggplot(data = dogs, aes(x = LicenseLength / 52 )) + geom_histogram() + scale_x_continuous(breaks = 0:10) `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Another question that I have when looking at this dataset is a bit more superficial - are the characteristics of different areas different? The dogs data frame has a Borough column, but it’s not actually filled in, so we’ll need to get rid of it and then add Borough back in by zip code. To look at this, we’ll need a bit more data. I found a list of NYC zip codes by borough, which we can merge in with the data we already have to get puppy registrations by borough. Then, we can see if e.g. the top 10 breeds are different for different boroughs. To simplify this, I’m going to link to a file to merge in, and not show you the specifics of how I read the table from this site into R. borough_zip &lt;- read_csv(&quot;https://raw.githubusercontent.com/srvanderplas/unl-stat850/master/data/nyc_zip_borough.csv&quot;) ── Column specification ──────────────────────────────────────────────────────── cols( ZipCode = col_double(), Borough = col_character() ) # Remove the Borough column from dogs dogs &lt;- dogs[, which(names(dogs) != &quot;Borough&quot;)] dogs &lt;- merge(dogs, borough_zip, by = &quot;ZipCode&quot;) head(dogs) ZipCode RowNumber AnimalName AnimalGender AnimalBirthMonth 1 10001 82601 ABBY F 2008 2 10001 33510 SALOMON M 2014 3 10001 114699 MAXWELL M 2016 4 10001 95306 CHANCE M 2015 5 10001 19397 TEDDY M 2017 6 10001 1506 CAIRO M 2012 BreedName LicenseIssuedDate LicenseExpiredDate Extract Year 1 Labrador Retriever 2016-08-01 2021-09-24 2016 2 Unknown 2015-12-05 2017-07-21 2016 3 Labrador Retriever 2017-12-26 2018-12-26 2017 4 Pointer 2017-09-14 2018-10-02 2017 5 Shih Tzu Crossbreed 2017-04-27 2018-04-27 2018 6 Bull Dog, French 2015-03-29 2018-04-19 2017 LicenseLength Borough 1 268.57143 weeks Manhattan 2 84.85714 weeks Manhattan 3 52.14286 weeks Manhattan 4 54.71429 weeks Manhattan 5 52.14286 weeks Manhattan 6 159.57143 weeks Manhattan Now that we have borough, let’s write a function that will take a dataset and spit out a list of the top 5 dog breeds registered in that area. top_5_breeds &lt;- function(data) { # Inside the function, our dataset is called data, not dogs tmp &lt;- table(data$BreedName) return(sort(tmp, decreasing = T)[1:5]) # top 5 breeds with counts } Now, using that function, lets write a for loop that loops through the 5 boroughs and spits out the top 5 breeds in each borough: boroughs &lt;- unique(borough_zip$Borough) # get a list of the 5 boroughs for (i in boroughs) { # Get subset of data frame corresponding to the Borough dogs_sub &lt;- subset(dogs, Borough == i) # Get top 5 dog breeds result &lt;- as.data.frame(top_5_breeds(dogs_sub)) # set names names(result) &lt;- c(&quot;Breed&quot;, &quot;Freq&quot;) # Add Borough as a new column result$Borough &lt;- i # Add rank as a new column result$rank &lt;- 1:5 print(result) } Breed Freq Borough rank 1 Unknown 12310 Manhattan 1 2 Yorkshire Terrier 5371 Manhattan 2 3 Chihuahua 5115 Manhattan 3 4 Shih Tzu 4607 Manhattan 4 5 Labrador Retriever 4162 Manhattan 5 Breed Freq Borough rank 1 Unknown 4119 Staten 1 2 Shih Tzu 2114 Staten 2 3 Yorkshire Terrier 2107 Staten 3 4 Labrador Retriever 1484 Staten 4 5 Maltese 1129 Staten 5 Breed Freq Borough rank 1 Yorkshire Terrier 3603 Bronx 1 2 Unknown 3484 Bronx 2 3 Shih Tzu 2976 Bronx 3 4 Chihuahua 2224 Bronx 4 5 American Pit Bull Terrier/Pit Bull 1820 Bronx 5 Breed Freq Borough rank 1 Unknown 8341 Queens 1 2 Yorkshire Terrier 4689 Queens 2 3 Shih Tzu 4272 Queens 3 4 Maltese 3090 Queens 4 5 Chihuahua 2990 Queens 5 Breed Freq Borough rank 1 Unknown 9863 Brooklyn 1 2 Yorkshire Terrier 5820 Brooklyn 2 3 Shih Tzu 5345 Brooklyn 3 4 Chihuahua 4078 Brooklyn 4 5 American Pit Bull Mix / Pit Bull Mix 3201 Brooklyn 5 If we wanted to save these results as a summary data frame, we could totally do that! breeds_by_borough &lt;- data.frame() # create a blank data frame for (i in boroughs) { # Get subset of data frame corresponding to the Borough dogs_sub &lt;- subset(dogs, Borough == i) # Get top 5 dog breeds result &lt;- as.data.frame(top_5_breeds(dogs_sub)) # set names names(result) &lt;- c(&quot;Breed&quot;, &quot;Freq&quot;) # Add Borough as a new column result$Borough &lt;- i # Add rank as a new column result$rank &lt;- 1:5 breeds_by_borough &lt;- rbind(breeds_by_borough, result) } breeds_by_borough Breed Freq Borough rank 1 Unknown 12310 Manhattan 1 2 Yorkshire Terrier 5371 Manhattan 2 3 Chihuahua 5115 Manhattan 3 4 Shih Tzu 4607 Manhattan 4 5 Labrador Retriever 4162 Manhattan 5 6 Unknown 4119 Staten 1 7 Shih Tzu 2114 Staten 2 8 Yorkshire Terrier 2107 Staten 3 9 Labrador Retriever 1484 Staten 4 10 Maltese 1129 Staten 5 11 Yorkshire Terrier 3603 Bronx 1 12 Unknown 3484 Bronx 2 13 Shih Tzu 2976 Bronx 3 14 Chihuahua 2224 Bronx 4 15 American Pit Bull Terrier/Pit Bull 1820 Bronx 5 16 Unknown 8341 Queens 1 17 Yorkshire Terrier 4689 Queens 2 18 Shih Tzu 4272 Queens 3 19 Maltese 3090 Queens 4 20 Chihuahua 2990 Queens 5 21 Unknown 9863 Brooklyn 1 22 Yorkshire Terrier 5820 Brooklyn 2 23 Shih Tzu 5345 Brooklyn 3 24 Chihuahua 4078 Brooklyn 4 25 American Pit Bull Mix / Pit Bull Mix 3201 Brooklyn 5 We could even sort our data by the rank and Borough for easier comparisons: breeds_by_borough[order(breeds_by_borough$rank, breeds_by_borough$Borough),] Breed Freq Borough rank 11 Yorkshire Terrier 3603 Bronx 1 21 Unknown 9863 Brooklyn 1 1 Unknown 12310 Manhattan 1 16 Unknown 8341 Queens 1 6 Unknown 4119 Staten 1 12 Unknown 3484 Bronx 2 22 Yorkshire Terrier 5820 Brooklyn 2 2 Yorkshire Terrier 5371 Manhattan 2 17 Yorkshire Terrier 4689 Queens 2 7 Shih Tzu 2114 Staten 2 13 Shih Tzu 2976 Bronx 3 23 Shih Tzu 5345 Brooklyn 3 3 Chihuahua 5115 Manhattan 3 18 Shih Tzu 4272 Queens 3 8 Yorkshire Terrier 2107 Staten 3 14 Chihuahua 2224 Bronx 4 24 Chihuahua 4078 Brooklyn 4 4 Shih Tzu 4607 Manhattan 4 19 Maltese 3090 Queens 4 9 Labrador Retriever 1484 Staten 4 15 American Pit Bull Terrier/Pit Bull 1820 Bronx 5 25 American Pit Bull Mix / Pit Bull Mix 3201 Brooklyn 5 5 Labrador Retriever 4162 Manhattan 5 20 Chihuahua 2990 Queens 5 10 Maltese 1129 Staten 5 Look at the name, age, or gender of dogs registered in NYC and see if you can come up with a similar function and way of summarizing the data in a for-loop. In 2 weeks, we’ll learn a much shorter set of commands to get these types of summaries, but it’s important to know how a for loop connects to the concept of summarizing data by a factor (in this case, by borough). "]]
