[
["lists-nested-lists-and-functional-programming.html", "Module 12 Lists, Nested Lists, and Functional Programming 12.1 Review: Lists and Vectors 12.2 Introduction to map 12.3 Creating List-columns References", " Module 12 Lists, Nested Lists, and Functional Programming 12.1 Review: Lists and Vectors A vector is a 1-dimensional R data structure that contains items of the same simple (‘atomic’) type (character, logical, integer, factor). (logical_vec &lt;- c(T, F, T, T)) ## [1] TRUE FALSE TRUE TRUE (numeric_vec &lt;- c(3, 1, 4, 5)) ## [1] 3 1 4 5 (char_vec &lt;- c(&quot;A&quot;, &quot;AB&quot;, &quot;ABC&quot;, &quot;ABCD&quot;)) ## [1] &quot;A&quot; &quot;AB&quot; &quot;ABC&quot; &quot;ABCD&quot; You index a vector using brackets: to get the 3rd element of the vector x, you would use x[3]. logical_vec[3] ## [1] TRUE numeric_vec[3] ## [1] 4 char_vec[3] ## [1] &quot;ABC&quot; You can also index a vector using a logical vector: numeric_vec[logical_vec] ## [1] 3 4 5 char_vec[logical_vec] ## [1] &quot;A&quot; &quot;ABC&quot; &quot;ABCD&quot; logical_vec[logical_vec] ## [1] TRUE TRUE TRUE A list is a 1-dimensional R data structure that has no restrictions on what type of content is stored within it. (mylist &lt;- list(logical_vec, numeric_vec, third_thing = char_vec[1:2])) ## [[1]] ## [1] TRUE FALSE TRUE TRUE ## ## [[2]] ## [1] 3 1 4 5 ## ## $third_thing ## [1] &quot;A&quot; &quot;AB&quot; A list is a vector, but it is not an atomic vector - that is, it does not necessarily contain things that are all the same type. List components may have names (or not), be homogeneous (or not), have the same length (or not). There are 3 ways to index a list: With single square brackets, just like we index atomic vectors. In this case, the return value is always a list. mylist[1] ## [[1]] ## [1] TRUE FALSE TRUE TRUE mylist[2] ## [[1]] ## [1] 3 1 4 5 mylist[c(T, F, T)] ## [[1]] ## [1] TRUE FALSE TRUE TRUE ## ## $third_thing ## [1] &quot;A&quot; &quot;AB&quot; With double square brackets. In this case, the return value is the thing inside the specified position in the list, but you also can only get one entry in the main list at a time. You can also get things by name. mylist[[1]] ## [1] TRUE FALSE TRUE TRUE mylist[[&quot;third_thing&quot;]] ## [1] &quot;A&quot; &quot;AB&quot; Using x$name. This is equivalent to using x[[\"name\"]]. Note that this does not work on unnamed entries in the list. mylist$third_thing ## [1] &quot;A&quot; &quot;AB&quot; You can get a more thorough review of vectors and lists from Jenny Bryan’s purrr tutorial. Operations in R are vectorized - that is, by default, they operate on vectors. This is primarily a feature that applies to atomic vectors (and we don’t even think about it): (rnorm(10) + rnorm(10, mean = 3)) ## [1] 2.5901192 5.6280698 3.8117427 2.9286354 0.7314445 1.8338168 3.1511402 ## [8] 1.2429209 4.1388425 2.2162552 We didn’t have to use a for loop to add these two vectors with 10 entries each together. In python (and SAS, and other languages), this might instead look like: a &lt;- rnorm(10) b &lt;- rnorm(10, mean = 3) result &lt;- rep(0, 10) for(i in 1:10) { result[i] &lt;- a[i] + b[i] } result ## [1] 2.670812 1.864085 3.418096 3.077160 1.961165 2.360801 2.158312 2.616665 ## [9] 3.034091 2.552671 That is, we would apply or map the + function to each entry of a and b. For atomic vectors, it’s easy to do this by default; with a list, however, we need to be a bit more explicit (because everything that’s passed into the function may not be the same type). This logic is the basis behind the purrr package (and similar base functions apply, lapply, sapply, tapply, and mapply - I find the purrr package easier to work with, but you may use the base package versions if you want, and you can find a side-by-side comparison in the purrr tutorial). 12.2 Introduction to map library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ ggplot2 3.3.2.9000 ✓ purrr 0.3.4 ## ✓ tibble 3.0.4 ✓ dplyr 1.0.2 ## ✓ tidyr 1.1.2 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.5.0 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(purrr) # list functions library(repurrrsive) # examples We’ll use one of the datasets in repurrsive, got_chars, to start playing with the map_ series of functions. data(got_chars) length(got_chars) ## [1] 30 got_chars[[1]] ## $url ## [1] &quot;https://www.anapioficeandfire.com/api/characters/1022&quot; ## ## $id ## [1] 1022 ## ## $name ## [1] &quot;Theon Greyjoy&quot; ## ## $gender ## [1] &quot;Male&quot; ## ## $culture ## [1] &quot;Ironborn&quot; ## ## $born ## [1] &quot;In 278 AC or 279 AC, at Pyke&quot; ## ## $died ## [1] &quot;&quot; ## ## $alive ## [1] TRUE ## ## $titles ## [1] &quot;Prince of Winterfell&quot; ## [2] &quot;Captain of Sea Bitch&quot; ## [3] &quot;Lord of the Iron Islands (by law of the green lands)&quot; ## ## $aliases ## [1] &quot;Prince of Fools&quot; &quot;Theon Turncloak&quot; &quot;Reek&quot; &quot;Theon Kinslayer&quot; ## ## $father ## [1] &quot;&quot; ## ## $mother ## [1] &quot;&quot; ## ## $spouse ## [1] &quot;&quot; ## ## $allegiances ## [1] &quot;House Greyjoy of Pyke&quot; ## ## $books ## [1] &quot;A Game of Thrones&quot; &quot;A Storm of Swords&quot; &quot;A Feast for Crows&quot; ## ## $povBooks ## [1] &quot;A Clash of Kings&quot; &quot;A Dance with Dragons&quot; ## ## $tvSeries ## [1] &quot;Season 1&quot; &quot;Season 2&quot; &quot;Season 3&quot; &quot;Season 4&quot; &quot;Season 5&quot; &quot;Season 6&quot; ## ## $playedBy ## [1] &quot;Alfie Allen&quot; It appears that each entry in this 30-item list is a character from Game of Thrones, and there are several sub-fields for each character. What characters do we have? We can use purrr::map(x, \"name\") to get a list of all characters’ names. Since they are all the same type, we could also use an extension of map, map_chr, which will coerce the returned list into a character vector (which may be simpler to operate on). There are several packages with map() functions including functions that are meant to actually plot maps; it generally saves time and effort to just type the function name with the package you want; you don’t have to do so, but if you have a lot of other (non tidyverse, in particular) packages loaded, it will save you a lot of grief. purrr::map(got_chars, &quot;name&quot;) ## [[1]] ## [1] &quot;Theon Greyjoy&quot; ## ## [[2]] ## [1] &quot;Tyrion Lannister&quot; ## ## [[3]] ## [1] &quot;Victarion Greyjoy&quot; ## ## [[4]] ## [1] &quot;Will&quot; ## ## [[5]] ## [1] &quot;Areo Hotah&quot; ## ## [[6]] ## [1] &quot;Chett&quot; ## ## [[7]] ## [1] &quot;Cressen&quot; ## ## [[8]] ## [1] &quot;Arianne Martell&quot; ## ## [[9]] ## [1] &quot;Daenerys Targaryen&quot; ## ## [[10]] ## [1] &quot;Davos Seaworth&quot; ## ## [[11]] ## [1] &quot;Arya Stark&quot; ## ## [[12]] ## [1] &quot;Arys Oakheart&quot; ## ## [[13]] ## [1] &quot;Asha Greyjoy&quot; ## ## [[14]] ## [1] &quot;Barristan Selmy&quot; ## ## [[15]] ## [1] &quot;Varamyr&quot; ## ## [[16]] ## [1] &quot;Brandon Stark&quot; ## ## [[17]] ## [1] &quot;Brienne of Tarth&quot; ## ## [[18]] ## [1] &quot;Catelyn Stark&quot; ## ## [[19]] ## [1] &quot;Cersei Lannister&quot; ## ## [[20]] ## [1] &quot;Eddard Stark&quot; ## ## [[21]] ## [1] &quot;Jaime Lannister&quot; ## ## [[22]] ## [1] &quot;Jon Connington&quot; ## ## [[23]] ## [1] &quot;Jon Snow&quot; ## ## [[24]] ## [1] &quot;Aeron Greyjoy&quot; ## ## [[25]] ## [1] &quot;Kevan Lannister&quot; ## ## [[26]] ## [1] &quot;Melisandre&quot; ## ## [[27]] ## [1] &quot;Merrett Frey&quot; ## ## [[28]] ## [1] &quot;Quentyn Martell&quot; ## ## [[29]] ## [1] &quot;Samwell Tarly&quot; ## ## [[30]] ## [1] &quot;Sansa Stark&quot; purrr::map_chr(got_chars, &quot;name&quot;) ## [1] &quot;Theon Greyjoy&quot; &quot;Tyrion Lannister&quot; &quot;Victarion Greyjoy&quot; ## [4] &quot;Will&quot; &quot;Areo Hotah&quot; &quot;Chett&quot; ## [7] &quot;Cressen&quot; &quot;Arianne Martell&quot; &quot;Daenerys Targaryen&quot; ## [10] &quot;Davos Seaworth&quot; &quot;Arya Stark&quot; &quot;Arys Oakheart&quot; ## [13] &quot;Asha Greyjoy&quot; &quot;Barristan Selmy&quot; &quot;Varamyr&quot; ## [16] &quot;Brandon Stark&quot; &quot;Brienne of Tarth&quot; &quot;Catelyn Stark&quot; ## [19] &quot;Cersei Lannister&quot; &quot;Eddard Stark&quot; &quot;Jaime Lannister&quot; ## [22] &quot;Jon Connington&quot; &quot;Jon Snow&quot; &quot;Aeron Greyjoy&quot; ## [25] &quot;Kevan Lannister&quot; &quot;Melisandre&quot; &quot;Merrett Frey&quot; ## [28] &quot;Quentyn Martell&quot; &quot;Samwell Tarly&quot; &quot;Sansa Stark&quot; Similar shortcuts work to get the nth item in each sub list: purrr::map_chr(got_chars, 4) ## [1] &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; ## [9] &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; ## [17] &quot;Female&quot; &quot;Female&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; ## [25] &quot;Male&quot; &quot;Female&quot; &quot;Male&quot; &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; Specifying the output type using e.g. map_chr works if each item in the list is an atomic vector of length 1. If the list is more complicated, though, these shortcuts will issue an error: purrr::map(got_chars, &quot;books&quot;) ## [[1]] ## [1] &quot;A Game of Thrones&quot; &quot;A Storm of Swords&quot; &quot;A Feast for Crows&quot; ## ## [[2]] ## [1] &quot;A Feast for Crows&quot; &quot;The World of Ice and Fire&quot; ## ## [[3]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## ## [[4]] ## [1] &quot;A Clash of Kings&quot; ## ## [[5]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## ## [[6]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; ## ## [[7]] ## [1] &quot;A Storm of Swords&quot; &quot;A Feast for Crows&quot; ## ## [[8]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## [4] &quot;A Dance with Dragons&quot; ## ## [[9]] ## [1] &quot;A Feast for Crows&quot; ## ## [[10]] ## [1] &quot;A Feast for Crows&quot; ## ## [[11]] ## NULL ## ## [[12]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## [4] &quot;A Dance with Dragons&quot; ## ## [[13]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; ## ## [[14]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; ## [3] &quot;A Storm of Swords&quot; &quot;A Feast for Crows&quot; ## [5] &quot;The World of Ice and Fire&quot; ## ## [[15]] ## [1] &quot;A Storm of Swords&quot; ## ## [[16]] ## [1] &quot;A Feast for Crows&quot; ## ## [[17]] ## [1] &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; &quot;A Dance with Dragons&quot; ## ## [[18]] ## [1] &quot;A Feast for Crows&quot; &quot;A Dance with Dragons&quot; ## ## [[19]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## ## [[20]] ## [1] &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## [3] &quot;A Feast for Crows&quot; &quot;A Dance with Dragons&quot; ## [5] &quot;The World of Ice and Fire&quot; ## ## [[21]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; ## ## [[22]] ## [1] &quot;A Storm of Swords&quot; &quot;A Feast for Crows&quot; ## [3] &quot;The World of Ice and Fire&quot; ## ## [[23]] ## [1] &quot;A Feast for Crows&quot; ## ## [[24]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## [4] &quot;A Dance with Dragons&quot; ## ## [[25]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## [4] &quot;A Feast for Crows&quot; ## ## [[26]] ## [1] &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; &quot;A Feast for Crows&quot; ## ## [[27]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Feast for Crows&quot; ## [4] &quot;A Dance with Dragons&quot; ## ## [[28]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Storm of Swords&quot; ## [4] &quot;A Feast for Crows&quot; ## ## [[29]] ## [1] &quot;A Game of Thrones&quot; &quot;A Clash of Kings&quot; &quot;A Dance with Dragons&quot; ## ## [[30]] ## [1] &quot;A Dance with Dragons&quot; purrr::map_chr(got_chars, &quot;books&quot;) ## Error: Result 1 must be a single string, not a character vector of length 3 What if we want to extract several things? This trick works off of the idea that [ is a function: that is, the single brackets we used before are actually a special type of function. In R functions, there is often the argument ..., which is a convention that allows us to pass arguments to other functions that are called within the main function we are using (you’ll see … used in plotting and regression functions frequently as well). Here, we use ... to pass in our list of 3 things we want to pull from each item in the list. purrr::map(got_chars, `[`, c(&quot;name&quot;, &quot;gender&quot;, &quot;born&quot;)) ## [[1]] ## [[1]]$name ## [1] &quot;Theon Greyjoy&quot; ## ## [[1]]$gender ## [1] &quot;Male&quot; ## ## [[1]]$born ## [1] &quot;In 278 AC or 279 AC, at Pyke&quot; ## ## ## [[2]] ## [[2]]$name ## [1] &quot;Tyrion Lannister&quot; ## ## [[2]]$gender ## [1] &quot;Male&quot; ## ## [[2]]$born ## [1] &quot;In 273 AC, at Casterly Rock&quot; ## ## ## [[3]] ## [[3]]$name ## [1] &quot;Victarion Greyjoy&quot; ## ## [[3]]$gender ## [1] &quot;Male&quot; ## ## [[3]]$born ## [1] &quot;In 268 AC or before, at Pyke&quot; ## ## ## [[4]] ## [[4]]$name ## [1] &quot;Will&quot; ## ## [[4]]$gender ## [1] &quot;Male&quot; ## ## [[4]]$born ## [1] &quot;&quot; ## ## ## [[5]] ## [[5]]$name ## [1] &quot;Areo Hotah&quot; ## ## [[5]]$gender ## [1] &quot;Male&quot; ## ## [[5]]$born ## [1] &quot;In 257 AC or before, at Norvos&quot; ## ## ## [[6]] ## [[6]]$name ## [1] &quot;Chett&quot; ## ## [[6]]$gender ## [1] &quot;Male&quot; ## ## [[6]]$born ## [1] &quot;At Hag&#39;s Mire&quot; ## ## ## [[7]] ## [[7]]$name ## [1] &quot;Cressen&quot; ## ## [[7]]$gender ## [1] &quot;Male&quot; ## ## [[7]]$born ## [1] &quot;In 219 AC or 220 AC&quot; ## ## ## [[8]] ## [[8]]$name ## [1] &quot;Arianne Martell&quot; ## ## [[8]]$gender ## [1] &quot;Female&quot; ## ## [[8]]$born ## [1] &quot;In 276 AC, at Sunspear&quot; ## ## ## [[9]] ## [[9]]$name ## [1] &quot;Daenerys Targaryen&quot; ## ## [[9]]$gender ## [1] &quot;Female&quot; ## ## [[9]]$born ## [1] &quot;In 284 AC, at Dragonstone&quot; ## ## ## [[10]] ## [[10]]$name ## [1] &quot;Davos Seaworth&quot; ## ## [[10]]$gender ## [1] &quot;Male&quot; ## ## [[10]]$born ## [1] &quot;In 260 AC or before, at King&#39;s Landing&quot; ## ## ## [[11]] ## [[11]]$name ## [1] &quot;Arya Stark&quot; ## ## [[11]]$gender ## [1] &quot;Female&quot; ## ## [[11]]$born ## [1] &quot;In 289 AC, at Winterfell&quot; ## ## ## [[12]] ## [[12]]$name ## [1] &quot;Arys Oakheart&quot; ## ## [[12]]$gender ## [1] &quot;Male&quot; ## ## [[12]]$born ## [1] &quot;At Old Oak&quot; ## ## ## [[13]] ## [[13]]$name ## [1] &quot;Asha Greyjoy&quot; ## ## [[13]]$gender ## [1] &quot;Female&quot; ## ## [[13]]$born ## [1] &quot;In 275 AC or 276 AC, at Pyke&quot; ## ## ## [[14]] ## [[14]]$name ## [1] &quot;Barristan Selmy&quot; ## ## [[14]]$gender ## [1] &quot;Male&quot; ## ## [[14]]$born ## [1] &quot;In 237 AC&quot; ## ## ## [[15]] ## [[15]]$name ## [1] &quot;Varamyr&quot; ## ## [[15]]$gender ## [1] &quot;Male&quot; ## ## [[15]]$born ## [1] &quot;At a village Beyond the Wall&quot; ## ## ## [[16]] ## [[16]]$name ## [1] &quot;Brandon Stark&quot; ## ## [[16]]$gender ## [1] &quot;Male&quot; ## ## [[16]]$born ## [1] &quot;In 290 AC, at Winterfell&quot; ## ## ## [[17]] ## [[17]]$name ## [1] &quot;Brienne of Tarth&quot; ## ## [[17]]$gender ## [1] &quot;Female&quot; ## ## [[17]]$born ## [1] &quot;In 280 AC&quot; ## ## ## [[18]] ## [[18]]$name ## [1] &quot;Catelyn Stark&quot; ## ## [[18]]$gender ## [1] &quot;Female&quot; ## ## [[18]]$born ## [1] &quot;In 264 AC, at Riverrun&quot; ## ## ## [[19]] ## [[19]]$name ## [1] &quot;Cersei Lannister&quot; ## ## [[19]]$gender ## [1] &quot;Female&quot; ## ## [[19]]$born ## [1] &quot;In 266 AC, at Casterly Rock&quot; ## ## ## [[20]] ## [[20]]$name ## [1] &quot;Eddard Stark&quot; ## ## [[20]]$gender ## [1] &quot;Male&quot; ## ## [[20]]$born ## [1] &quot;In 263 AC, at Winterfell&quot; ## ## ## [[21]] ## [[21]]$name ## [1] &quot;Jaime Lannister&quot; ## ## [[21]]$gender ## [1] &quot;Male&quot; ## ## [[21]]$born ## [1] &quot;In 266 AC, at Casterly Rock&quot; ## ## ## [[22]] ## [[22]]$name ## [1] &quot;Jon Connington&quot; ## ## [[22]]$gender ## [1] &quot;Male&quot; ## ## [[22]]$born ## [1] &quot;In or between 263 AC and 265 AC&quot; ## ## ## [[23]] ## [[23]]$name ## [1] &quot;Jon Snow&quot; ## ## [[23]]$gender ## [1] &quot;Male&quot; ## ## [[23]]$born ## [1] &quot;In 283 AC&quot; ## ## ## [[24]] ## [[24]]$name ## [1] &quot;Aeron Greyjoy&quot; ## ## [[24]]$gender ## [1] &quot;Male&quot; ## ## [[24]]$born ## [1] &quot;In or between 269 AC and 273 AC, at Pyke&quot; ## ## ## [[25]] ## [[25]]$name ## [1] &quot;Kevan Lannister&quot; ## ## [[25]]$gender ## [1] &quot;Male&quot; ## ## [[25]]$born ## [1] &quot;In 244 AC&quot; ## ## ## [[26]] ## [[26]]$name ## [1] &quot;Melisandre&quot; ## ## [[26]]$gender ## [1] &quot;Female&quot; ## ## [[26]]$born ## [1] &quot;At Unknown&quot; ## ## ## [[27]] ## [[27]]$name ## [1] &quot;Merrett Frey&quot; ## ## [[27]]$gender ## [1] &quot;Male&quot; ## ## [[27]]$born ## [1] &quot;In 262 AC&quot; ## ## ## [[28]] ## [[28]]$name ## [1] &quot;Quentyn Martell&quot; ## ## [[28]]$gender ## [1] &quot;Male&quot; ## ## [[28]]$born ## [1] &quot;In 281 AC, at Sunspear, Dorne&quot; ## ## ## [[29]] ## [[29]]$name ## [1] &quot;Samwell Tarly&quot; ## ## [[29]]$gender ## [1] &quot;Male&quot; ## ## [[29]]$born ## [1] &quot;In 283 AC, at Horn Hill&quot; ## ## ## [[30]] ## [[30]]$name ## [1] &quot;Sansa Stark&quot; ## ## [[30]]$gender ## [1] &quot;Female&quot; ## ## [[30]]$born ## [1] &quot;In 286 AC, at Winterfell&quot; If this is ugly syntax to you, that’s fine - the magrittr package also includes an extract function that works the same way. purrr::map(got_chars, magrittr::extract, c(&quot;name&quot;, &quot;gender&quot;, &quot;born&quot;)) ## [[1]] ## [[1]]$name ## [1] &quot;Theon Greyjoy&quot; ## ## [[1]]$gender ## [1] &quot;Male&quot; ## ## [[1]]$born ## [1] &quot;In 278 AC or 279 AC, at Pyke&quot; ## ## ## [[2]] ## [[2]]$name ## [1] &quot;Tyrion Lannister&quot; ## ## [[2]]$gender ## [1] &quot;Male&quot; ## ## [[2]]$born ## [1] &quot;In 273 AC, at Casterly Rock&quot; ## ## ## [[3]] ## [[3]]$name ## [1] &quot;Victarion Greyjoy&quot; ## ## [[3]]$gender ## [1] &quot;Male&quot; ## ## [[3]]$born ## [1] &quot;In 268 AC or before, at Pyke&quot; ## ## ## [[4]] ## [[4]]$name ## [1] &quot;Will&quot; ## ## [[4]]$gender ## [1] &quot;Male&quot; ## ## [[4]]$born ## [1] &quot;&quot; ## ## ## [[5]] ## [[5]]$name ## [1] &quot;Areo Hotah&quot; ## ## [[5]]$gender ## [1] &quot;Male&quot; ## ## [[5]]$born ## [1] &quot;In 257 AC or before, at Norvos&quot; ## ## ## [[6]] ## [[6]]$name ## [1] &quot;Chett&quot; ## ## [[6]]$gender ## [1] &quot;Male&quot; ## ## [[6]]$born ## [1] &quot;At Hag&#39;s Mire&quot; ## ## ## [[7]] ## [[7]]$name ## [1] &quot;Cressen&quot; ## ## [[7]]$gender ## [1] &quot;Male&quot; ## ## [[7]]$born ## [1] &quot;In 219 AC or 220 AC&quot; ## ## ## [[8]] ## [[8]]$name ## [1] &quot;Arianne Martell&quot; ## ## [[8]]$gender ## [1] &quot;Female&quot; ## ## [[8]]$born ## [1] &quot;In 276 AC, at Sunspear&quot; ## ## ## [[9]] ## [[9]]$name ## [1] &quot;Daenerys Targaryen&quot; ## ## [[9]]$gender ## [1] &quot;Female&quot; ## ## [[9]]$born ## [1] &quot;In 284 AC, at Dragonstone&quot; ## ## ## [[10]] ## [[10]]$name ## [1] &quot;Davos Seaworth&quot; ## ## [[10]]$gender ## [1] &quot;Male&quot; ## ## [[10]]$born ## [1] &quot;In 260 AC or before, at King&#39;s Landing&quot; ## ## ## [[11]] ## [[11]]$name ## [1] &quot;Arya Stark&quot; ## ## [[11]]$gender ## [1] &quot;Female&quot; ## ## [[11]]$born ## [1] &quot;In 289 AC, at Winterfell&quot; ## ## ## [[12]] ## [[12]]$name ## [1] &quot;Arys Oakheart&quot; ## ## [[12]]$gender ## [1] &quot;Male&quot; ## ## [[12]]$born ## [1] &quot;At Old Oak&quot; ## ## ## [[13]] ## [[13]]$name ## [1] &quot;Asha Greyjoy&quot; ## ## [[13]]$gender ## [1] &quot;Female&quot; ## ## [[13]]$born ## [1] &quot;In 275 AC or 276 AC, at Pyke&quot; ## ## ## [[14]] ## [[14]]$name ## [1] &quot;Barristan Selmy&quot; ## ## [[14]]$gender ## [1] &quot;Male&quot; ## ## [[14]]$born ## [1] &quot;In 237 AC&quot; ## ## ## [[15]] ## [[15]]$name ## [1] &quot;Varamyr&quot; ## ## [[15]]$gender ## [1] &quot;Male&quot; ## ## [[15]]$born ## [1] &quot;At a village Beyond the Wall&quot; ## ## ## [[16]] ## [[16]]$name ## [1] &quot;Brandon Stark&quot; ## ## [[16]]$gender ## [1] &quot;Male&quot; ## ## [[16]]$born ## [1] &quot;In 290 AC, at Winterfell&quot; ## ## ## [[17]] ## [[17]]$name ## [1] &quot;Brienne of Tarth&quot; ## ## [[17]]$gender ## [1] &quot;Female&quot; ## ## [[17]]$born ## [1] &quot;In 280 AC&quot; ## ## ## [[18]] ## [[18]]$name ## [1] &quot;Catelyn Stark&quot; ## ## [[18]]$gender ## [1] &quot;Female&quot; ## ## [[18]]$born ## [1] &quot;In 264 AC, at Riverrun&quot; ## ## ## [[19]] ## [[19]]$name ## [1] &quot;Cersei Lannister&quot; ## ## [[19]]$gender ## [1] &quot;Female&quot; ## ## [[19]]$born ## [1] &quot;In 266 AC, at Casterly Rock&quot; ## ## ## [[20]] ## [[20]]$name ## [1] &quot;Eddard Stark&quot; ## ## [[20]]$gender ## [1] &quot;Male&quot; ## ## [[20]]$born ## [1] &quot;In 263 AC, at Winterfell&quot; ## ## ## [[21]] ## [[21]]$name ## [1] &quot;Jaime Lannister&quot; ## ## [[21]]$gender ## [1] &quot;Male&quot; ## ## [[21]]$born ## [1] &quot;In 266 AC, at Casterly Rock&quot; ## ## ## [[22]] ## [[22]]$name ## [1] &quot;Jon Connington&quot; ## ## [[22]]$gender ## [1] &quot;Male&quot; ## ## [[22]]$born ## [1] &quot;In or between 263 AC and 265 AC&quot; ## ## ## [[23]] ## [[23]]$name ## [1] &quot;Jon Snow&quot; ## ## [[23]]$gender ## [1] &quot;Male&quot; ## ## [[23]]$born ## [1] &quot;In 283 AC&quot; ## ## ## [[24]] ## [[24]]$name ## [1] &quot;Aeron Greyjoy&quot; ## ## [[24]]$gender ## [1] &quot;Male&quot; ## ## [[24]]$born ## [1] &quot;In or between 269 AC and 273 AC, at Pyke&quot; ## ## ## [[25]] ## [[25]]$name ## [1] &quot;Kevan Lannister&quot; ## ## [[25]]$gender ## [1] &quot;Male&quot; ## ## [[25]]$born ## [1] &quot;In 244 AC&quot; ## ## ## [[26]] ## [[26]]$name ## [1] &quot;Melisandre&quot; ## ## [[26]]$gender ## [1] &quot;Female&quot; ## ## [[26]]$born ## [1] &quot;At Unknown&quot; ## ## ## [[27]] ## [[27]]$name ## [1] &quot;Merrett Frey&quot; ## ## [[27]]$gender ## [1] &quot;Male&quot; ## ## [[27]]$born ## [1] &quot;In 262 AC&quot; ## ## ## [[28]] ## [[28]]$name ## [1] &quot;Quentyn Martell&quot; ## ## [[28]]$gender ## [1] &quot;Male&quot; ## ## [[28]]$born ## [1] &quot;In 281 AC, at Sunspear, Dorne&quot; ## ## ## [[29]] ## [[29]]$name ## [1] &quot;Samwell Tarly&quot; ## ## [[29]]$gender ## [1] &quot;Male&quot; ## ## [[29]]$born ## [1] &quot;In 283 AC, at Horn Hill&quot; ## ## ## [[30]] ## [[30]]$name ## [1] &quot;Sansa Stark&quot; ## ## [[30]]$gender ## [1] &quot;Female&quot; ## ## [[30]]$born ## [1] &quot;In 286 AC, at Winterfell&quot; What if we want this to be a data frame instead? We can use map_dfr to get a data frame that is formed by row-binding each element in the list. purrr::map_dfr(got_chars, `[`, c(&quot;name&quot;, &quot;gender&quot;, &quot;born&quot;)) ## # A tibble: 30 x 3 ## name gender born ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Theon Greyjoy Male &quot;In 278 AC or 279 AC, at Pyke&quot; ## 2 Tyrion Lannister Male &quot;In 273 AC, at Casterly Rock&quot; ## 3 Victarion Greyjoy Male &quot;In 268 AC or before, at Pyke&quot; ## 4 Will Male &quot;&quot; ## 5 Areo Hotah Male &quot;In 257 AC or before, at Norvos&quot; ## 6 Chett Male &quot;At Hag&#39;s Mire&quot; ## 7 Cressen Male &quot;In 219 AC or 220 AC&quot; ## 8 Arianne Martell Female &quot;In 276 AC, at Sunspear&quot; ## 9 Daenerys Targaryen Female &quot;In 284 AC, at Dragonstone&quot; ## 10 Davos Seaworth Male &quot;In 260 AC or before, at King&#39;s Landing&quot; ## # … with 20 more rows # Equivalent to purrr::map(got_chars, `[`, c(&quot;name&quot;, &quot;gender&quot;, &quot;born&quot;)) %&gt;% dplyr::bind_rows() ## # A tibble: 30 x 3 ## name gender born ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Theon Greyjoy Male &quot;In 278 AC or 279 AC, at Pyke&quot; ## 2 Tyrion Lannister Male &quot;In 273 AC, at Casterly Rock&quot; ## 3 Victarion Greyjoy Male &quot;In 268 AC or before, at Pyke&quot; ## 4 Will Male &quot;&quot; ## 5 Areo Hotah Male &quot;In 257 AC or before, at Norvos&quot; ## 6 Chett Male &quot;At Hag&#39;s Mire&quot; ## 7 Cressen Male &quot;In 219 AC or 220 AC&quot; ## 8 Arianne Martell Female &quot;In 276 AC, at Sunspear&quot; ## 9 Daenerys Targaryen Female &quot;In 284 AC, at Dragonstone&quot; ## 10 Davos Seaworth Male &quot;In 260 AC or before, at King&#39;s Landing&quot; ## # … with 20 more rows 12.3 Creating List-columns Data structures in R are typically list-based in one way or another. Sometimes, more complicated data structures are actually lists of lists, or tibbles with a list-column, or other variations on “list within a ____”. In combination with purrr, this is an incredibly powerful setup that can make working with simulations and data very easy. Suppose, for instance, I want to simulate some data for modeling purposes, where I can control the number of outliers in the dataset: data_sim &lt;- function(n_outliers = 0) { tmp &lt;- tibble(x = seq(-10, 10, .1), y = rnorm(length(x), mean = x, sd = 1)) outlier_sample &lt;- c(NULL, sample(tmp$x, n_outliers)) # Create outliers tmp %&gt;% mutate( is_outlier = x %in% outlier_sample, y = y + is_outlier * sample(c(-1, 1), n(), replace = T) * runif(n(), 5, 10) ) } data_sim() ## # A tibble: 201 x 3 ## x y is_outlier ## &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 -10 -8.88 FALSE ## 2 -9.9 -9.13 FALSE ## 3 -9.8 -9.64 FALSE ## 4 -9.7 -9.30 FALSE ## 5 -9.6 -10.5 FALSE ## 6 -9.5 -11.8 FALSE ## 7 -9.4 -10.5 FALSE ## 8 -9.3 -9.45 FALSE ## 9 -9.2 -9.07 FALSE ## 10 -9.1 -7.42 FALSE ## # … with 191 more rows Now, lets suppose that I want 100 replicates of each of 0, 5, 10, and 20 outliers. sim &lt;- crossing(rep = 1:100, n_outliers = c(0, 5, 10, 20)) %&gt;% mutate(sim_data = purrr::map(n_outliers, data_sim)) I could use unnest(sim_data) if I wanted to expand my data a bit to see what I have, but in this case, it’s more useful to leave it in its current, compact form. Instead, suppose I fit a linear regression to each of the simulated data sets, and store the fitted linear regression object in a new list-column? sim &lt;- sim %&gt;% mutate(reg = purrr::map(sim_data, ~lm(data = ., y ~ x))) Here, we use an anonymous function in purrr: by using ~{expression}, we have defined a function that takes the argument . (which is just a placeholder). So in our case, we’re saying “use the data that I pass in to fit a linear regression of y using x as a predictor”. Let’s play around a bit with this: We might want to look at our regression coefficients or standard errors to see how much the additional outliers affect us. We could use a fancy package for tidy modeling, such as broom, but for now, lets do something a bit simpler and apply the purrr name extraction functions we used earlier. It can be helpful to examine one of the objects just to see what you’re dealing with: str(sim$reg[[1]]) ## List of 12 ## $ coefficients : Named num [1:2] -0.241 1.015 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; ## $ residuals : Named num [1:201] -0.2395 1.0206 -0.0367 0.318 -0.2776 ... ## ..- attr(*, &quot;names&quot;)= chr [1:201] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ effects : Named num [1:201] 3.423 83.47 -0.124 0.231 -0.363 ... ## ..- attr(*, &quot;names&quot;)= chr [1:201] &quot;(Intercept)&quot; &quot;x&quot; &quot;&quot; &quot;&quot; ... ## $ rank : int 2 ## $ fitted.values: Named num [1:201] -10.39 -10.29 -10.19 -10.08 -9.98 ... ## ..- attr(*, &quot;names&quot;)= chr [1:201] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ assign : int [1:2] 0 1 ## $ qr :List of 5 ## ..$ qr : num [1:201, 1:2] -14.1774 0.0705 0.0705 0.0705 0.0705 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:201] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;x&quot; ## .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## ..$ qraux: num [1:2] 1.07 1.11 ## ..$ pivot: int [1:2] 1 2 ## ..$ tol : num 1e-07 ## ..$ rank : int 2 ## ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## $ df.residual : int 199 ## $ xlevels : Named list() ## $ call : language lm(formula = y ~ x, data = .) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language y ~ x ## .. ..- attr(*, &quot;variables&quot;)= language list(y, x) ## .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:2] &quot;y&quot; &quot;x&quot; ## .. .. .. ..$ : chr &quot;x&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;x&quot; ## .. ..- attr(*, &quot;order&quot;)= int 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x55ddc3dde378&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(y, x) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;y&quot; &quot;x&quot; ## $ model :&#39;data.frame&#39;:\t201 obs. of 2 variables: ## ..$ y: num [1:201] -10.63 -9.27 -10.22 -9.77 -10.26 ... ## ..$ x: num [1:201] -10 -9.9 -9.8 -9.7 -9.6 -9.5 -9.4 -9.3 -9.2 -9.1 ... ## ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language y ~ x ## .. .. ..- attr(*, &quot;variables&quot;)= language list(y, x) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;y&quot; &quot;x&quot; ## .. .. .. .. ..$ : chr &quot;x&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;x&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: 0x55ddc3dde378&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(y, x) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;y&quot; &quot;x&quot; ## - attr(*, &quot;class&quot;)= chr &quot;lm&quot; If we pull out the coefficients by name we get a vector of length two. So before we unnest, we need to change that so that R formats it as a row of a data frame. sim$reg[[1]]$coefficients %&gt;% as_tibble_row() ## # A tibble: 1 x 2 ## `(Intercept)` x ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.241 1.01 This will make our formatting a lot easier and prevent any duplication that might occur if we unnest a vector that has length &gt; 1. sim &lt;- sim %&gt;% mutate(coefs = purrr::map(reg, &quot;coefficients&quot;) %&gt;% purrr::map(as_tibble_row)) sim$coefs[1:5] ## [[1]] ## # A tibble: 1 x 2 ## `(Intercept)` x ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.241 1.01 ## ## [[2]] ## # A tibble: 1 x 2 ## `(Intercept)` x ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.283 1.02 ## ## [[3]] ## # A tibble: 1 x 2 ## `(Intercept)` x ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0.232 1.00 ## ## [[4]] ## # A tibble: 1 x 2 ## `(Intercept)` x ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.0635 1.03 ## ## [[5]] ## # A tibble: 1 x 2 ## `(Intercept)` x ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.0625 1.03 Then, we can plot our results: sim %&gt;% unnest(coefs) %&gt;% select(rep, n_outliers, `(Intercept)`, x) %&gt;% pivot_longer(-c(rep, n_outliers), names_to = &quot;coef&quot;, values_to = &quot;value&quot;) %&gt;% ggplot(aes(x = value, color = factor(n_outliers))) + geom_density() + facet_wrap(~coef, scales = &quot;free_x&quot;) So as there are more and more outliers, the coefficient estimates get a wider distribution, but remain (relatively) centered on the “true” values of 0 and 1, respectively. Notice that we keep our data in list column form right up until it is time to actually unnest it - which means that we have at the ready the simulated data, the simulated model, and the conditions under which it was simulated, all in the same data structure. It’s a really nice, organized system. References The Joy of Functional Programming (for Data Science): Hadley Wickham’s talk on purrr and functional programming. ~1h video and slides. (The Joy of Cooking meets Data Science, with illustrations by Allison Horst) Pirating Web Content Responsibly with R and purrr (a blog post in honor of international talk like a pirate day) Happy R Development with purrr Web mining with purrr Text Wrangling with purrr Setting NAs with purrr (uses the naniar package) Mappers with purrr - handy ways to make your code simpler if you’re reusing functions a lot. Function factories - code optimization with purrr Stats and Machine Learning examples with purrr "]
]
