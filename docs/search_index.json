[
["index.html", "Stat 850: Computing Tools for Statisticians Introduction", " Stat 850: Computing Tools for Statisticians Susan Vanderplas 2020-06-07 Introduction "],
["tools.html", "Module 1 Tools for Statistical Computing Module Objectives 1.1 R and RStudio 1.2 SAS 1.3 Version Control with Git 1.4 Easy Extra Setup Script 1.5 LaTeX 1.6 Topic Sequencing 1.7 Using Version Control", " Module 1 Tools for Statistical Computing The goal of this class is to expose you to basic computing skills in R and SAS, which are two of the more common languages for statistical computing (python is the 3rd most common, and is particularly popular in data science and machine learning, but will not be explicitly taught in this class.) Since we’ll be learning how to use a bunch of different software, the first step is to get everythign set up on your machine: git SAS 9.4 (or later) R (3.5 or higher) RStudio LaTeX You will also need to sign up for a GitHub account Module Objectives Set up R, Rstudio, SAS, LaTeX, and git on personal machines Use version control to track changes to documents and code 1.1 R and RStudio For an explanation of the differences between the R and RStudio and a short history lesson, see the expandable section below. R is a statistical computing language which originated as an open-source clone of Bell labs S computing language. S was inspired by Scheme, but also has features which are similar to Lisp. It is a scripting language (you don’t have to compile the code before it runs) and is natively accessed using a command-line prompt. One feature of R that is relatively unique is that it uses vector-based math, which means that mathematical operations on vectors occur for the entire vector without having to use loops to iterate through the vector line-by-line (this feature is common in languages designed for data manipulation, like SAS, Matlab, and julia; it is rare in more general computing languages). R is optimized for working on data: unlike more general-purpose programming languages such as Python, R was built with the idea of facilitating data analysis. As a result, data structures in R tend to be more natural for statistical work than similar structures in Python or C, which can feel unwieldly. From a computer science perspective, though, R seems like an extremely odd language because the design choices that make data analysis easier are unconventional for more general-purpose languages. RStudio is an integrated development environment for R. Basically, it adds a pretty graphical layer on top of R, providing an easy way to develop R code, evaluate that code, and keep track of all of the variables which are available in the computing environment. RStudio contains integrations which provide syntax highlighting, code folding, basic checks (missing parentheses, etc.), debugging tools, and many other features. RStudio was designed around the idea of making R easier to use and making it easy to develop statistical software reproducibly. RStudio (the company) is responsible for adding many features to the R ecosystem which facilitate running statistical analyses and presenting the results in user-friendly ways. Another useful explanation of R and RStudio can be found in Section 1 of ModernDive’s book 1.1.1 Getting Set up: R Note that the tutorial videos use versions of R that are old. You should be installing at least R 3.5 (if you have an older version, please update.) The basic installation process is the same, though, so the videos are still useful. R on Windows installation: R on Mac installation: R on Linux installation: On Linux, instead of a youtube video, you get a text-based tutorial. One of the Debian maintainers, Dirk Eddelbuettel, is also on R core, which means that R tends to work extremely well with Debian-based distributions, like Ubuntu and Linux Mint. R does work on RPM based distros, and you can of course also compile it from source for Arch/Gentoo, but I’ve stuck with Deb-based distributions for approximately 7 years because it seems to be a bit less hassle. Additional troubleshooting can be found here. ### Getting Set up: RStudio You can find RStudio at https://rstudio.com/products/rstudio/download/. You want the open source edition of RStudio Desktop. If you’re feeling brave, you can install the preview release - this may have a few bugs, but tends to be relatively stable and has the latest features. Please install RStudio 1.3.9+ for this class. If you’re on Linux, go ahead and import RStudio’s public key so that software validation works. (All of the commands are provided in the linked page) 1.1.2 Exploring RStudio The RStudio window will look something like this. In the top-left pane is the text editor. This is where you’ll do most of your work. In the top right, you’ll find the environment, history, and connections tabs. The environment tab shows you the objects available in R (variables, data files, etc.), the history tab shows you what code you’ve run recently, and the connections tab is useful for setting up database connections. On the bottom left is the console. There are also other tabs to give you a terminal (command line) prompt, and a jobs tab to monitor progress of long-running jobs. In this class we’ll primarily use the console tab. On the bottom right, there are a set of tabs: - files (to give you an idea of where you are working, and what files are present), - plots (which will be self-explanatory), - packages (which extensions to R are installed and loaded), - the help window (where documentation will show up), and - the viewer window, which is used for interactive graphics or previewing HTML documents. To get started, type 2+2 into the console window and hit enter. Now, type 2+2 into the text editor and press the run button that is on the pane’s shortcut bar (or, you can hit Ctrl-Enter/CMD-Enter to send a single line to the console). If both of those things worked, you’re probably set up correctly! Next, try typing this into the text editor, then run the line. Look in the environment and see if you can see what has changed. a &lt;- 3 # store 3 in the variable a Your environment window should now look something like this (the .Last.value entry may not be there, and that’s ok) You can use the environment window to preview your data, check on the status of variables, and more. Note that while R is running, the window doesn’t update (so you can’t check on the status of a loop while the loop is running using the window). 1.2 SAS SAS is another extensively used statistical programming language. It is primarily used for mixed models and in the biostatistics community (for e.g. drug trials). For SAS installation, see Steve Westerholt. He manages UNL SAS installations. Note SAS looks different on different machines. On Linux, SAS looks like you took a time machine back to the early 1990s. Screenshots from SAS will likely look very different on your machine than on mine. I will try to integrate screenshots from other OS’s where it matters. 1.3 Version Control with Git You don’t want to end up here. Version control is the answer to this problem. Git is a program whose primary purpose is version control. Git tracks changes to each file that it is told to monitor, and as the files change, you provide short labels describing what the changes were and why they exist (called “commits”). The log of these changes (along with the file history) is called your git commit history. When writing papers, this means you can cut material out freely, so long as the paper is being tracked by git - you can always go back and get that paragraph you cut out if you need to. You also don’t have to rename files - you can confidently overwrite your files, so long as you remember to commit frequently. The git material in this chapter is just going to link directly to the book “Happy Git with R” by Jenny Bryan. It’s amazing, amusing, and generally well written. I’m not going to try to do better. Go read Chapter 1.. 1.3.1 Getting set up: github See the instructions here 1.3.2 Getting set up: git See the instructions here Write down, or keep track of, the git installation path. This will make your life much easier. There is a troubleshooting guide that has some common problems which occur during git installation. 1.3.3 Introduce yourself to git You need to tell git what your name and email address are, because every “commit” you make will be signed. You can follow the instructions here, or just wait and run the R script to install and configure R, LaTeX, and packages. 1.3.4 Optional: Install a git client Instructions 1.3.5 Git and Github Slightly crude (but memorable) analogy: Git is to GitHub what Porn is to PornHub Git is a program that runs on your machine and keeps track of changes to files that you tell it to monitor. If you want, you can hook Git up to GitHub, and make a copy of your local git repository that lives in the cloud. Then, if you configure things correctly, your local repository will talk to GitHub without too much trouble. Using Github with Git allows you to easily make a cloud backup of your important code, so that even if your computer suddenly catches on fire, all of your important code files exist somewhere else. Remember: any data you don’t have in 3 different places is data you don’t care about.1 1.4 Easy Extra Setup Script Run this script on your machine. It will ask you for some input - your name, email address, etc. Then it’s going to run for a while, installing some packages (read the code file if you want to know what it’s doing - I’ve provided short explanations of what each package does). source(&quot;srvanderplas.github.io/unl-stat850/code/01_setup_install.R&quot;) This script will set up git for you (e.g. the introduce yourself to git section above) and then will install tinytex, which is a version of LaTeX that is very simple and easy to install. 1.5 LaTeX LaTeX is a typesetting program, which makes it different from most other document creation software, such as MS Word, which is “WYSIWYG” - what you see is what you get. In LaTeX, you’ll type in code to create a document, and LaTeX will compile the document into something pretty. The goal is that you have to think less about formatting and what goes on which page - LaTeX will handle that part for you - so that you can think more about the content. In practice, it doesn’t usually work out like that, so there are programs like markdown which aim to simplify document creation even more to free you from the formatting that LaTeX requires. LaTeX is often used for typesetting statistical and mathematical papers because its equation editor is top notch. (It was actually written by Donald Knuth because he got so annoyed trying to write his dissertation that he took some time off to write TeX first, and then used it to write his dissertation).^[Amusingly, knitr was written in much the same manner. Yihui Xie had to substitute-teach ISU’s version of 850 on the day we covered Sweave (a predecessor to knitr). He got so frustrated teaching the class that he went home and started writing knitr. Later, he developed Rmarkdown, bookdown, blogdown, and several other packages aimed at making writing documents + code easier to handle. Moral of the story - if you get frustrated with the tools you have, you’re in good company. Use it as fuel to make better tools.] We’ll work with LaTeX later in the semester, but for now, we’ll be primarily working with Markdown, which is much simpler. Here’s a quick cheatsheet. 1.6 Topic Sequencing In several places in this class, you’ll have to use material that you haven’t been formally taught yet. I will do my absolute best to provide thorough instructions, help you along as much as I can, and generally provide enough support that you can muddle through. But it’s going to be hard to teach you everything you need to e.g. plot some data, before providing you the opportunity to SEE that data. And it’s silly to teach you plotting before you know how to read data in. But to teach you how to read data in, you need to know about functions. You see my problem. So instead, what I’m going to do is to leave you lots of comments as to what a piece of code does when I’m using things you haven’t been formally shown yet. Then, you can copy/paste/modify those pieces of code, and if they break, you can ask why and we’ll dig into it (this is a good thing!). For each chapter, focus on learning how to write code that accomplishes that chapter’s objectives. If you understand some of the code you’re modifying that covers other topics not in that chapter, so much the better. But it’s not an expectation or a requirement. If you’re confused, please post on the class message boards so that those who have seen this material before can help you out. 1.7 Using Version Control XXX Need to fix this - write when GitHub Classroom setup is known XXX Yes, I’m aware that this sounds paranoid. It’s been a very rare occasion that I’ve needed to restore something from another backup. You don’t want to take chances. I knew a guy who had to retype his entire masters thesis from the printed out version the night before it was due because he had stored it on a network drive that was decommissioned. You don’t want to be that guy.↩ "],
["intro-prog.html", "Module 2 Introduction to Statistical Programming Module Objectives Definitions Statistical Programming Languages 2.1 Variable types 2.2 Data structures 2.3 Control structures 2.4 Overgrown Calculators References and Links", " Module 2 Introduction to Statistical Programming The only way to learn how to program effectively is to take something that works, break it, and then fix it again. There’s plenty of theory and you should definitely learn that, but fundamentally, if you are not regularly breaking code, you’re probably not programming. Figure 2.1: This is basically the class summarized, in meme format. The goal for this chapter (and several chapters to come) is that you can modify example code and adapt it to the problem at hand. This is the best way to learn how to program, but it means you may break the code and not know how to fix it. If that happens, please try the following steps: Google the error and see if you can understand why it happened. Consult with a classmate to see if they can understand where things broke. Post to the discussion board and see if anyone in the class can understand where things broke. (When you do this, post all of the code relevant to the problem, and the error you’re getting, so that your classmates can replicate the problem) If you do not hopelessly break code during this chapter, then please do your best to help others who may not have previously programmed (or previously programmed in these languages). While writing this chapter, I came across about 10 errors in SAS that I’d never encountered before. If all else fails, while you’re waiting for someone to help you figure out what an error message means… try this approach. Module Objectives Identify variable types, data structures, and common reserved words in R and SAS Use control structures (loops and conditionals) effectively Use matrix algebra functionality in R and SAS to perform basic calculations More informally, the goal is to get familiar with the basics of each programming language. Definitions Many programming resources talk about 3, or 5, or 10 core concepts in any programming language. In this module, we’re going to discuss the generic concepts, and then how these concepts are implemented in R and SAS. Interestingly, the “core concepts” aren’t necessarily the same across lists. So, here is a consensus list of concepts which are generic across languages and usually important: Variables - a symbolic name or reference to some kind of information. In the expression a + b &gt; a, both a and b are variables. Variables may have a specific type (what data can be stored in the variable), scope (where the variable can be accessed), location (in memory). Here is a nice explanation of the difference between variables in programming and variables in math. Conditional statements (if statements) - These statements allow the program to handle information adaptively - if a statement is true, one set of instructions will be used, and if the statement is false, a different set of instructions will be used. Looping and iteration - An iteration is any time a sequence of steps is executed. Most languages have several different types of loops or iteration: for loops, which allow for the sequence of steps to be executed a specific number of times, while loops, which allow for the sequence of steps to be executed while a conditional statement is true, recursion, where a block of code calls itself. Data types and data structures - these concepts determine what information a variable can hold. Data types are lower-level, simple objects (floating-point numbers, integers, boolean T/F, characters, strings). Data structures may include lists (sequences of many objects) and vectors (sequences of many objects of the same type), dictionaries (a list of key-value pairs), objects (data structures which may hold multiple related pieces of information). Functions, or self-contained modules of code that accomplish a particular task. Syntax, the set of rules that define which combinations of symbols consist of correctly structured and interpretable commands in the language. Tools, the set of external programs which may help with development and writing code. Some common tools are IDEs (Integrated Development Environments), which may correct syntax and typos, organize files for you, allow you to keep track of which variables you have defined, and assist you with code organization and navigation. Other tools include compilers (which take human-written code and translate it into efficient machine code), version control systems (which help you track changes to code over time), debuggers, and documentation generators. Not all of these tools are necessary for all languages - scripting languages such as python and R do not require compilers by default, for instance. Sequence of commands: It’s important to have the right commands in the right order. Some recipes, like bread dough, are flexible, and you can add the ingredients in almost any order, but in other recipes, the order matters as much as the correct quantity of ingredients (try putting the cheese powder in before the noodles are boiled when making macaroni and cheese. Yuck.). Programming tends to be like these less flexible recipes. Statistical Programming Languages Having established the generic definitions of the concepts which apply to almost any programming language, we now must examine how R and SAS implement these concepts. R and SAS are both statistical programming languages - they are specifically designed to work with data, which means that they make compromises that other languages do not in order to make it easier to write code where the data (rather than the functions, classes, methods, or objects) are the primary concern. Both R and SAS have long histories. SAS in particular dates back to the 1960s, and has syntax which is unique compared to more modern languages such as C, python, Java, and R. R’s predecessor, S, dates back to 1976 and was designed for internal use at Bell Labs. The histories of both languages are useful in understanding why they are useful for their respective tasks, but are not essential for this course (so read them at your leisure). The biggest difference between R and SAS (at a fundamental level) is that R is a functional language - it consists mainly of functions, which can (and do) manipulate objects, including other functions. SAS, on the other hand, is a procedural language - most SAS programs follow a specific series of steps, known as “proc”s. Procs are essentially functions (or compositions of multiple functions), but in SAS, it is simpler to think of an analysis as a series of procedural steps; in R, there are steps, but they may be implemented in a more flexible way (depending on the analysis). Another interesting feature of SAS is that it’s really several languages - some commands work in PROC IML (interactive matrix language) but not in a DATA step. When looking for help in SAS, make sure you’re referencing the correct part of the language documentation. Basic Syntax and Cheatsheets SAS Cheatsheet (from another class like this) SAS Cheatsheet (by SAS) R Cheatsheet - this is a simplified cheat sheet offered by RStudio. R Cheatsheet (classic) SAS Programming for R Users (free book) I kept the classic R reference card by my computer for about 5 years, and referenced it at least once or twice a day for that entire period. There will be other cheat sheets and reference cards scattered through this book because if you can’t remember something’s name, you might be able to remember where it is on the reference card (or at least, that’s how I learned R). 2.1 Variable types Variable types are sufficiently different in R and SAS that we will cover R first, then SAS. 2.1.1 R In R, there are 4 commonly-used types: Type Description character holds text-based information: “abcd” or “3.24a” are examples of values which would be stored as characters in R logical holds binary information: 0/1, or FALSE/TRUE. Logical variables are stored as single bit information (e.g. either a 0 or 1), but display as TRUE and FALSE (which are reserved words and constants). It is possible to use the shorthand F and T, but be careful with this, because F and T are not reserved, and other information can be stored within them. integer holds (as you might expect) integers. Note that integers are handled differently than doubles (floating point numbers), but in general, R will implicitly convert integers to doubles to avoid common pitfalls with integer divison (which does not allow for decimals). double holds floating point numbers. By default, most numeric variables in R are doubles. You can test to see whether a variable holds a value of a specific type using the is.xxx() functions, which are demonstrated below. You can convert a variable of one type to another with as.xxx() functions. You can test what type a variable is using typeof(). Note that &lt;- is used for assigning a value to a variable. So the first line in the code below is read “x gets ‘R is awesome’” or “x is assigned the value ‘R is awesome’”. Demonstration of variable types: Character Variables x &lt;- &quot;R is awesome&quot; typeof(x) [1] &quot;character&quot; is.character(x) [1] TRUE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] FALSE Logical Variables x &lt;- FALSE typeof(x) [1] &quot;logical&quot; is.character(x) [1] FALSE is.logical(x) [1] TRUE is.integer(x) [1] FALSE is.double(x) [1] FALSE Integer Variables x &lt;- 2 typeof(x) [1] &quot;double&quot; is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] TRUE Wait, 2 is an integer, right? 2 is an integer, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically. x &lt;- 2L # The L immediately after the 2 indicates that it is an integer. typeof(x) [1] &quot;integer&quot; is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] TRUE is.double(x) [1] FALSE is.numeric(x) [1] TRUE Double Variables x &lt;- 2.45 typeof(x) [1] &quot;double&quot; is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] TRUE is.numeric(x) [1] TRUE Numeric Variables A fifth common “type”2, numeric is really the union of two types: integer and double, and you may come across it when using str() or mode(), which are similar to typeof() but do not quite do the same thing. The numeric category exists because when doing math, we can add an integer and a double, but adding an integer and a string is … trickier. Testing for numeric variables guarantees that we’ll be able to do math with those variables. is.numeric() and as.numeric() work as you would expect them to work. The general case of this property of a language is called implicit type conversion - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double. 2.1.1.1 Type Conversions R will generally work hard to seamlessly convert variables to different types. So, for instance, TRUE + 2 [1] 3 2L + 3.1415 [1] 5.1415 &quot;abcd&quot; + 3 Error in &quot;abcd&quot; + 3: non-numeric argument to binary operator This conversion doesn’t always work - there’s no clear way to make “abcd” into a number we could use in addition. So instead, R will issue an error. This error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops. When you want to, you can also use as.xxx() to make the type conversion explicit. So, the analogue of the code above, with explicit conversions would be: as.double(TRUE) + 2 [1] 3 as.double(2L) + 3.1415 [1] 5.1415 as.numeric(&quot;abcd&quot;) + 3 Warning: NAs introduced by coercion [1] NA When we make our intent explicit (convert “abcd” to a numeric variable) we get an NA - a missing value. There’s still no easy way to figure out where “abcd” is on a number line, but our math will still have a result - NA + 3 is NA. If you are unsure what the type of a variable is, use the typeof() function to find out. w &lt;- &quot;a string&quot; x &lt;- 3L y &lt;- 3.1415 z &lt;- FALSE typeof(w) [1] &quot;character&quot; typeof(x) [1] &quot;integer&quot; typeof(y) [1] &quot;double&quot; typeof(z) [1] &quot;logical&quot; 2.1.1.2 Factors In R, there is one other type of variable to know about, and that is a factor. Factors are basically labeled integers. Instead of storing the data as a string or character, R instead stores the data as a series of integers, and then stores a separate table mapping the integers to labels. This is technically more efficient, but it is also (and this is the technical term) a pain in the ass. Factors are the default way to store characters for most base R functions. Or rather, they were. In R 4.0, the default way to read data in will change from stringsAsFactors = T to stringsAsFactors = F.3 Let’s look at the names of the months: month.name [1] &quot;January&quot; &quot;February&quot; &quot;March&quot; &quot;April&quot; &quot;May&quot; &quot;June&quot; [7] &quot;July&quot; &quot;August&quot; &quot;September&quot; &quot;October&quot; &quot;November&quot; &quot;December&quot; df &lt;- data.frame(num = 1:12, name = month.name, stringsAsFactors = T) # I&#39;m putting the argument in so that this is still relevant when everyone switches to R 4.0 # Even with stringsAsFactors = F, factors are still useful and we still need to work with them. str(df) &#39;data.frame&#39;: 12 obs. of 2 variables: $ num : int 1 2 3 4 5 6 7 8 9 10 ... $ name: Factor w/ 12 levels &quot;April&quot;,&quot;August&quot;,..: 5 4 8 1 9 7 6 2 12 11 ... Notice that as soon as we make that data.frame, the months are converted into a factor variable? The other big problem is that the order of the factor levels is … not what we’d normally want. We don’t want alphabetical ordering of month names - they have a different, implicit, and natural order. To fix this, we can explicitly specify that we’re dealing with a factor, and what we want the levels to be. If you specify the levels manually (instead of letting R do the work for you) then you get to determine the order. month_fct &lt;- factor(month.name, levels = month.name) str(month_fct) Factor w/ 12 levels &quot;January&quot;,&quot;February&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... We can even be more explicit: month_fct &lt;- factor(month.name, levels = month.name, ordered = T) str(month_fct) Ord.factor w/ 12 levels &quot;January&quot;&lt;&quot;February&quot;&lt;..: 1 2 3 4 5 6 7 8 9 10 ... Making the factor ordered lets us explicitly say which levels are less than other levels. Factors are technically integers, with labels that are stored as an attribute. That doesn’t mean you can do math with them, though. month_fct[1] + month_fct[2] Warning in Ops.ordered(month_fct[1], month_fct[2]): &#39;+&#39; is not meaningful for ordered factors [1] NA Often, years or dates or other numeric-like information will end up as factor variables. When this happens, you need to be a little bit careful. # This works pretty naturally for months, right? as.numeric(month_fct) [1] 1 2 3 4 5 6 7 8 9 10 11 12 yfact &lt;- factor(2000:2020, levels = 2000:2020) yfact [1] 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 [16] 2015 2016 2017 2018 2019 2020 21 Levels: 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 ... 2020 # But, this does not... as.numeric(yfact) [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 as.character(yfact) # gets the labels [1] &quot;2000&quot; &quot;2001&quot; &quot;2002&quot; &quot;2003&quot; &quot;2004&quot; &quot;2005&quot; &quot;2006&quot; &quot;2007&quot; &quot;2008&quot; &quot;2009&quot; [11] &quot;2010&quot; &quot;2011&quot; &quot;2012&quot; &quot;2013&quot; &quot;2014&quot; &quot;2015&quot; &quot;2016&quot; &quot;2017&quot; &quot;2018&quot; &quot;2019&quot; [21] &quot;2020&quot; as.numeric(as.character(yfact)) # gets the info we want [1] 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 [16] 2015 2016 2017 2018 2019 2020 When converting factors with numeric labels, you need to first convert the factor to a character, and then to a numeric variable. That will get the information you actually want back out. 2.1.2 SAS In SAS, there are two basic variable types: numeric and character variables. Thus, SAS does not differentiate between integers and floats or doubles. Functionally, though, the same basic operations can be performed in SAS. As with R, SAS does attempt to implicitly convert variable types, and will notify you that the conversion has taken place in the log file. SAS will attempt to implicitly convert variables when: a character value is assigned to a previously defined numeric variable a character value is used in arithmetic operations a character value is compared to a numeric value using a comparison operator (&lt;, &gt;, &lt;=, &gt;=) a character value is specified in a function that takes numeric arguments Note that implicit conversion does not occur in WHERE statements. (This will make more sense later, but is here for reference) If you want to manually convert a value, the INPUT statement can be used. Unlike in R, the INPUT statement has the ability to read numbers which are formatted differently. For instance proc printto log=&quot;saslog.log&quot; new; data set1; /* This tells SAS we&#39;re defining some variables */ x = 3; y = &#39;3.1415&#39;; z = x * y; /* this is arithmetic, so y will be converted */ x = &#39;3.14159&#39;; /* x previously had a number in it, */ /* so it will be converted to a number here */ zz = y&lt;=2; /* comparison operator: y will be converted */ put z; /* This prints the result to the log */ put x=; put zz=; run; Notice that in SAS, zz, which is the result of the logical statement y&lt;=2, is a numeric variable. The value 0 signifies that the comparison was false. SAS does not have a logical data type, it uses the numeric variable with 0:=FALSE, 1:=TRUE. NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 7 data set1; /* This tells SAS we&#39;re defining some variables */ 8 x = 3; 9 y = &#39;3.1415&#39;; 10 z = x * y; 11 /* this is arithmetic, so y will be converted */ 12 x = &#39;3.14159&#39;; 13 /* x previously had a number in it, */ 14 /* so it will be converted to a number here */ 15 zz = y&lt;=2; 16 /* comparison operator: y will be converted */ 17 18 put z; /* This prints the result to the log */ 19 put x=; 20 put zz=; 21 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 10:11 12:7 15:8 9.4245 x=3.14159 zz=0 NOTE: The data set WORK.SET1 has 1 observations and 4 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds Try it out: Variable types In R Create variables string, integer, decimal, and logical, with types that match the relevant variable names. string &lt;- integer &lt;- decimal &lt;- logical &lt;- Can you get rid of the error that occurs when this chunk is run? logical + decimal integer + decimal string + integer What happens when you add string to string? logical to logical? In SAS Create variables string1 and string2 that each have text/character values. “Bob” and “Jane” might be good options. How does logical operation work with actual character values? What happens if you use string1 and add 3 to it? Answers string &lt;- &quot;hi, I&#39;m a string&quot; integer &lt;- 4L decimal &lt;- 5.412 logical &lt;- TRUE logical + decimal [1] 6.412 integer + decimal [1] 9.412 as.numeric(string) + integer Warning: NAs introduced by coercion [1] NA &quot;abcd&quot; + &quot;defg&quot; Error in &quot;abcd&quot; + &quot;defg&quot;: non-numeric argument to binary operator TRUE + TRUE [1] 2 In R, adding a string to a string creates an error (“non-numeric argument to binary operator”). Adding a logical to a logical, e.g. TRUE + TRUE, results in 2, which is a numeric value. proc printto log=&quot;saslog.log&quot; new; data set1; string1 = &#39;Bob&#39;; string2 = &#39;Jane&#39;; x = string1 &lt; string2; put x=; /* This prints the result to the log */ run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 8 data set1; 9 string1 = &#39;Bob&#39;; 10 string2 = &#39;Jane&#39;; 11 x = string1 &lt; string2; 12 put x=; /* This prints the result to the log */ 13 run; x=1 NOTE: The data set WORK.SET1 has 1 observations and 3 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.01 seconds 14 SAS will actually compare strings based on the first letter: Bob comes before Jane, so Bob &lt; Jane. proc printto log=&quot;saslog.log&quot; new; data set2; string1 = &#39;Bob&#39;; y = string1 + 3; put y=; run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 8 data set2; 9 string1 = &#39;Bob&#39;; 10 y = string1 + 3; 11 put y=; 12 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 10:7 NOTE: Invalid numeric data, string1=&#39;Bob&#39; , at line 10 column 7. y=. string1=Bob y=. _ERROR_=1 _N_=1 NOTE: Missing values were generated as a result of performing an operation on missing values. Each place is given by: (Number of times) at (Line):(Column). 1 at 10:15 NOTE: The data set WORK.SET2 has 1 observations and 2 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.01 seconds 2.2 Data structures Data structures are more complex arrangements of information than single variables. Of primary interest in statistical programming are the following types of structures:   Homogeneous Heterogeneous 1d vector list 2d matrix data frame (R) or data set (SAS) nd array (R) In the table above, homogeneous means that all entries in the structure must be of the same type. Heterogeneous means that the entries are allowed to be of different types. Figuring out what to call these types with two languages is hard - in SAS, an array is a group of columns of a data set, but in R, it’s a multi-dimensional matrix. In this section, we’ll discuss the generic concepts relevant to both languages. The differences between the two languages will be discussed as appropriate. As there are more similarities than differences, it’s easier to do this in a single section rather than duplicating half of the content. 2.2.1 Homogeneous data structures (R and SAS) R does not have scalar types - even single-value variables are technically vectors of length 1. SAS does have scalar types. If we try to create a heterogeneous vector in R, using the concatenate function, c(), which combines scalar entries into a vector, what happens? c(1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) [1] &quot;1&quot; &quot;2&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; Because there were 3 character entries, the entire vector is now a character vector. Watch Out This behavior can cause some errors - for instance, R does not read in numeric data formatted with commas as numeric data. You may thus get the result x &lt;- c(356, 452, &quot;1,325&quot;) mean(x) Warning in mean.default(x): argument is not numeric or logical: returning NA [1] NA If you are reading in data from a file, this will cause some issues - the whole column of data will be formatted as characters. Keep an eye out for errors of this type. 2.2.1.1 Indexing The 1, 2, and multi-dimensional homogeneous data types should be familiar from e.g. linear algebra and calculus. Single elements of a vector can be extracted using single square brackets, e.g. x[1] will get the first element of the vector x. In a matrix, elements are indexed as row, column, so to get the (2, 2) entry of a matrix x, you would use x[2,2]. This is extended for multi-dimensional arrays in R, with each dimension added, e.g. x[3,1,2] or x[4, 3, 2, 1]. To get a full row or column from a matrix (in both SAS and R) you would use x[1,] (get the first row) or x[,3] (get the 3rd column). To select multiple rows or columns from a matrix, you would use x[, c(1, 3)] in R or x[,{1 3}] in SAS - both options get the first and third column of the matrix, with all rows of data included. In both R and SAS, a:b where a and b are numbers will form a sequence from a to b by 1s. So 1:4 is 1, 2, 3, 4. This is often used to get a set of rows or columns: x[3:4, 1:2]. x &lt;- matrix(1:20, nrow = 5, byrow = T) # Create a matrix with values 1 to 20, 5 rows, and fill by row x [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 [4,] 13 14 15 16 [5,] 17 18 19 20 x[3:4, 1:2] [,1] [,2] [1,] 9 10 [2,] 13 14 # Gets a submatrix In SAS, the same basic code works (though matrix definition is a bit more manual). proc iml; /* Interactive Matrix Language */ x = {1 2 3 4 5, 6 7 8 9 10, 11 12 13 14 15, 16 17 18 19 20}; y = x[3:4, 1:2]; print x; /* Here, print is used instead of put */ print y; quit; /* exit proc IML */ x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 y 11 12 16 17 Both R and SAS are 1-indexed languages, so the elements of a list or vector are indexed as 1, 2, 3, 4, …4 As R has logical vectors, it is possible to index a vector using a logical vector of the same length. Try it out # From project Euler # If we list all the natural numbers below 10 that are multiples of 3 or 5, # we get 3, 5, 6 and 9. The sum of these multiples is 23. # Find the sum of all the multiples of 3 or 5 below 1000. # Hint: The modulo operator, `%%`, gives the integer remainder of one number # divided by another. So `a %% b` gives the integer remainder when # dividing `a` by `b`. Modular division is often used to find multiples # of a number. Answers In R: x &lt;- 1:999 # all nums below 1000 m3 &lt;- (x %% 3) == 0 # multiple of 3 m5 &lt;- (x %% 5) == 0 # multiple of 5 m3or5 &lt;- m3 | m5 sum(x[m3or5]) [1] 233168 In SAS: data tmp; do x = 1 to 999; output; end; run; proc summary data=tmp; /* Summarize data */ where (mod(x, 3) = 0) | (mod(x, 5) = 0); /* Keep only obs where x is divisible by 3 or 5 */ var x; /* what variable we want the summary for */ output out=sum_x sum=; /* output sum_x to a new dataset */ run; proc print data = sum_x; /* print our sum_x dataset */ run; Obs TYPE FREQ x 1 0 466 233168 2.2.2 Heterogeneous data structures The heterogeneous data types are not much harder to grasp, as they’re mostly different ways to combine various homogeneous data types. Lists A list is, well, a list - a sequence of potentially different-typed values. Unlike when concatenating values, the list() command in R allows each value to keep its natural type. You can access elements of a list using [] (this will extract a subset of the list items) or [[]], which will extract a single item from the list. x &lt;- list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3) x [[1]] [1] &quot;a&quot; [[2]] [1] &quot;b&quot; [[3]] [1] &quot;c&quot; [[4]] [1] 1 [[5]] [1] 2 [[6]] [1] 3 x[[3]] [1] &quot;c&quot; x[[4]] + x[[5]] [1] 3 x[1:2] # This will work [[1]] [1] &quot;a&quot; [[2]] [1] &quot;b&quot; x[[1:2]] # This won&#39;t work Error in x[[1:2]]: subscript out of bounds Some lists consist of named variables. These list components can be accessed either by index (as above) or by name, using the $ operator. Names which have spaces or special characters must be enclosed in backticks (next to the 1 on the keyboard). Named components can also be accessed using the [[ ]] operator. dog &lt;- list(name = &quot;Edison Vanderplas&quot;, age = 8, breed = &quot;Jack Russell Terrorist&quot;, `favorite toy` = &quot;a blue and orange stuffed duck. Or rawhide.&quot;, `link(video)` = &quot;https://youtu.be/zVeoQTOTIuQ&quot;) dog $name [1] &quot;Edison Vanderplas&quot; $age [1] 8 $breed [1] &quot;Jack Russell Terrorist&quot; $`favorite toy` [1] &quot;a blue and orange stuffed duck. Or rawhide.&quot; $`link(video)` [1] &quot;https://youtu.be/zVeoQTOTIuQ&quot; dog$name [1] &quot;Edison Vanderplas&quot; dog$breed [1] &quot;Jack Russell Terrorist&quot; dog$`favorite toy` [1] &quot;a blue and orange stuffed duck. Or rawhide.&quot; dog[[&quot;link(video)&quot;]] [1] &quot;https://youtu.be/zVeoQTOTIuQ&quot; Most complicated structures in R are lists. You should be able to access any of the pieces of a list using a combination of named references and indexing. You can get a sense of the structure of a list (or any other object) in R using the str() command. str(dog) List of 5 $ name : chr &quot;Edison Vanderplas&quot; $ age : num 8 $ breed : chr &quot;Jack Russell Terrorist&quot; $ favorite toy: chr &quot;a blue and orange stuffed duck. Or rawhide.&quot; $ link(video) : chr &quot;https://youtu.be/zVeoQTOTIuQ&quot; Lists can also contain other lists. When accessing a list-within-a-list, just add another index or name reference (see below). grocery_list &lt;- list( dairy = list(&quot;asiago&quot;, &quot;fontina&quot;, &quot;mozzarella&quot;, &quot;blue cheese&quot;), baking = list(&quot;flour&quot;, &quot;yeast&quot;, &quot;salt&quot;), canned_goods = list(&quot;pepperoni&quot;, &quot;pizza sauce&quot;, &quot;olives&quot;), meat = list(&quot;bacon&quot;, &quot;sausage&quot;, &quot;anchovies&quot;), veggies = list(&quot;bell pepper&quot;, &quot;onion&quot;, &quot;scallions&quot;, &quot;tomatoes&quot;, &quot;basil&quot;) ) ick &lt;- c(grocery_list[[4]][2:3], grocery_list$canned_goods[[3]]) ick [[1]] [1] &quot;sausage&quot; [[2]] [1] &quot;anchovies&quot; [[3]] [1] &quot;olives&quot; crust_ingredients &lt;- c(grocery_list$baking, &quot;water&quot;) crust_ingredients [[1]] [1] &quot;flour&quot; [[2]] [1] &quot;yeast&quot; [[3]] [1] &quot;salt&quot; [[4]] [1] &quot;water&quot; essential_toppings &lt;- c(grocery_list$dairy[3], grocery_list$canned_goods[2]) essential_toppings [[1]] [1] &quot;mozzarella&quot; [[2]] [1] &quot;pizza sauce&quot; yummy_toppings &lt;- c(grocery_list$dairy[c(1, 2, 4)], grocery_list$meat[1], grocery_list[[5]][c(3, 5)]) yummy_toppings [[1]] [1] &quot;asiago&quot; [[2]] [1] &quot;fontina&quot; [[3]] [1] &quot;blue cheese&quot; [[4]] [1] &quot;bacon&quot; [[5]] [1] &quot;scallions&quot; [[6]] [1] &quot;basil&quot; There are also lists in SAS IML which function similarly to lists in R. To create a named object in a list, precede the name with #. In SAS, the $ operator can be used to get items from a list, using either proc iml; grocery_list = [ #dairy = [&quot;asiago&quot;, &quot;fontina&quot;, &quot;mozzarella&quot;, &quot;blue cheese&quot;], #baking = [&quot;flour&quot;, &quot;yeast&quot;, &quot;salt&quot;], #canned = [&quot;pepperoni&quot;, &quot;pizza sauce&quot;, &quot;olives&quot;], #meat = [&quot;bacon&quot;, &quot;sausage&quot;, &quot;anchovies&quot;], #veggies= [&quot;bell pepper&quot;, &quot;onion&quot;, &quot;scallions&quot;, &quot;tomatoes&quot;, &quot;basil&quot;] ]; /* print only works on matrices and vectors */ /* so we&#39;ll cheat and load another library to print lists */ package load ListUtil; /* run ListPrint(grocery_list); */ /* This would print the thing, but it&#39;s long */ ick = [grocery_list$&quot;canned&quot;$3, grocery_list$4$2, grocery_list$4$3]; crust = grocery_list$&quot;baking&quot;; call ListAddItem(crust, &quot;water&quot;); /* add an item to a list */ essential_toppings = [grocery_list$&quot;dairy&quot;$3, grocery_list$&quot;canned&quot;$2]; yummy_toppings = [grocery_list$&quot;dairy&quot;$1, grocery_list$&quot;dairy&quot;$2, grocery_list$&quot;dairy&quot;$4, grocery_list$&quot;meat&quot;$1, grocery_list$5$3] ; /* The || is a concatenation operator, like c(). */ /* It is inefficient for large data sets */ run ListPrint(ick); run ListPrint(crust); run ListPrint(yummy_toppings); quit; ——— List = ick——— Item 1 olives Item 2 sausage Item 3 anchovies ——— List = crust——— Item 1 flour Item 2 yeast Item 3 salt Item 4 water ——— List = yummy_toppings——— Item 1 asiago Item 2 fontina Item 3 blue cheese Item 4 bacon Item 5 scallions Try it out Using the list of pizza toppings above as a starting point, make your own list of pizza toppings organized by grocery store section (approximately). Create your own vectors of yummy, essential, and ick toppings, using R and SAS. Data frames (R only) A data frame is a special type of list - one in which each element in the list is a vector of the same length. If you put these vectors side-by-side, you get a table of data that looks like a spreadsheet. When you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The head() command shows the first 6 rows of a data frame (enough to see what’s there, not enough to overflow your screen). head(mtcars) ## A data frame included in base R mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 str(mtcars) &#39;data.frame&#39;: 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... $ disp: num 160 160 108 258 360 ... $ hp : num 110 110 93 110 175 105 245 62 95 123 ... $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... $ wt : num 2.62 2.88 2.32 3.21 3.44 ... $ qsec: num 16.5 17 18.6 19.4 17 ... $ vs : num 0 0 1 1 0 1 0 1 1 1 ... $ am : num 1 1 1 0 0 0 0 0 0 0 ... $ gear: num 4 4 4 3 3 3 3 4 4 4 ... $ carb: num 4 4 1 1 2 1 4 2 2 4 ... You can change column values or add new columns easily using assignment. It’s also easy to access specific columns to perform summary operations. Often, it is useful to know the dimensions of a data frame. The number of rows can be obtained by using nrow(df) and similarly, the columns can be obtained using ncol(df) (or, get both with dim()). There is also an easy way to get a summary of each column in the data frame, using summary(). mtcars$gpm &lt;- 1/mtcars$mpg # gpm is sometimes used to assess efficiency summary(mtcars$gpm) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.02950 0.04386 0.05208 0.05423 0.06483 0.09615 summary(mtcars$mpg) Min. 1st Qu. Median Mean 3rd Qu. Max. 10.40 15.43 19.20 20.09 22.80 33.90 summary(mtcars) mpg cyl disp hp Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 Median :19.20 Median :6.000 Median :196.3 Median :123.0 Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 drat wt qsec vs Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 Median :3.695 Median :3.325 Median :17.71 Median :0.0000 Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 am gear carb gpm Min. :0.0000 Min. :3.000 Min. :1.000 Min. :0.02950 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 1st Qu.:0.04386 Median :0.0000 Median :4.000 Median :2.000 Median :0.05208 Mean :0.4062 Mean :3.688 Mean :2.812 Mean :0.05423 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 3rd Qu.:0.06483 Max. :1.0000 Max. :5.000 Max. :8.000 Max. :0.09615 Missing variables in an R data frame are indicated with NA. Try it out The dataset state.x77 contains information on US state statistics in the 1970s. By default, it is a matrix, but we can easily convert it to a data frame, as shown below. data(state) state_facts &lt;- data.frame(state.x77) state_facts &lt;- cbind(state = row.names(state_facts), state_facts, stringsAsFactors = F) # State names were stored as row labels # Store them in a variable instead, and add it to the data frame row.names(state_facts) &lt;- NULL # get rid of row names head(state_facts) state Population Income Illiteracy Life.Exp Murder HS.Grad Frost Area 1 Alabama 3615 3624 2.1 69.05 15.1 41.3 20 50708 2 Alaska 365 6315 1.5 69.31 11.3 66.7 152 566432 3 Arizona 2212 4530 1.8 70.55 7.8 58.1 15 113417 4 Arkansas 2110 3378 1.9 70.66 10.1 39.9 65 51945 5 California 21198 5114 1.1 71.71 10.3 62.6 20 156361 6 Colorado 2541 4884 0.7 72.06 6.8 63.9 166 103766 How many rows and columns does it have? Can you find at least 3 ways to get that information? The Illiteracy column contains the percent of the population of each state that is illiterate. Calculate the number of people in each state who are illiterate, and store that in a new column called TotalNumIlliterate. Note: Population contains the population in thousands. Calculate the average population density of each state (population per square mile) and store it in a new column PopDensity. Using the R reference card, can you find functions that you can combine to get the state with the minimum population density? # 3 ways to get rows and columns str(state_facts) &#39;data.frame&#39;: 50 obs. of 9 variables: $ state : chr &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ... $ Population: num 3615 365 2212 2110 21198 ... $ Income : num 3624 6315 4530 3378 5114 ... $ Illiteracy: num 2.1 1.5 1.8 1.9 1.1 0.7 1.1 0.9 1.3 2 ... $ Life.Exp : num 69 69.3 70.5 70.7 71.7 ... $ Murder : num 15.1 11.3 7.8 10.1 10.3 6.8 3.1 6.2 10.7 13.9 ... $ HS.Grad : num 41.3 66.7 58.1 39.9 62.6 63.9 56 54.6 52.6 40.6 ... $ Frost : num 20 152 15 65 20 166 139 103 11 60 ... $ Area : num 50708 566432 113417 51945 156361 ... dim(state_facts) [1] 50 9 nrow(state_facts) [1] 50 ncol(state_facts) [1] 9 # Illiteracy state_facts$TotalNumIlliterate &lt;- state_facts$Population * 1e3 * (state_facts$Illiteracy/100) # Population Density state_facts$PopDensity &lt;- state_facts$Population * 1e3/state_facts$Area # in people per square mile # minimum population state_facts$state[which.min(state_facts$PopDensity)] [1] &quot;Alaska&quot; Data Sets (SAS) The SAS data set structure is similar to a R data frame. This is a schematic of a data set as taken from the SAS documentation The biggest difference is that in SAS, missing values are indicated with .. SAS datasets also come with a description which is attached to the table. The descriptor portion of the data set records names of variables (and attributes), numbers of observations, and date/time stamps of creation and updates. /* Data source: http://blog.yhat.com/posts/7-funny-datasets.html */ data mathMJ; title &#39;Average math test scores under the influence of LSD&#39;; input Drugs Score; datalines; 1.17 78.93 2.97 58.20 3.26 67.47 4.69 37.47 5.83 45.65 6.00 32.92 6.41 29.97 ; /* Describe the dataset */ proc datasets; contents data = mathMJ; run; proc print data = mathMJ; run; Average math test scores under the influence of LSD Directory Libref WORK Engine V9 Physical Name /tmp/SAS_work25270000261A_silicon Filename /tmp/SAS_work25270000261A_silicon Inode Number 12461080 Access Permission rwx—— Owner Name susan File Size 4KB File Size (bytes) 4096 # Name Member Type File Size Last Modified 1 MATHMJ DATA 128KB 06/07/2020 17:37:56 2 PROFILE CATALOG 12KB 06/07/2020 17:37:56 3 REGSTRY ITEMSTOR 32KB 06/07/2020 17:37:56 4 SASMAC3 CATALOG 20KB 06/07/2020 17:37:56 Average math test scores under the influence of LSD Data Set Name WORK.MATHMJ Observations 7 Member Type DATA Variables 2 Engine V9 Indexes 0 Created 06/07/2020 17:37:57 Observation Length 16 Last Modified 06/07/2020 17:37:57 Deleted Observations 0 Protection Compressed NO Data Set Type Sorted NO Label Data Representation SOLARIS_X86_64, LINUX_X86_64, ALPHA_TRU64, LINUX_IA64 Encoding latin1 Western (ISO) Engine/Host Dependent Information Data Set Page Size 65536 Number of Data Set Pages 1 First Data Page 1 Max Obs per Page 4061 Obs in First Data Page 7 Number of Data Set Repairs 0 Filename /tmp/SAS_work25270000261A_silicon/mathmj.sas7bdat Release Created 9.0401M6 Host Created Linux Inode Number 12461085 Access Permission rw-rw-r– Owner Name susan File Size 128KB File Size (bytes) 131072 Alphabetic List of Variables and Attributes # Variable Type Len 1 Drugs Num 8 2 Score Num 8 Average math test scores under the influence of LSD Obs Drugs Score 1 1.17 78.93 2 2.97 58.20 3 3.26 67.47 4 4.69 37.47 5 5.83 45.65 6 6.00 32.92 7 6.41 29.97 2.3 Control structures 2.3.1 If statements If statements are just about as simple in programming as they are in real life. Figure 2.2: Source In general, the structure of an if statement is if (condition) then { # do something here } If the condition is true, the inner code will be executed. Otherwise, nothing happens. You can add an else statement that will execute if the condition is not true if (condition) then { # do something } else { # do a different thing } And in some languages, you can even have many sets of if statements: if (condition) { # do something } else if (condition 2) { # do something else } else { # do a third thing } Note that this could also be written (perhaps more clearly) as: if (condition) { # do something } else { if (condition 2) { # do something else } else { # do a third thing } } That is, condition 2 is only checked once it is known that condition is false. Often, programmers use logic flow maps, like the one shown below, to map out a logical sequence and ensure that every possible value is handled appropriately. If statement flow diagram, from wikimedia commons The syntax for conditional statements using if/then logic is shown below using an example where Santa must determine which members of a household will receive a toy for Christmas and which members will receive coal.5 Example In R: tmp &lt;- data.frame(name = c(&quot;Alex&quot;, &quot;Edison&quot;, &quot;Susan&quot;, &quot;Ryan&quot;), status = c(&quot;naughty&quot;, &quot;nice&quot;, NA, &quot;neutral&quot;), stringsAsFactors = F) # Santa&#39;s decision process if (tmp$status == &quot;naughty&quot;) { tmp$present &lt;- &quot;coal&quot; } else { tmp$present &lt;- &quot;toy&quot; } Warning in if (tmp$status == &quot;naughty&quot;) {: the condition has length &gt; 1 and only the first element will be used tmp name status present 1 Alex naughty coal 2 Edison nice coal 3 Susan &lt;NA&gt; coal 4 Ryan neutral coal What happened? When evaluating if statements, R does not evaluate each entry in the vector tmp$status separately. Instead, it takes the first value and issues a warning message. One option would be to use a loop, and examine each row in the data set separately. We’ll talk about loops in the next subsection. Another option is to use the ifelse() function, which is ifelse(condition, thing to do if condition is true, thing to do if condition is false) tmp$present &lt;- ifelse(tmp$status == &quot;naughty&quot;, &quot;coal&quot;, &quot;toy&quot;) tmp name status present 1 Alex naughty coal 2 Edison nice toy 3 Susan &lt;NA&gt; &lt;NA&gt; 4 Ryan neutral toy When R evaluates a missing value, (so ? NA == “naughty”), the result is NA. This is fine for us - if we don’t have data on whether someone is naughty or nice, maybe we don’t need to give them a present at all. But “neutral” is evaluated as getting a toy. Do we want that to happen? Maybe not. We might have to nest ifelse statements to solve this issue… tmp$present &lt;- ifelse(tmp$status == &quot;naughty&quot;, &quot;coal&quot;, ifelse(tmp$status == &quot;nice&quot;, &quot;toy&quot;, NA)) tmp name status present 1 Alex naughty coal 2 Edison nice toy 3 Susan &lt;NA&gt; &lt;NA&gt; 4 Ryan neutral &lt;NA&gt; In SAS: In a data step: data santa; input name $ status $; datalines; Edison nice Alex naughty Susan . Ryan neutral ; /* Modify santa_list and make a new dataset, present_list */ data presents; set santa; if status = &quot;naughty&quot; then present = &quot;coal&quot;; else present = &quot;toy&quot;; run; /* must end with run if no datalines option */ proc print data=presents; run; Obs name status present 1 Edison nice toy 2 Alex naughty coal 3 Susan toy 4 Ryan neutral toy Note that ., or missing data is handled the same as ‘nice’. That might not be what we wanted… this is the natural thing to do, right? data santa; input name $ status $; datalines; Edison nice Alex naughty Susan . Ryan neutral ; /* Modify santa_list and make a new dataset, present_list */ data presents; set santa; if status = &quot;naughty&quot; then present = &quot;coal&quot;; else (if status = &quot;nice&quot; then present = &quot;toy&quot; else present = .); run; /* must end with run if no datalines option */ proc print data=presents; run; SAS doesn’t handle nested if statements very well - they can be ambiguous. Instead, SAS documentation suggests using do; and end; to denote the start and end points of each if statement (like the {} in R). data santa; input name $ status $; datalines; Edison nice Alex naughty Susan . Ryan neutral ; data presents; set santa; if status = &quot;naughty&quot; then do; present = &quot;coal&quot;; end; else if status = &quot;nice&quot; then do; present = &quot;toy&quot;; end; else do; present = .; end; run; proc print data=presents; run; Obs name status present 1 Edison nice toy 2 Alex naughty coal 3 Susan . 4 Ryan neutral . Interestingly, if you set a character variable to be missing, SAS converts it to ‘.’. So, if we actually want to have the value be missing, we can set it to an empty string. data santa; input name $ status $; datalines; Edison nice Alex naughty Susan . Ryan neutral ; data presents; set santa; if status = &quot;naughty&quot; then do; present = &quot;coal&quot;; end; else if status = &quot;nice&quot; then do; present = &quot;toy&quot;; end; else do; present = &#39;&#39;; end; run; proc print data=presents; run; Obs name status present 1 Edison nice toy 2 Alex naughty coal 3 Susan 4 Ryan neutral Now things work the way we expected them to work. There are more complicated if-statement like control structures, such as switch statements, which can save time and typing. In the interests of simplicity, we will skip these for now, as any conditional can be implemented with sequences of if statements in the proper order. If you would like to read about switch statements, here are links to SAS case statement documentation and base R switch statement explanation and documentation. Try it out The sample() function selects a random sample of entries from a vector. Suppose we sample a random vector \\(x\\) with 10 entries. Write one or more if statements to fulfill the following conditions if \\(x\\) is divisible by 2, \\(y\\) should be positive; otherwise, it should be negative. if \\(x\\) is divisible by 3, \\(y\\) should have a magnitude of 2; otherwise, it should have a magnitude of 1. It may be helpful to define separate variables y_mag and y_sign and then multiply them afterwards. Once you have found the value of \\(y\\) compute \\(\\text{sum}(x * y)\\). You may use the following R and SAS code skeletons to set the problem up. set.seed(342502837) x &lt;- sample(1:50, size = 20, replace = F) # Conditional statements go here sum(x * y) [1] 1567.609 proc iml; call randseed(342502837); x = sample(1:50, 20)`; create sampledata from x [colname = &quot;x&quot;]; append from x; close; quit; data xy; set sampledata; /* Conditional statements go here */ /* Leave this so that the code below works */ res = x * y; run; proc summary data=xy; /* Summarize data */ var res; /* what variable we want the summary for */ output out=tmpsum sum=; /* output tmpsum to a new dataset */ run; proc print data = xy; /* print our original dataset to check result */ var x y res; sum res; run; proc print data = tmpsum; /* print our tmpsum dataset */ run; Solutions R Solution set.seed(342502837) x &lt;- sample(1:50, size = 20, replace = F) y_sign &lt;- ifelse(x %% 2 == 0, 1, -1) y_mag &lt;- ifelse(x %% 3 == 0, 2, 1) y &lt;- y_sign * y_mag sum(x * y) [1] 157 SAS Solution proc iml; call randseed(342502837); x = sample(1:50, 20)`; create sampledata from x [colname = &quot;x&quot;]; append from x; close; quit; data xy; set sampledata; y_sign = 0 * x; y_mag = 0 * x; /* Conditional statements go here */ if MOD(x, 2) = 0 then y_sign = 1; else y_sign = -1; if MOD(x, 3) = 0 then y_mag = 2; else y_mag = 1; y = y_sign * y_mag; res = x * y; run; proc summary data=xy; /* Summarize data */ var res; /* what variable we want the summary for */ output out=tmpsum sum=; /* output tmpsum to a new dataset */ run; proc print data = xy; /* print our original dataset to check result */ var x y res; sum res; run; proc print data = tmpsum; /* print our tmpsum dataset */ run; Obs x y res 1 44 1 44 2 42 2 84 3 1 -1 -1 4 7 -1 -7 5 42 2 84 6 13 -1 -13 7 27 -2 -54 8 19 -1 -19 9 41 -1 -41 10 16 1 16 11 6 2 12 12 44 1 44 13 26 1 26 14 48 2 96 15 22 1 22 16 15 -2 -30 17 40 1 40 18 1 -1 -1 19 27 -2 -54 20 13 -1 -13 235 Obs TYPE FREQ res 1 0 20 235 See this to understand how the print statement works and how to add column summary values. 2.3.2 Loops Often, we need to do a single task many times - for instance, we may need to calculate the average data value for each week, using daily data. Rather than typing out 52 different iterations of the same code, it is likely easier to type out one single block of code which contains the steps necessary to complete one instance of the task, and then leverage variables to ensure that each task is completed the correct number of times, using the correct inputs. Let us start with the most generic loop written in pseudocode (code that won’t work, but provides the general idea of the steps which are taken) loop_invocation(iteration variable, exit condition) { # Steps to repeat } We use the loop_invocation function to indicate what type of loop we use. We have at least one iteration variable that indicates where in the looping process we currently are. This may be an index (if we want to do something 500 times, it would take values from 1 to 500), or it may take a more complicated sequence of values (for instance, if we are testing convergence, we might put some sort of delta variable as the iteration variable). Most loops also have an explicit exit condition that is part of the loop invocation; more rarely, a loop may depend on break statements that cause the control flow of the code to exit. Without some sort of exit condition, our program would run forever, which is… not optimal. 2.3.2.1 Count controlled loops (FOR loops) In a for loop, the steps in the loop body repeat a specified number of times. That is, for each value in a sequence, the steps within the loop are repeated. Example: Santa and if/else + loops in R (plus some debugging strategies) For instance, suppose we want to revisit our R Santa example from the previous section. The original if/else code we wrote in R didn’t work, because R evaluates if statements using a single (scalar or vector of length 1) condition. If we add a loop around that code, we can evaluate only one row at a time. We need to check every row, so we’ll iterate over 1:nrow(tmp) - it’s better to get the upper bound from the data frame, rather than just using 4 - if we add another entry, the code will still work if we’re using nrow(tmp) to define how many iterations we need. We start by defining our data frame: tmp &lt;- data.frame(name = c(&quot;Alex&quot;, &quot;Edison&quot;, &quot;Susan&quot;, &quot;Ryan&quot;), status = c(&quot;naughty&quot;, &quot;nice&quot;, NA, &quot;neutral&quot;), stringsAsFactors = F) And then we add the basic loop syntax: for (i in 1:nrow(tmp)) { } For some reason, i is often used as the iteration variable (with j and k for nested loops). What this loop says is that i will first take on the value 1, then 2, then 3, then 4. On each iteration, i will advance to the next value in the vector of options we have provided. Now we need to add the middle part by adapting the conditional statement we used before so that it looks at only the ith row. I’ve also added the catch-all else condition that assigns NA for any value that isn’t “naughty” or “nice”. It’s good practice to initialize your variable (create a column for it) ahead of time and set the variable to a default value. tmp$present &lt;- NA # Initialize column and set to NA by default for (i in 1:nrow(tmp)) { # Santa&#39;s decision process if (tmp$status[i] == &quot;naughty&quot;) { tmp$present[i] &lt;- &quot;coal&quot; } else if (tmp$status[i] == &quot;nice&quot;) { tmp$present[i] &lt;- &quot;toy&quot; } else { tmp$present[i] &lt;- NA_character_ # use a special NA value that has # character type to avoid any issues } } Error in if (tmp$status[i] == &quot;naughty&quot;) {: missing value where TRUE/FALSE needed Well, that didn’t work! We can see that the loop stopped at i = 3 by printing out the value of i - because the loop failed, i will still contain the value which caused the loop to stop. i [1] 3 tmp[i,] # print tmp at that point name status present 3 Susan &lt;NA&gt; &lt;NA&gt; Combining this information with the error above, we can guess that R stopped evaluating the loop because the if statement returned NA (missing) instead of TRUE or FALSE. if/else statements in R can’t evaluate to NA, so we need to restructure our conditional statement - first, we’ll test for NA values, then, we can test for naughty and nice, and we’ll keep the catch-all statement at the bottom. We’ll test for an NA value using the function is.na(). tmp$present &lt;- NA # Initialize column and set to NA by default for (i in 1:nrow(tmp)) { # Santa&#39;s decision process if (is.na(tmp$status[i])) { tmp$present[i] &lt;- NA_character_ } else if (tmp$status[i] == &quot;naughty&quot;) { tmp$present[i] &lt;- &quot;coal&quot; } else if (tmp$status[i] == &quot;nice&quot;) { tmp$present[i] &lt;- &quot;toy&quot; } else { tmp$present[i] &lt;- NA_character_ } } tmp name status present 1 Alex naughty coal 2 Edison nice toy 3 Susan &lt;NA&gt; &lt;NA&gt; 4 Ryan neutral &lt;NA&gt; Now the if/else logic works exactly as intended. This is longer than the version using ifelse(), but it is perhaps more readable. In most cases in R and SAS, it is possible to write code without needing loops at all, because both languages are vector-based - they will often use vectorized functions which implicitly loop over each row without having to write a loop to do so. ifelse() is a vectorized version of if() {} else {}. Here is an example of the most basic for loop logic - printing the numbers 1 through 10 - in both R and SAS. SAS code is provided for both PROC IML and DATA steps. In R: # R Example loop for (i in 1:10) { print(i) } [1] 1 [1] 2 [1] 3 [1] 4 [1] 5 [1] 6 [1] 7 [1] 8 [1] 9 [1] 10 In SAS IML: /* SAS IML example loop */ proc iml; do i = 1 to 10; print i; end; /* This ends the loop definition */ quit; i 1 i 2 i 3 i 4 i 5 i 6 i 7 i 8 i 9 i 10 In SAS DATA: /* SAS DATA step example loop */ proc printto log=&quot;saslog.log&quot; new; /* to shows output log in bookdown */ data A; do i = 1 to 10; put i=; end; /* This ends the loop definition */ run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 4 data A; 5 do i = 1 to 10; 6 put i=; 7 end; /* This ends the loop definition */ 8 run; i=1 i=2 i=3 i=4 i=5 i=6 i=7 i=8 i=9 i=10 NOTE: The data set WORK.A has 1 observations and 1 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds Another explanation of for loops is available at Khan Academy. While the most straighforward (and common) case of for-loop use in practice is to count from 1 to N, both R and SAS allow for loops to use other sequence structures. In R: R allows loops to occur over any vector… even randomly generated numbers, or nonnumeric vectors (say, a character vector of URLs). x &lt;- rnorm(5) # Generate 5 normal (0,1) samples for (i in x) { print(i^2) } [1] 4.500349 [1] 3.820737 [1] 2.656216 [1] 1.120775 [1] 2.10086 We can also iterate by non-integer values using seq(from = , to = , by = ) # This loop counts down in 1/2 units from 5 to 0 for (i in seq(5, 0, -.5)) { # do nothing } In SAS: We can iterate by non-integer values: proc printto log=&quot;saslog.log&quot; new; /* to shows output log in bookdown */ data A; y = 0; do i = 5 to 0 by -0.5; put i=; end; run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 3 data A; 4 y = 0; 5 do i = 5 to 0 by -0.5; 6 put i=; 7 end; 8 run; i=5 i=4.5 i=4 i=3.5 i=3 i=2.5 i=2 i=1.5 i=1 i=0.5 i=0 NOTE: The data set WORK.A has 1 observations and 2 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds We can even add additional conditions: proc printto log=&quot;saslog.log&quot; new; /* to shows output log in bookdown */ data A; y = 0; do i = 5 to 0 by -0.5 while (i**2 &gt; 1); put i=; end; run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 3 data A; 4 y = 0; 5 do i = 5 to 0 by -0.5 while (i**2 &gt; 1); 6 put i=; 7 end; 8 run; i=5 i=4.5 i=4 i=3.5 i=3 i=2.5 i=2 i=1.5 NOTE: The data set WORK.A has 1 observations and 2 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds Try it out In R: The beepr package plays sounds in R to alert you when your code has finished running (or just to annoy your friends and classmates). (Documentation) You can install the package using the following command: install.packages(&quot;beepr&quot;) (if you are using Linux you will also need to make sure one of paplay, aplay, or vlc is installed) Load the library and write a for loop which plays the 10 different sounds corresponding to integers 1 through 10. library(beepr) # load the beepr library beep(sound = 1) # sound is any integer between 1 and 10. It may be helpful to add the command Sys.sleep(5) into your loop to space out the noises so that they can be heard individually. In SAS: Write a for loop which will output the first 30 fibbonacci numbers. You can use the following code as a starting point: /* SAS IML example loop */ proc iml; current = 1; prev = 0; quit; R Solution: library(beepr) for (i in 1:10) { beep(sound = i) Sys.sleep(5) } SAS Solution: /* SAS IML example loop */ proc iml; current = 1; prev = 0; do i = 1 to 30; new = current + prev; prev = current; current = new; print current; end; /* This ends the loop definition */ quit; current 1 current 2 current 3 current 5 current 8 current 13 current 21 current 34 current 55 current 89 current 144 current 233 current 377 current 610 current 987 current 1597 current 2584 current 4181 current 6765 current 10946 current 17711 current 28657 current 46368 current 75025 current 121393 current 196418 current 317811 current 514229 current 832040 current 1346269 2.3.2.2 Condition-controlled loops (WHILE, DO WHILE) Frequently, we do not know how many times a loop will need to execute a priori. We might be converging on a value, and want to repeat the calculation until the new value is within an acceptably epsilon of the previous iteration. In these cases, it can be helpful to use a WHILE loop, which loops while the condition is true (another variant, the do-while loop, is similar, except that a do-while loop will always execute once, and checks the condition at the end of the iteration). If a WHILE loop condition is never falsified, the loop will continue forever. Thus, it is usually wise to include a loop counter as well, and a condition to terminate the loop if the counter value is greater than a certain threshold. Example: Let’s solve the Basel problem in R and SAS using WHILE loops - we’ll repeat the calculation until the value changes by less than 0.000001. The Basel problem is the problem of calculating the precise infinite summation \\[\\sum_{n=1}^\\infty \\frac{1}{n^2}\\] We’ll stick to calculating it computationally. In R: # Start out by defining your starting values outside of the loop i &lt;- 1 basel_value &lt;- 0 # initial guess prev_basel_value &lt;- -Inf # previous value while (abs(basel_value - prev_basel_value) &gt; 0.000001) { prev_basel_value &lt;- basel_value # update condition basel_value &lt;- basel_value + 1/i^2 i &lt;- i + 1 # Prevent infinite loops if (i &gt; 1e6) { break } # Monitor the loop to know that it&#39;s behaving if (i %% 200 == 0) { print(c(&#39;i = &#39; = i, &#39;prev&#39; = prev_basel_value, &#39;current&#39; = basel_value, diff = basel_value - prev_basel_value)) } } i = prev current diff 2.000000e+02 1.639896e+00 1.639922e+00 2.525189e-05 i = prev current diff 4.000000e+02 1.642425e+00 1.642431e+00 6.281368e-06 i = prev current diff 6.000000e+02 1.643263e+00 1.643266e+00 2.787060e-06 i = prev current diff 8.000000e+02 1.643682e+00 1.643683e+00 1.566414e-06 i = prev current diff 1.000000e+03 1.643933e+00 1.643934e+00 1.002003e-06 i [1] 1001 basel_value [1] 1.643935 prev_basel_value [1] 1.643934 in SAS: proc iml; i = 1; basel = 0; prev = -1; do while((basel - prev) &gt; 1e-6); prev = basel; basel = basel + 1/i**2; /* ** is the exponent operator */ i = i + 1; if i &gt; 1e6 then do; leave; end; if MOD(i, 200) = 0 then do; print i, prev, basel; end; end; print i, basel; quit; i 200 prev 1.6398963 basel 1.6399215 i 400 prev 1.6424247 basel 1.6424309 i 600 prev 1.6432632 basel 1.643266 i 800 prev 1.6436817 basel 1.6436833 i 1000 prev 1.6439326 basel 1.6439336 i 1001 basel 1.6439346 Another explanation of while loops is available at Khan Academy. Try it out Write a while loop in R and in SAS to calculate \\(\\displaystyle \\lim_{x \\rightarrow 4} \\frac{2 - \\sqrt{x}}{4-x}\\) by starting at 3 and halving the distance to 4 with each iteration. Exit the loop when you are within 1e-6 of the value computed on the previous iteration, or when you are within 1e-6 from 4. Which exit condition did you hit first? How do you know? Solutions: x &lt;- 3 dist &lt;- 4 - x current_value &lt;- 0 prev_value &lt;- -Inf while (abs(current_value - prev_value) &gt; 1e-6 &amp; dist &gt; 1e-6) { prev_value &lt;- current_value dist &lt;- dist/2 x &lt;- 4 - dist current_value &lt;- (2 - sqrt(x))/(4-x) } c(x = x, dist = dist, current_value = current_value, d_value = abs(current_value - prev_value)) x dist current_value d_value 3.999939e+00 6.103516e-05 2.500010e-01 9.536961e-07 Before \\(x\\) got to 4 - 1e-6, the change in f(x) became less than 1e-6. proc iml; x = 3; dist = 4 - x; fx = 0; prev_fx = 1; dfx = abs(fx - prev_fx); do while(dfx &gt; 1e-6 &amp; dist &gt; 1e-6); prev_fx = fx; dist = dist/2; x = 4 - dist; fx = (2 - sqrt(x))/(4 - x); dfx = abs(fx - prev_fx); end; print x, dist, fx, dfx; quit; x 3.999939 dist 0.000061 fx 0.250001 dfx 9.537E-7 2.3.2.3 Other Loops and Interative Structures There are many different ways to implement iteration in any language, including very low-level controls like repeat (in R). Higher level iteration may include a FOREACH loop, where a series of commands is applied to a list or vector (the *apply commands in R are examples of this). An additional method of iteration that requires functions is the recursion (where a function calls itself). In every case, these alternative loop structures can be translated to for or while loops. 2.4 Overgrown Calculators While R and SAS are both extremely powerful statistical programming languages, the core of both languages is the ability to do basic calculations and matrix arithmetic. As almost every dataset is stored as a matrix-like structure (data sets and data frames both allow for multiple types, which isn’t quite compatible with more canonical matrices), it is useful to know how to do matrix-level calculations in R and SAS. In this section, we will essentially be using both R and SAS as overgrown calculators. 2.4.1 Basic numerical operations Operation R SAS Addition + + Subtraction - - Elementwise Multiplication * # Matrix/Vector Multiplication %*% * Division \\ \\ Elementwise Exponentiation ^ ## Matrix Exponentiation ^ ** Matrix Transpose t(A) `A\\`` R demo: # transpose these to make row vectors to match SAS x &lt;- t(1:10) y &lt;- t(seq(3, 30, by = 3)) x + y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 4 8 12 16 20 24 28 32 36 40 x - y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] -2 -4 -6 -8 -10 -12 -14 -16 -18 -20 x * y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 3 12 27 48 75 108 147 192 243 300 x / y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [1,] 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 [,8] [,9] [,10] [1,] 0.3333333 0.3333333 0.3333333 x^2 [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 1 4 9 16 25 36 49 64 81 100 t(x) %*% y [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 3 6 9 12 15 18 21 24 27 30 [2,] 6 12 18 24 30 36 42 48 54 60 [3,] 9 18 27 36 45 54 63 72 81 90 [4,] 12 24 36 48 60 72 84 96 108 120 [5,] 15 30 45 60 75 90 105 120 135 150 [6,] 18 36 54 72 90 108 126 144 162 180 [7,] 21 42 63 84 105 126 147 168 189 210 [8,] 24 48 72 96 120 144 168 192 216 240 [9,] 27 54 81 108 135 162 189 216 243 270 [10,] 30 60 90 120 150 180 210 240 270 300 SAS demo: By default, SAS creates row vectors with do(a, b, by = c) syntax. The transpose operator (a single backtick) can be used to transform A into A`. proc iml; x = do(1, 10, 1); y = do(3, 30, 3); z = x + y; z2 = x - y; z3 = x # y; z4 = x/y; z5 = x##2; z6 = x` * y; print z, z2, z3, z4, z5, z6; quit; z COL1 COL2 COL3 COL4 COL5 COL6 COL7 COL8 COL9 COL10 ROW1 4 8 12 16 20 24 28 32 36 40 z2 COL1 COL2 COL3 COL4 COL5 COL6 COL7 COL8 COL9 COL10 ROW1 -2 -4 -6 -8 -10 -12 -14 -16 -18 -20 z3 COL1 COL2 COL3 COL4 COL5 COL6 COL7 COL8 COL9 COL10 ROW1 3 12 27 48 75 108 147 192 243 300 z4 COL1 COL2 COL3 COL4 COL5 COL6 COL7 COL8 COL9 COL10 ROW1 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 0.3333333 z5 COL1 COL2 COL3 COL4 COL5 COL6 COL7 COL8 COL9 COL10 ROW1 1 4 9 16 25 36 49 64 81 100 z6 COL1 COL2 COL3 COL4 COL5 COL6 COL7 COL8 COL9 COL10 ROW1 3 6 9 12 15 18 21 24 27 30 ROW2 6 12 18 24 30 36 42 48 54 60 ROW3 9 18 27 36 45 54 63 72 81 90 ROW4 12 24 36 48 60 72 84 96 108 120 ROW5 15 30 45 60 75 90 105 120 135 150 ROW6 18 36 54 72 90 108 126 144 162 180 ROW7 21 42 63 84 105 126 147 168 189 210 ROW8 24 48 72 96 120 144 168 192 216 240 ROW9 27 54 81 108 135 162 189 216 243 270 ROW10 30 60 90 120 150 180 210 240 270 300 Other matrix operations, such as determinants and extraction of the matrix diagonal, are similarly easy: R: mat &lt;- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T) t(mat) # transpose [,1] [,2] [,3] [1,] 1 6 7 [2,] 2 4 8 [3,] 3 5 9 det(mat) # get the determinant [1] 18 diag(mat) # get the diagonal [1] 1 4 9 diag(diag(mat)) # get a square matrix with off-diag 0s [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 4 0 [3,] 0 0 9 diag(1:3) # diag() also will create a diagonal matrix if given a vector [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 2 0 [3,] 0 0 3 SAS: proc iml; mat = {1 2 3, 6 4 5, 7 8 9}; tmat = mat`; /* transpose */ determinant = det(mat); /* get the determinant */ diagonal_vector = vecdiag(mat); /* get the diagonal as a vector */ diagonal_mat = diag(mat); /* get the diagonal as a square matrix */ /* with 0 on off-diagonal entries */ dm = diag({1 2 3}); /* make a square matrix with vector as the diagonal */ print tmat, determinant, diagonal_vector, diagonal_mat, dm; quit; tmat 1 6 7 2 4 8 3 5 9 determinant 18 diagonal_vector 1 4 9 diagonal_mat 1 0 0 0 4 0 0 0 9 dm 1 0 0 0 2 0 0 0 3 The other important matrix-related function is the inverse. In R, A^-1 will get you the elementwise reciprocal of the matrix. Not exactly what we’d like to see… Instead, in both languages, we use the solve() function. The inverse is defined as the matrix B such that AB = I where I is the identity matrix (1’s on diagonal, 0’s off-diagonal). So if we solve(A) (in R) or solve(A, diag(n)) in SAS (where n is a vector of 1s the size of A), we will get the inverse matrix. R: mat &lt;- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T) minv &lt;- solve(mat) # get the inverse minv [,1] [,2] [,3] [1,] -0.2222222 0.3333333 -0.1111111 [2,] -1.0555556 -0.6666667 0.7222222 [3,] 1.1111111 0.3333333 -0.4444444 mat %*% minv [,1] [,2] [,3] [1,] 1 0 0 [2,] 0 1 0 [3,] 0 0 1 SAS: Documentation proc iml; mat = {1 2 3, 6 4 5, 7 8 9}; mat_inv = solve(mat, diag({1 1 1})); /* get the inverse */ mat_inv2 = inv(mat); /* less efficient and less accurate */ print mat_inv, mat_inv2; id = mat * mat_inv; id2 = mat * mat_inv2; print id, id2; quit; mat_inv -0.222222 0.3333333 -0.111111 -1.055556 -0.666667 0.7222222 1.1111111 0.3333333 -0.444444 mat_inv2 -0.222222 0.3333333 -0.111111 -1.055556 -0.666667 0.7222222 1.1111111 0.3333333 -0.444444 id 1 -2.22E-16 0 0 1 0 0 -8.88E-16 1 id2 1 -2.22E-16 0 0 1 0 0 -8.88E-16 1 References and Links Non-exhaustive list of general R and SAS references used in this chapter: SAS Matrix reference: http://www.math.wpi.edu/saspdf/iml/chap4.pdf Data structures in Advanced R: http://adv-r.had.co.nz/Data-structures.html SAS Data set documentation Loops in SAS and SAS documentation for DO WHILE loops Random number generation in SAS Repeatable random number generation in R Creating SAS Data Sets from IML (also this friendly guide and this blog post) SAS Data Step options SAS Mathematical Operators SAS and R compared (by SAS) Lists and Data Structures in SAS Non-Exhaustive List of Sources used to aggregate “core programming concepts”: https://blog.upperlinecode.com/computer-language-fundamentals-five-core-concepts-1aa43e929f40 https://howtoprogramwithjava.com/programming-101-the-5-basic-concepts-of-any-programming-language/ https://dev.to/lucpattyn/basic-programming-concepts-for-beginners-2o73 http://livecode.byu.edu/programmingconcepts/ControlStruct.php http://holowczak.com/programming-concepts-tutorial-programmers/ numeric is not really a type, it’s a mode. Run ?mode for more information.↩ You can read about why factors aren’t ideal here↩ Most languages are 0-indexed languages: C, C++, python, Java, javascript. Vectors in these languages are indexed as 0, 1, 2, 3. Other 1-indexed languages include FORTRAN, Matlab, Julia, Mathematica, and Lua, many of which were intended for mathematical processing or data analysis.↩ Traditionally, naughty children got coal, while nice children got toys or candy.↩ "],
["organization.html", "Module 3 Organization: Packages, Functions, Scripts, and Documents Module Objectives 3.1 Reproducibility 3.2 Markdown 3.3 Functions and Modules 3.4 Scripts 3.5 Packages and Modules 3.6 References", " Module 3 Organization: Packages, Functions, Scripts, and Documents Module Objectives Use markdown to create dynamic documents which show code and results reproducibly Create functions and scripts to accomplish simple tasks Compare the structure and syntax of R and SAS programs Know where to find external software packages or modules to provide additional functionality 3.1 Reproducibility The concepts of replication and reproducibility is central to science - we do not trust studies whose results cannot be replicated by additional repetitions of the experiment, and we do not trust statistical analyses whose results are not backed up by valid methods that can be re-run to verify the reported results. While replication covers the lab methods, experimental design, and data collection procedures, reproducibility is concerned with the code and the data from an experiment which has already been run. Specifically, the idea is that the research paper is basically an advertisement - by exposing the code and data used in the analysis, readers can engage with the core of the analysis methods, leading to better peer feedback as well as easier adoption of the research for future work. Reproducibility has several advantages: It allows you to show the correctness of your results Trying to reproduce an analysis from the data and the description in the journal article is… challenging, if not impossible, in many cases. By providing the raw data and code to take the data from raw form to analysis results, readers can verify the legitimacy of each step in the analysis. This allows researchers to review each others methods, finding mistakes due to bugs in the software used or due to implementation errors. In one particularly prominent failure of reproducibility, a study used to support macroeconomic theories that shaped the response to the 2008-2009 recession negatively correlating national debt with gdp growth was found to be flawed due to an excel indexing mistake. Use of GUI-based (graphical user interface) statistical analysis software may make it harder to identify these mistakes, because the formulas and code are not visually displayed. It allows others to use your results more easily By sharing your code and raw data, you provide the wider scientific community with the ability to use your results to build new scientific studies. This increases the relevance of your work, the number of citations your papers get, and you also benefit from the community adopting a culture of openness and reproducibility. In 2 years, when you need to find the code you used for that analysis in XXX paper, you’ll be able to find the code (and the data) to see how it worked and what you did. The code may or may not run as-is (depending on software versioning, package updates, etc.), but you will have the methods clearly documented along with the data (so it’s easy to replicate the data format needed, etc.) There are other advantages (personal and public) described in an issue of Biostatistics dedicated to reproducibility. David Donoho’s response is particularly useful. As you might expect, there are many different types of reproducibility. Code reproducibility - allows replication of the computing aspects of the study. Includes code, software, hardware, and implementation details. Data reproducibility - allows replication of the non-computational parts of the study (e.g. experiment and data collection). This may include making protocols and data available. Statistical reproducibility - allows replication of the statistical methods. Includes details about model parameters, thresholds, etc. and may also include study pre-registration to prevent p-hacking. There are also many levels of reproducibility. Much of the computer code written in the 1960s is no longer runnable today, because the computer architecture it was written for is not available anymore. Code which depends on URLs is vulnerable to website rearrangements or the content no longer being hosted. Archiving projects on GitHub is nice, but what happens if GitHub goes down? It’s important to decide what type of reproducibility is important for a particular project, and then design the project’s workflow around that process. For most of my projects, I don’t worry about software versioning (I may archive my sessionInfo() so that package versions are documented) and storing the software packages alongside the code and data. As much as possible, I keep the code and the data (if it’s small) on GitHub in a public repository for people to access, along with any manuscripts or presentations related to the project. Manuscripts are written in knitr or r markdown, so that the code is documented by the context of the project, and every image in the article generated by R has corresponding code available. This ensures that my code (and data) is stored somewhere off-site (backed up in the cloud) my code is available if others want to use it I can track my contributions to a project relative to any collaborators I can reuse blocks of code easily In situations where I run experiments, I also make sure that any experimental stimuli or other code that would contribute to the execution and data collection part of the experiment is also included in the repository. Stimuli are archived as well. The github reproducibility work flow is convenient - it allows for me to easily collaborate with others, without emailing versions of code and documents back and forth. I can revert changes that are made that had unintentional effects fairly easily. I can sync my files across multiple machines effortlessly. And if necessary, I can look back at the changes I’ve made and see why I made them, or what I’ve already tried. 3.1.1 Reproducibility References and Reading Advanced R’s reproducibility guide A reproducible R workflow ROpenSci’s guide to reproducibility Roger Peng’s Biostatistics editorial on reproducibility The Biostatistics reproducibility issue w/ responses to the editorial and associated commentary 3.2 Markdown In this class, we’re primarily going to use rmarkdown to create dynamic documents. Markdown itself is a special style of text that is intended to allow you to do basic formatting without having to pause to actually click the buttons (if you were writing in word). It integrates equation functionality (so you can type mathematical equations using LaTeX syntax) and also allows for the use of templates (so you can write whole journal articles in a text editor). Markdown is also program agnostic - it will allow you to compile your work into HTML, word, or PDF form. Markdown documents must be compiled - a computer program runs and transforms the text file into a full document. RStudio has markdown functionality built-in, and also supports rmarkdown, which is a markdown variant designed to make it easy to integrate R code with document creation (so-called literate programming). There are other markdown programs which extend markdown’s functionality so that you can write a book (like this one), create presentations or posters, or maintain a blog in markdown. Rmarkdown, despite the name, also allows you to integrate the results from code in other languages. As you saw in the last chapter, SAS code can be integrated into markdown as well. Other languages commonly used include python, julia, SQL, Bash, C++, and Stan. There is a full set of Rmarkdown tutorials from RStudio. There is also a handy cheatsheet. Rmarkdown documents may contain code used to support an analysis, but they are usually not the best way to develop an analysis method - they are better for documentation, writing tutorials, and other scenarios where you need both text explanations and code/analysis/results. There are other “containers” for code, though, including functions, scripts, and packages. Each has their own advantages and disadvantages, and can be used together. 3.2.1 Rmarkdown with… SAS? You may have noticed that I’ve been including SAS chunks throughout this book, and even in your homework assignments. Here’s how that’s set up. SAS in Rmarkdown – guide. It’s really fairly simple. 3.3 Functions and Modules A function (or a module, in SAS) is a block of code which is only run when it is called. It takes arguments (known as parameters) and returns data or some other value. There is some extensive material on this subject in R for Data Science on functions. If you aren’t familiar with functions, you should read that material before proceeding. Let’s look at the structure of a generic function in pseudocode (code that isn’t really part of any language, but describes the steps of a program): my_function_name = function(param1, param2 = 3) { step1 // do something step2 // do something else return step_1/step2 } The first part of a function declaration (storing information in a named object) is the function’s intended name, my_function_name. Then, we indicate that we are defining a function, and what parameters our function requires. For param1, we do not provide a default value, but for param2, we indicate that the default value is 3. Thus, if we call the function (tell the program to run this function with certain arguments and provide the result), we could either say my_function_name(param1 = value1, param2 = value2) or my_function_name(param1 = value1) (which is equivalent to my_function_name(param1 = value1, param2 = 3)). Inside the function block (indicated by {} here, but some languages may use do ... end;), we perform whatever steps we’ve decided to include in the function, and then at the end of the function, we return a value - the function exits, and leaves behind some information. In R, functions look like this: function( arglist ) { expr return(value) } In SAS, functions are called modules and look like this: Statements That Define and Execute Modules Modules are used to create a user-defined subroutine or function. A module definition begins with a START statement, which has the following general form: START &lt;name&gt; &lt;( arguments )&gt; &lt;GLOBAL( arguments )&gt;; A module definition ends with a FINISH statement, which has the following general form: FINISH &lt;name&gt;; To execute a module, you can use either a RUN statement or a CALL statement. The general forms of these statements are as follows: `RUN &lt;name&gt; &lt;( arguments)&gt;; `CALL &lt;name&gt; &lt;( arguments)&gt;;` The only difference between the RUN and CALL statements is the order of resolution. Source: SAS function reference Let’s try functions out by writing a simple function that takes two numbers as arguments and adds them together. adder &lt;- function(a, b) { return(a + b) } adder(3, 4) [1] 7 proc IML; start adder(a, b); return(a + b); finish; c = adder(3, 4); print c; quit; c 7 Of course, it’s not just important to be able to write your own functions. It’s also helpful to be able to see how functions are written, both to explore how a method is implemented and for debugging purposes. In SAS, this is generally not an option, because SAS is closed source, but in R, you can see the code behind any function which is implemented in R (it is harder to see functions implemented in C or C++, but not impossible) by typing the function name (no parentheses) into the command prompt. Let’s examine how the colSums() function is implemented: colSums function (x, na.rm = FALSE, dims = 1L) { if (is.data.frame(x)) x &lt;- as.matrix(x) if (!is.array(x) || length(dn &lt;- dim(x)) &lt; 2L) stop(&quot;&#39;x&#39; must be an array of at least two dimensions&quot;) if (dims &lt; 1L || dims &gt; length(dn) - 1L) stop(&quot;invalid &#39;dims&#39;&quot;) n &lt;- prod(dn[id &lt;- seq_len(dims)]) dn &lt;- dn[-id] z &lt;- if (is.complex(x)) .Internal(colSums(Re(x), n, prod(dn), na.rm)) + (0+1i) * .Internal(colSums(Im(x), n, prod(dn), na.rm)) else .Internal(colSums(x, n, prod(dn), na.rm)) if (length(dn) &gt; 1L) { dim(z) &lt;- dn dimnames(z) &lt;- dimnames(x)[-id] } else names(z) &lt;- dimnames(x)[[dims + 1L]] z } &lt;bytecode: 0x556250483500&gt; &lt;environment: namespace:base&gt; You can see that the first 3 steps in the function are if statements to test whether the inputs are acceptable - x must be a data frame, a matrix, or an array (with 2+ dimensions). The next couple of lines test to see whether there are additional “column” dimensions (don’t worry if you don’t understand what’s going on in this code - it’s highly optimized and a bit arcane). Then, the function checks to see if x is real-valued or complex, and if it’s complex, computes the real and imaginary sums separately. The .Internal(colSums(x...)) part is calling a C function - basically, functions written in C are faster than R because they’re compiled, so this speeds basic operations up in R. Then there are statements that transfer dimension names over to the summed object. At the end of the function, the last value computed is returned automatically (in this case, z). Try it out Write a function named circle_area which computes the area of a circle given the radius. Make sure to use reasonable parameter names! (Note: in R, pi is conveniently stored in the variable of the same name - it can be overwritten if you want to do so, but why would you want to do that? In SAS, you can get the value of pi using constant(&quot;pi&quot;)) circle_area &lt;- function(r) { r^2*pi # automatically returned as the last computed value } circle_area(5) [1] 78.53982 A more complete and robust answer might include a test for numeric r: circle_area &lt;- function(r) { if (!is.numeric(r)) { stop(&quot;Supplied radius must be numeric&quot;) # This issues an error } r^2*pi # automatically returned as the last computed value } circle_area(5) [1] 78.53982 proc IML; start circle_area(r); pi = constant(&quot;pi&quot;); return(pi*r**2); finish; c = circle_area(5); print c; quit; c 78.539816 One last trick to note: functions generally can only return one object. If you need to return more than one thing, put the objects into a list or another data structure, and return that - then you can take the list/structure apart outside the function to use the returned values separately. 3.3.1 Scope The scope of a variable is the space in the program where a variable is defined and can be accessed. A local variable is one which can only be accessed within a function or block of code - it does not exist outside of that code. A global variable is one which is available to the entire program. 3.3.1.1 Scoping in R Every function is defined in a certain environment, and once it is defined, executed in a specific environment. Think of an environment as a space full of available variables, functions, and objects. Any defined object or variable that a function has access to is in scope. When you are inside of a function block, you have access to values defined within the function, plus any other values outside the function. When there are two variables with the same name, the object in the environment which is “closest” is used. Demonstration of scoping in R: a &lt;- 3 myfun &lt;- function(a, b) { a + b + 2 } myfun(5, 6) # a is 5 inside the function, so that overrides the [1] 13 # a defined outside the function myfun(a, 3) # this references the a outside the function [1] 8 Scope diagram. When myfun() is called, the calling environment contains the two parameters a and b. a &lt;- 3 myfun2 &lt;- function(d) { myfun(a, d) } myfun2(3) # the only a in scope inside fun2 is the a defined at the top of the chunk [1] 8 Scope diagram. When myfun2() is called, the calling environment contains only a parameter \\(d\\). \\(a\\) is pulled from the global environment, as there is no parameter \\(a\\) in the myfun2 calling environment. a &lt;- 3 myfun3 &lt;- function(a, d) { b &lt;- a; # make a copy of the value a &lt;- 250; myfun(b, d) } a [1] 3 myfun3(5, 3) # now, a is defined inside fun3 as a = 5, so there is an a in [1] 10 # fun3&#39;s scope that isn&#39;t in the global environment. a # value of a hasn&#39;t changed [1] 3 Scope diagram. When myfun3() is called, the calling environment contains parameters a and d, which are then copied into the calling environment of myfun as \\(a\\) and \\(b\\). The variable \\(a\\) in the global environment is ignored. If you want to avoid too many issues with scoping (because scoping rules are complicated), the simplest way is to not reuse variable names inside of a function if you’ve already used those names outside the function. R does have global variables and a global assignment operator, &lt;&lt;-, but the use of global variables is strongly discouraged, and global variables are not permitted in e.g. CRAN packages. 3.3.1.2 Scoping in SAS In SAS, scoping rules are more like those in other programming languages - you have to keep track of how arguments are made available to the function. Demonstration of scoping in SAS. Environments do not inherit variables from the calling environment. PROC IML; a = 3; start myfun(a, b); return a + b + 2; finish; r1 = myfun(5, 6); /* a is 5 inside the function, so that overrides the a defined outside the function */ r2 = myfun(a, 3); /* this references the a outside the function */ print r1 r2; quit; r1 r2 13 8 In SAS, the equivalent version of the program used to demonstrate lexical scoping in R produces an error. In SAS, you cannot assume the function has access to values defined outside of that function that are not passed into the function as arguments. PROC IML; a = 3; start myfun(a, b); return a + b + 2; finish; start myfun2(d); return myfun(a, d); /* SAS complains because a is not defined */ finish; r1 = myfun2(3); print r1; quit; First, let’s consider the similarities: like R, functions have a local scope, and changing a similarly named value inside the function doesn’t change the value outside the function. PROC IML; start myfun(x); y = 2 * x; print y[label=&quot;y inside function (local)&quot;]; return 1; finish; y = 0; x = 1:5; res = myfun(x); print y[label=&quot;y outside function&quot;]; quit; y inside function (local) 2 4 6 8 10 y outside function 0 However, R’s environment feature and lexical scoping is not common to many other programming languages. When values are passed into the function as arguments, the behavior in SAS deviates from the equivalent behavior in R. In SAS, arguments to functions are passed by reference. An argument that is passed by value makes a copy of the value (to a new memory location) for the local function scope (this is what R does). When an argument is passed by reference, the address of the argument is passed in instead6. This is faster and more efficient (because you aren’t making a new copy of the data), but it does mean that changes inside the function persist outside that function. Example: Argument passing in R and SAS In SAS: If we make a slight modification to myfun(a, b), though, we see some interesting behavior in SAS that we wouldn’t see in the equivalent R program. PROC IML; a = 3; start myfun(a, b); a = a + 2; return a + b; finish; b = a; r1 = myfun(5, 6); c = a; r2 = myfun(a, 3); d = a; print b[label=&quot;a before r1&quot;] r1 c[label=&quot;a after r1&quot;] r2 d[label=&quot;a after r2&quot;]; quit; a before r1 r1 a after r1 r2 a after r2 3 13 3 8 5 In R: In R, variables inside a function don’t modify variables which are outside a function (generally speaking). In SAS, this is not necessarily the case. In the first call to myfun(), we pass in two numerical arguments, and we see that even though the value of a changes inside the function, that change doesn’t affect the variable defined outside of the function. In the second call to myfun(), we pass a variable in as an argument, and we see that the variable changes after the function’s execution! In the R chunk (below), you can see that the behavior of what is essentially the same code is different. a &lt;- 3 myfun &lt;- function(a, b) { a &lt;- a + 2 a + b } a [1] 3 myfun(5, 6) [1] 13 a [1] 3 myfun(a, 3) [1] 8 a [1] 3 Here’s another example of SAS passing arguments by reference (and the unexpected effects that can have on a program’s state): PROC IML; start myfun(x); call sort(x, 1); /* sort the values */ return (cusum(x)); /* cusum() = cumulative sum */ finish; y = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4}; z = y; print y[label=&quot;y before function is called&quot;]; cs = myfun(y); print z[label=&quot;original y&quot;] y[label=&quot;y after function is called&quot;] cs[label=&quot;cumulative sum of sorted y&quot;]; quit; y before functionis called 3 1 4 1 5 9 2 6 5 4 original y y after functionis called cumulative sumof sorted y 3 1 1 1 1 2 4 2 4 1 3 7 5 4 11 9 4 15 2 5 20 6 5 25 5 6 31 4 9 40 Because arguments in SAS are passed by reference, you can “trick” a function into returning multiple values by passing the variables in as arguments to the function, changing their values in the function, and returning. This is not necessarily a good practice - it can make code very difficult to debug, and may lead to non-obvious dependencies - but for short, simple programs, you can probably get away with it. PROC IML; start getDescriptive(Mean, SD, /* output args */ x /* input arg */); Mean = x[:]; /* this is shorthand for compute the mean of the column */ SD = sqrt( ssq(x - Mean)/(nrow(x) - 1)); finish; m = 0; s = 0; y = {3, 1, 4, 1, 5, 9, 2, 6, 5, 4}; run GetDescriptive(m, s, y); print m s; quit; m s 4 2.4494897 If you want to avoid any of these side-effects of SAS’s pass-by-reference behavior, you can very easily do so: just don’t write any modules that modify input arguments. Always modify a copy of the variable instead. Try it out Can you predict what the output of this chunk will be? f &lt;- function(x) { f &lt;- function(x) { f &lt;- function(x) { x ^ 2 } f(x) + 1 } f(x) * 2 } f(10) Run it - were you right? What happens when you run a similar program in SAS? (I only nested two functions this time, but you get the idea) proc IML; start f(x); start f(x); return x**x; finish; return f(x)+1; finish; quit; Working through the R program: This gets much less confusing if you rename the functions following R’s scoping rules. f &lt;- function(x) { f1 &lt;- function(x) { # because inside of f(), the new definition will dominate f2 &lt;- function(x) { # because inside of f1(), the new definition will dominate x ^ 2 } f2(x) + 1 } f1(x) * 2 } f(10) Once this has been renamed, it is relatively easy to write out as a series of mathematical substitutions: \\[f(10) = f1(10) * 2 = (f2(10) + 1) * 2 = (10^2 + 1)*2 = 202\\] Running the similar program in SAS results in SAS complaining about a recursive function definition. What will this SAS program output? proc IML; start funwithSAS(x, y); a = x; x = x + 3; return x*y; finish; a = 0; res1 = funwithSAS(a, 5); a1 = a; x = 3; res2 = funwithSAS(x, 5); a2 = a; x2 = x; y = 3; res3 = funwithSAS(x, y); /* print res1 a1 res2 a2 x2 res3 a x y; */ /* uncomment this when you&#39;re ready */ quit; This is easiest if we step through the program and list what is passed around inside and outside of the function evaluation. a = 0 res1 = ...? (inside funwithsas res1) x = (location of a), y = 5 (inside funwithsas res1) a = x = (location of a), x = (location of a) + 3 = 3, so (location of a) = 3 and x = 3. res1 returns x = 3 * y = 5 = 15 a1 = 3 res2 = ...? (inside funwithsas res2) x = (location of x), y = 5 (inside funwithsas res2) a = (location of x), x = (location of x) + 3 = 6 (a outside the function is unaffected because a is not a parameter) res2 returns x = 6 * y = 5 = 30 a2 = 3 x2 = 6 y = 3 res3 = ...? (inside funwithsas res3) x = (location of x), y = (location of y) (inside funwithsas res3) a = (location of x), x = (location of x) + 3 = 9 (a outside the function is unaffected; y is unchanged) res3 returns x = 9 * y = 3 = 27 at this point, x = 9 and y = 3. So the output is res1 = 15 a1 = 3 res2 = 30 a2 = 3 x2 = 6 res3 = 27 a = 3 x = 9 y = 3 The trick to this problem is to realize that inside of the function, when a variable is passed in (by reference) the thing that is assigned is the pointer to the value in memory where the original variable lives. So when a is passed in as x, x is assigned (location of a), which is then assigned to the local copy of a. So both variables now point at the outside (a), and any changes to x also affect both a and the local copy of a. 3.3.2 Infix operators and the pipe in R Note You do not need to understand this section yet. If you’re feeling comfortable with the material, go ahead and read it now. Otherwise, make a note of where this is, and come back to it when we start using dplyr and readr. It makes more sense to talk about this in the functions section, but you don’t need it yet. Most functions take arguments written after the function name. Can you think of any functions which work differently? Infix functions are functions that take arguments on both sides of the function name. Say, a + b: technically, a and b are arguments to the function +, so we could think of this as +(a, b). R has a number of infix functions, but you can also create your own. User-defined infix functions start and end with %. So %&gt;%, %in%, %dosomething% would all be valid infix operators. To define one, you need to enclose the name in back-ticks (`). `%dosomething%` &lt;- function(a, b) { a^b - a + b } 3 %dosomething% 4 [1] 82 You can also call default infix operators using this syntax: `+`(3, 4) = 7 One of the most useful infix operators is the pipe, %&gt;%, which is a part of the magrittr library and is commonly included in other packages, such as dplyr, and tidyr (we will talk about packages later in this chapter, but pipes are useful to discuss now, so roll with it for a few minutes). library(magrittr) 3 %&gt;% exp() [1] 20.08554 exp(3) [1] 20.08554 The pipe takes the left hand side and a function, and puts the left hand side as an argument to the function on the right hand side. It doesn’t sound very impressive, but it allows you to do some very cool things: you can “chain” operations. Consider 3 functions: f1 &lt;- function(x, y = 3) { x * y } f2 &lt;- function(z) { z^2 } f3 &lt;- function(z2) { log10(z2) } Normally, you’d write f3(f2(f1(4))), which you have to read from the inside to the outside. With pipes, you can write the same operation as: 4 %&gt;% f1() %&gt;% f2() %&gt;% f3() [1] 2.158362 This is much simpler to read - it’s like a recipe. “Take 4, do f1, then f2, then f3”. You don’t need to know how to define your own infix operators, but you will want to become familiar with the pipe eventually. 3.4 Scripts Up until this point, you may have been writing code in an R Studio or SAS text editor window, or, you may have been typing commands into the command line without preserving them in a separate file. You might even have been working in R markdown documents, where you had code and non-code chunks of the file. A script is a file which contains only code and comments. It is intended to run from start to finish, and usually completes one or more tasks - for instance, cleaning your data, or loading a series of custom functions into your R environment. Scripts are useful because they preserve code so that it can be re-run… and in some cases, they can even be re-run autonomously - I have several scripts which automatically run at specific times every day to complete various tasks (scraping data off the internet, mostly). I find that when doing data analysis, it is often easier to write a script as opposed to working in R markdown or typing commands into the console. Scripts are a record of what I’ve done, and ensure that commands are executed in the right order. As with any tool, it is important to know where to use the tool and where the tool is usually not the best option. You can source (run) an R script using the source() command with the file path of the script as the argument. Scripts in R end in .r or .R, while scripts in SAS end in .sas. Scripts can be run in one of (at least) two modes: batch mode, or interactive mode. In batch mode, the entire script is run without human intervention or monitoring. This is useful for repetitive jobs – for instance, to record the weather at 6h intervals throughout the day. In interactive mode, scripts may be run line-by-line or block-wise, with small tweaks made to the code as you proceed through the file. I find that in some cases, what starts out as an interactive mode script can become a batch script as I work the kinks out. If you ever need to use the high-performance computing resources on campus, you will need to write code to run in batch mode, because these jobs are generally not friendly to interactive programming. Try it out I maintain a list of packages that I find to be useful so that when I install R on a new machine (or update R), I don’t have to spend 3 weeks realizing that I need to install X package. Instead of many repeated 5 minute pauses for package installation, I can just let this script run once and walk away. I’ve pared down my list of packages a bit for this class (you don’t need the packages for analysis of 3D bullet scan data, for instance), but this step should help populate your R installation with a few new packages. Read the script (located here) and try to understand what it is doing. Once you think you understand what it is doing, run the following command to run the script and install the packages on your machine. Were you right? source(&quot;https://raw.githubusercontent.com/srvanderplas/unl-stat850/master/code/03_setup.R&quot;) 3.5 Packages and Modules Both SAS and R have systems for extending the base system/language with additional functionality. In R, these extensions are called packages, and in SAS they are called modules.7 3.5.1 R In R, there are two main sources for packages: CRAN (the Comprehensive R Archive Network) (and related archives, such as MRAN, which is Microsoft’s version of CRAN) and github. R packages published on CRAN go through a basic verification process that makes sure that the package meets certain standards (for instance, packages must have proper dependencies specified, cannot conflict with previous package names, must have a software license, and cannot contain malicious code). Note that CRAN does not check the packages for statistical correctness! On github, packages go through less verification. Many packages use a system where the version in development is on github and available for installation, but the version on CRAN is considered “stable”. Sometimes, packages are never put on CRAN: I contribute to several packages which are too large for CRAN, and it’s not worth the hassle to get an exception or figure out a workaround. library(rvest) Loading required package: xml2 txt &lt;- read_xml(&quot;https://cran.r-project.org/web/packages/&quot;) %&gt;% html_node(css = &quot;#pkgs&quot;) %&gt;% xml_parent() %&gt;% html_text() npkgs &lt;- stringr::str_extract(txt, &quot;features \\\\d{1,}&quot;) %&gt;% stringr::str_remove(&quot;features &quot;) %&gt;% as.numeric() Currently, the CRAN package repository features 1.579110^{4} available packages. How do you navigate them to find the one you need? Sometimes, the CRAN Task Views may be helpful - for instance, if you want to see all of the packages which are useful for Meta-Analysis, Finance, Bayesian statistics, etc. Other times, it’s useful to let Google help you navigate: searching for “R CRAN” + “what you want the package to do” can often narrow things down (I recommend adding CRAN in because Google results for “R” are not particularly useful.) 3.5.2 SAS In SAS, there are also packages of code that encapsulate scripts. However, unlike R (and many other languages), there is no centralized repository for SAS packages. Papers may include SAS packages to demonstrate new methods, and other packages may be found on GitHub or various SAS forums. 3.6 References A more advanced take on functions in R can be found here (Advanced R chapter) There is also a handy cheat sheet style summary of PROC IML in SAS here and some useful demonstrations of simple tasks in IML here. A helpful blog post for scoping in SAS is here Here is another explanation of pass-by-value vs. pass-by-reference (intended for C programming) A comparison of R, SAS, and python - source of information about the SAS package distribution system. if you’re familiar with C, the argument passed in is just a pointer to the original memory↩ Note that the various components of SAS can be extremely confusing to separate. I found this guide to be somewhat helpful.↩ "],
["reading-data.html", "Module 4 External Data Module Objectives 4.1 External Data Formats 4.2 Reading text data 4.3 Binary Files 4.4 Importing Tabular Data into R 4.5 Importing Tabular Data into SAS 4.6 Exploratory Data Analysis 4.7 References", " Module 4 External Data Module Objectives Import data from text and excel files into R and SAS for analysis Conduct exploratory data analysis to determine how the data is structured, what cleaning must be done, and what (if any) interesting artifacts are in the dataset 4.1 External Data Formats In order to use statistical software to do anything interesting, we need to be able to get data into the program so that we can work with it effectively. For the moment, we’ll focus on tabular data - data that is stored in a rectangular shape, with rows indicating observations and columns that show variables. This type of data can be stored on the computer in multiple ways: as raw text, usually in a file that ends with .txt, .tsv, .csv, .dat, or sometimes, there will be no file extension at all. These types of files are human-readable. If part of a text file gets corrupted, the rest of the file may be recoverable. as a binary file. Binary files are compressed files that are readable by computers but not by humans. They generally take less space to store on disk (but the same amount of space when read into computer memory). If part of a binary file is corrupted, the entire file is usually affected. R, SAS, Stata, SPSS, and Minitab all have their own formats for storing binary data. Packages such as foreign in R will let you read data from other programs, and packages such as haven in R will let you write data from other programs. To read data from R into SAS, the easiest way is probably to call R from PROC IML. in a database. Databases are typically composed of a set of one or more tables, with information that may be related across tables. Data stored in a database may be easier to access, and may not require that the entire data set be stored in computer memory at the same time, but you may have to join several tables together to get the full set of data you want to work with. in a spreadsheet. Spreadsheets, such as those created by MS Excel, Google Sheets, or LibreOffice Calc, are not completely binary formats, but they’re also not raw text files either. They’re a hybrid. Practically, they may function like a poorly laid-out database, a text file, or a total nightmare, depending on who designed the spreadsheet. There is a collection of horror stories here and a series of even more horrifying tweets here There are, of course, many other non-tabular data formats – some open and easy to work with, some inpenetrable. A few which may be more common: Web related data structures: XML (eXtensible markup language), JSON (JavaScript Object Notation), YAML. These structures have their own formats and field delimiters, but more importantly, are not necessarily easily converted to tabular structures. They are, however, useful for handling nested objects, such as trees. When read into R or SAS, these file formats are usually treated as lists, and may be restructured afterwards into a format useful for statistical analysis. Spatial files: Shapefiles are by far the most common version of spatial files8. Spatial files often include structured encodings of geographic information plus corresponding tabular format data that goes with the geographic information. We’ll explore these a bit more when we talk about maps. To be minimally functional in R and SAS, let’s start with figuring out how to read text, spreadsheet, and SQLite database formats into both programs. 4.2 Reading text data There are several different variants of text data which are relatively common, but for the most part, text data files can be broken down into fixed-width and delimited formats. What’s the difference, you say? 4.2.1 Fixed-width files In a fixed-width text file, the position of the data indicates which field (variable/column) it belongs to. These files are fairly common outputs from older FORTRAN-based programs, but may be found elsewhere as well - if you have a very large amount of data, a fixed-width format may be more efficient to read, because you can select only the portions of the file which matter for a particular analysis (and so you don’t have to read the whole thing into memory). Col1 Col2 Col3 3.4 4.2 5.4 27.3 -2.4 15.9 In base R (no extra packages), you can read fwf files in using read.fwf, but you must specify the column breaks yourself. url &lt;- &quot;https://www.mesonet.org/index.php/dataMdfMts/dataController/getFile/202006070000/mdf/TEXT/&quot; read.fwf(url, skip = 2, # Skip the first 2 lines header = T) # There is a row with the column names specified Error in read.fwf(url, skip = 2, header = T): argument &quot;widths&quot; is missing, with no default You can count all of those spaces by hand (not shown), you can use a different function, or you can write code to do it for you. # I like to cheat a bit.... # Read the first few lines in tmp &lt;- readLines(url, n = 20)[-c(1:2)] # split each line into a series of single characters tmp_chars &lt;- strsplit(tmp, &#39;&#39;) # Bind the lines together into a character matrix # do.call applies a function to an entire list - so instead of doing 18 rbinds, # one command will put all 18 rows together tmp_chars &lt;- do.call(&quot;rbind&quot;, tmp_chars) # (it&#39;s ok if you don&#39;t get this line) # Make into a logical matrix where T = space, F = not space tmp_chars_space &lt;- tmp_chars == &quot; &quot; # Add up the number of rows where there is a non-space character # space columns would have 0s/FALSE tmp_space &lt;- colSums(!tmp_chars_space) # We need a nonzero column followed by a zero column breaks &lt;- which(tmp_space != 0 &amp; c(tmp_space[-1], 0) == 0) # Then, we need to get the widths between the columns widths &lt;- diff(c(0, breaks)) # Now we&#39;re ready to go mesodata &lt;- read.fwf(url, skip = 3, widths = widths, header = F) Warning in readLines(file, n = thisblock): incomplete final line found on &#39;https://www.mesonet.org/index.php/dataMdfMts/dataController/getFile/ 202006070000/mdf/TEXT/&#39; # read header separately - if you use header = T, it errors for some reason. # It&#39;s easier just to work around the error than to fix it :) mesodata_names &lt;- read.fwf(url, skip = 2, n = 1, widths = widths, header = F, stringsAsFactors = F) names(mesodata) &lt;- as.character(mesodata_names) mesodata STID STNM TIME RELH TAIR WSPD WVEC WDIR WDSD WSSD 1 ACME 110 0 53 31.8 5.2 5.1 146 8.5 0.7 2 ADAX 1 0 55 32.4 1.0 0.8 108 36.5 0.4 3 ALTU 2 0 31 35.6 8.9 8.7 147 10.9 1.1 4 ALV2 116 0 27 35.8 6.7 6.7 145 8.2 1.2 5 ANT2 135 0 73 27.8 0.0 0.0 0 0.0 0.0 6 APAC 111 0 52 32.3 6.2 6.1 133 9.8 0.8 7 ARD2 126 0 46 32.9 2.6 2.5 150 11.8 0.5 8 ARNE 6 0 28 33.5 6.5 6.3 163 11.9 1.5 9 BEAV 8 0 23 34.9 11.2 11.1 165 7.3 1.4 10 BESS 9 0 37 33.8 8.3 8.3 156 6.6 1.3 11 BIXB 10 0 55 33.6 3.0 2.9 161 7.9 0.4 12 BLAC 11 0 45 33.9 5.1 5.1 155 8.7 0.8 13 BOIS 12 0 15 33.7 14.3 14.3 180 5.3 1.3 14 BREC 14 0 42 33.9 6.5 6.4 152 9.0 1.0 15 BRIS 15 0 59 32.3 1.6 1.6 153 13.8 0.5 16 BROK 124 0 60 31.6 2.2 2.1 104 20.5 0.7 17 BUFF 16 0 28 35.6 8.4 8.3 149 8.7 1.8 18 BURB 17 0 58 32.0 3.3 3.2 161 11.9 0.7 19 BURN 18 0 55 32.9 2.0 2.0 89 7.8 0.4 20 BUTL 19 0 33 34.2 7.0 6.9 160 10.2 1.1 21 BYAR 20 0 52 31.8 3.0 2.9 103 10.4 0.6 22 CAMA 22 0 28 34.5 7.6 7.6 168 7.3 1.1 23 CARL 131 0 48 33.3 4.3 4.3 153 10.4 0.7 24 CENT 23 0 67 29.7 2.1 2.1 167 14.2 0.6 25 CHAN 24 0 56 32.4 3.0 2.9 134 7.7 0.5 26 CHER 25 0 25 36.6 5.9 5.8 172 8.5 1.4 27 CHEY 26 0 30 33.5 8.8 8.7 148 9.1 1.4 28 CHIC 27 0 51 32.7 4.9 4.8 144 8.8 0.6 29 CLAY 29 0 51 31.9 3.6 3.6 88 8.6 0.7 30 CLOU 30 0 64 30.9 1.3 1.1 212 35.5 1.0 31 COOK 31 0 66 31.1 1.1 1.1 160 15.5 0.4 32 COPA 32 0 58 32.6 3.0 3.0 149 7.6 0.6 33 DURA 33 0 57 30.6 2.9 2.8 61 10.5 0.5 34 ELKC 139 0 33 33.5 8.4 8.3 160 7.6 1.3 35 ELRE 34 0 52 31.7 6.0 5.9 154 9.1 0.9 36 ERIC 35 0 31 34.1 8.8 8.7 157 6.5 1.3 37 EUFA 36 0 55 32.6 2.8 2.7 120 8.7 0.5 38 EVAX 141 0 16 34.5 13.4 13.3 171 6.7 2.1 39 FAIR 37 0 28 35.8 6.7 6.5 166 11.4 1.4 40 FITT 127 0 53 31.7 2.8 2.8 137 4.1 0.4 41 FORA 38 0 58 31.8 3.6 3.5 144 11.9 0.7 42 FREE 39 0 28 35.0 8.4 8.3 167 7.4 1.1 43 FTCB 40 0 42 33.2 7.8 7.7 145 6.3 0.9 44 GOOD 41 0 16 33.9 12.2 12.1 181 7.3 1.6 45 GRA2 117 0 40 34.3 6.8 6.7 139 7.6 0.9 46 GUTH 43 0 51 32.8 4.8 4.7 144 8.1 0.7 47 HASK 44 0 54 33.8 2.6 2.6 136 7.4 0.6 48 HECT 113 0 56 32.6 1.9 1.8 148 13.8 0.5 49 HINT 45 0 44 32.2 7.1 7.0 146 10.5 1.0 50 HOBA 46 0 40 34.1 8.2 8.2 140 7.8 1.2 51 HOLD 134 0 61 32.4 2.2 2.2 122 8.6 0.5 52 HOLL 47 0 35 34.2 8.0 7.9 137 8.2 1.4 53 HOOK 48 0 17 35.5 11.4 11.3 174 7.9 1.4 54 HUGO 49 0 -996 -996.0 -996.0 -996.0 -996 -996.0 -996.0 55 IDAB 50 0 67 30.5 0.8 0.8 100 10.9 0.2 56 INOL 120 0 53 33.5 2.0 2.0 126 9.8 0.4 57 JAYX 51 0 61 31.4 1.3 1.3 102 18.3 0.3 58 KENT 52 0 15 33.8 14.8 14.7 177 6.4 1.6 59 KETC 53 0 54 31.9 4.1 4.1 142 7.0 0.6 60 KIN2 133 0 40 34.2 6.8 6.6 151 11.9 1.2 61 LAHO 55 0 33 35.2 6.0 5.9 161 8.4 1.1 62 LANE 56 0 69 28.1 0.4 0.4 109 17.5 0.2 63 MADI 57 0 52 32.6 1.6 1.5 118 17.0 0.6 64 MANG 58 0 31 35.0 7.1 7.0 157 8.5 1.0 65 MARE 59 0 53 32.3 4.0 3.9 144 9.9 0.8 66 MAYR 61 0 28 35.0 9.3 9.2 162 8.2 1.2 67 MCAL 62 0 57 32.1 1.7 1.6 100 15.9 0.6 68 MEDF 63 0 37 34.7 7.2 7.1 148 6.7 1.3 69 MEDI 64 0 46 32.0 6.3 6.3 140 8.0 1.0 70 MIAM 65 0 62 31.9 3.5 3.4 116 8.8 0.6 71 MINC 66 0 51 32.0 6.7 6.6 142 8.5 1.2 72 MRSH 125 0 44 33.4 4.9 4.9 140 8.5 0.8 73 MTHE 67 0 68 31.0 1.0 0.7 139 36.9 0.7 74 NEWK 68 0 55 32.2 6.0 5.9 151 7.2 0.7 75 NEWP 123 0 52 32.5 2.4 2.4 165 10.3 0.4 76 NOWA 70 0 58 32.7 3.2 3.2 145 7.1 0.5 77 NRMN 121 0 53 32.8 4.3 4.1 129 15.4 1.0 78 OILT 71 0 58 32.2 2.7 2.7 141 9.7 0.7 79 OKCE 130 0 48 32.9 3.6 3.5 124 15.7 0.9 80 OKEM 72 0 57 32.6 2.1 2.0 135 13.6 0.5 81 OKMU 73 0 60 32.4 2.3 2.3 158 9.3 0.5 82 PAUL 74 0 49 33.1 2.5 2.4 151 17.0 0.8 83 PAWN 75 0 53 32.8 4.3 4.3 149 6.8 0.6 84 PERK 76 0 46 33.9 5.4 5.4 145 7.6 1.0 85 PORT 118 0 53 33.4 1.9 1.9 93 8.6 0.3 86 PRYO 77 0 55 33.4 2.7 2.7 119 6.6 0.5 87 PUTN 78 0 30 33.9 7.0 6.9 162 9.8 0.9 88 REDR 79 0 49 33.4 5.2 5.2 158 8.1 0.8 89 RING 81 0 50 32.9 2.8 2.7 134 10.3 0.4 90 SALL 82 0 65 30.9 1.8 1.7 116 11.3 0.5 91 SEIL 83 0 28 34.7 6.2 6.1 176 11.6 1.3 92 SEMI 143 0 58 32.4 1.4 1.4 154 14.4 0.3 93 SHAW 84 0 54 32.1 3.9 3.9 151 6.3 0.6 94 SKIA 85 0 59 32.6 1.3 1.3 124 11.3 0.3 95 SLAP 86 0 27 34.0 10.8 10.7 166 7.7 1.5 96 SPEN 87 0 54 32.2 2.8 2.7 142 13.2 0.6 97 STIG 88 0 59 32.8 3.5 3.4 108 6.9 0.5 98 STIL 89 0 49 33.6 3.6 3.4 152 20.4 0.9 99 STUA 90 0 61 32.1 1.2 1.2 89 12.2 0.2 100 SULP 91 0 51 32.3 2.1 2.1 121 11.6 0.3 101 TAHL 92 0 57 32.5 2.1 2.1 89 15.4 0.5 102 TALA 138 0 57 32.9 3.7 3.6 144 10.5 0.6 103 TALI 93 0 55 32.6 1.5 1.5 114 13.7 0.5 104 TIPT 94 0 38 34.1 8.0 7.9 137 8.2 1.1 105 TISH 95 0 55 31.5 3.9 3.8 130 13.4 0.9 106 TULN 137 0 53 33.4 1.9 1.9 111 16.5 0.5 107 VALL 140 0 81 28.3 0.6 0.5 313 33.8 0.2 108 VINI 97 0 60 32.7 2.8 2.8 140 6.3 0.3 109 WAL2 136 0 49 33.0 5.9 5.8 149 7.5 1.0 110 WASH 99 0 54 32.2 3.9 3.8 146 12.6 0.7 111 WATO 100 0 40 33.6 7.2 7.0 151 12.9 1.1 112 WAUR 101 0 46 33.4 3.8 3.8 136 10.0 1.0 113 WEAT 102 0 41 33.4 8.8 8.6 139 8.8 1.0 114 WEBR 132 0 73 26.6 5.1 5.0 340 9.7 1.2 115 WEST 104 0 60 30.9 2.4 2.3 83 14.9 0.6 116 WILB 105 0 57 32.2 3.7 3.7 110 8.3 0.7 117 WIST 106 0 54 31.6 2.0 1.9 70 10.5 0.7 118 WOOD 107 0 32 33.9 7.3 7.2 168 11.2 1.0 119 WYNO 108 0 64 31.5 3.0 3.0 148 7.2 0.3 120 YUKO 142 0 50 31.8 4.8 4.7 157 12.6 1.0 121 &lt;/pre &gt; NA NA NA NA NA NA NA NA WMAX RAIN PRES SRAD TA9M WS2M TS10 TB10 TS05 1 6.9 0.00 964.79 272 31.8 4.0 29.2 36.2 31.6 2 2.2 0.00 976.20 245 32.0 0.2 28.8 38.2 29.6 3 11.5 0.00 960.94 296 34.7 6.8 29.3 34.1 30.7 4 9.0 0.00 957.45 298 35.5 5.4 24.7 34.7 25.6 5 0.0 0.00 990.11 213 27.8 0.0 29.5 31.1 30.2 6 7.9 0.00 959.54 277 31.9 4.6 30.4 35.2 34.7 7 3.6 0.00 979.23 256 32.6 2.1 30.2 37.1 30.1 8 10.0 0.00 927.19 334 33.4 4.3 31.9 35.0 33.1 9 15.2 0.00 921.20 335 34.6 8.9 32.2 30.6 34.2 10 11.2 0.00 950.82 306 33.4 6.4 32.5 35.5 33.5 11 3.9 0.00 988.72 250 33.5 2.4 25.8 33.7 28.7 12 7.3 0.00 974.53 258 33.9 4.2 23.0 35.4 24.5 13 17.4 0.00 866.96 377 33.1 11.4 28.0 28.6 29.1 14 9.5 0.00 969.03 295 33.9 5.2 27.7 35.3 27.2 15 2.6 0.00 982.60 242 32.4 1.0 31.0 37.8 31.1 16 4.2 0.00 996.78 227 31.4 1.6 27.8 33.1 30.1 17 11.9 0.00 943.56 316 35.1 5.0 29.8 32.9 32.5 18 4.9 0.00 975.46 248 32.2 1.7 31.3 35.9 33.3 19 3.4 0.00 983.39 250 32.9 0.8 28.8 36.9 29.3 20 10.1 0.00 949.47 303 34.0 4.9 27.5 34.2 28.1 21 4.2 0.00 970.91 255 31.6 2.2 29.7 37.0 32.5 22 10.8 0.00 941.71 308 34.2 5.7 28.2 34.7 30.0 23 5.7 0.00 975.92 266 33.3 3.3 28.7 36.8 29.7 24 3.5 0.00 986.00 112 29.7 1.6 27.9 35.5 28.7 25 4.0 0.00 976.88 269 32.0 2.5 30.8 31.6 31.3 26 8.4 0.00 966.36 303 36.4 4.1 29.0 36.5 29.7 27 12.1 0.00 930.41 311 33.2 7.3 28.4 35.1 31.9 28 6.1 0.00 972.14 260 32.6 3.0 25.8 38.6 25.6 29 5.3 0.00 988.40 240 32.3 2.4 27.9 37.4 27.0 30 3.6 0.00 984.70 233 30.9 0.9 30.4 32.8 31.7 31 1.8 0.00 976.35 245 31.0 0.4 24.9 35.0 26.5 32 4.1 0.00 981.60 245 32.6 2.0 28.3 35.5 28.8 33 4.0 0.00 987.06 386 30.3 1.9 30.3 37.1 30.9 34 11.9 0.00 942.36 308 33.3 6.1 23.7 35.0 25.0 35 7.7 0.00 961.89 283 32.1 4.2 26.4 33.7 26.3 36 11.2 0.00 940.01 305 33.9 6.1 28.3 34.1 28.6 37 4.5 0.00 987.15 238 32.7 1.9 30.0 33.6 31.0 38 17.7 0.00 888.05 356 34.0 9.3 28.2 28.5 27.0 39 10.0 0.00 961.94 294 35.5 5.1 25.6 35.5 25.0 40 3.6 0.00 970.02 258 32.0 2.0 28.7 38.1 31.2 41 5.6 0.00 972.42 254 31.8 2.5 29.8 37.1 31.8 42 10.4 0.00 947.30 317 34.9 5.8 -999.0 33.2 -999.0 43 9.8 0.00 961.42 282 33.0 5.3 31.1 36.4 33.4 44 15.0 0.00 895.45 182 34.0 9.0 31.7 32.0 32.7 45 8.7 0.00 969.95 279 33.9 5.2 30.0 35.2 29.3 46 6.2 0.00 971.87 260 32.5 3.9 30.3 36.3 33.1 47 3.6 0.00 988.96 240 33.6 2.1 27.0 34.2 27.9 48 2.9 0.00 982.37 248 32.5 0.7 28.9 36.8 29.3 49 9.7 0.00 953.56 290 32.1 5.0 31.5 35.1 33.2 50 10.6 0.00 955.30 292 33.3 6.4 26.1 35.0 30.2 51 3.4 0.00 978.03 251 32.2 1.6 30.4 35.8 32.6 52 11.0 0.00 951.40 294 34.4 5.5 29.8 34.0 33.4 53 14.9 0.00 904.65 274 35.0 8.9 29.2 29.7 31.2 54 -996.0 -996.00 -996.00 -996 -996.0 -996.0 -996.0 -996.0 -996.0 55 1.2 0.00 997.36 94 30.5 0.3 30.0 34.0 28.5 56 2.9 0.00 988.30 254 33.6 1.5 27.1 37.1 28.0 57 2.2 0.00 976.36 235 31.2 0.6 25.6 -999.0 29.9 58 19.1 0.00 860.82 330 33.2 11.3 28.4 32.3 30.6 59 6.0 0.00 970.94 265 31.9 2.9 29.9 36.5 30.8 60 9.0 0.00 972.00 288 34.1 5.4 30.4 37.4 30.9 61 8.9 0.00 963.46 313 34.9 4.0 24.5 33.7 26.5 62 0.8 0.00 989.16 268 28.0 0.1 29.4 31.5 28.3 63 3.0 0.00 982.87 248 32.6 0.7 28.0 36.8 29.9 64 10.0 0.00 956.03 297 34.9 4.7 29.5 35.1 32.2 65 6.2 0.00 972.39 251 32.3 2.9 25.5 35.9 27.0 66 12.9 0.00 944.67 310 34.7 6.4 27.7 33.1 28.1 67 2.9 0.00 983.72 247 31.9 0.2 31.2 32.7 33.2 68 10.4 0.00 970.70 244 34.5 5.8 25.0 34.9 26.4 69 8.5 0.00 954.31 290 32.1 4.8 31.5 36.9 35.9 70 4.9 0.00 982.40 239 32.4 2.1 28.0 32.0 29.4 71 9.1 0.00 960.87 284 32.0 5.3 30.6 35.8 30.5 72 6.9 0.00 973.46 119 33.5 3.9 28.2 35.1 28.4 73 2.6 0.00 978.01 221 31.1 0.5 25.4 32.5 26.5 74 7.6 0.00 968.47 264 32.1 4.4 28.1 35.1 29.1 75 3.2 0.00 977.28 259 32.4 1.6 23.4 33.4 24.2 76 4.4 0.00 986.44 242 33.0 2.0 29.0 34.4 30.5 77 6.6 0.00 969.30 308 32.7 3.0 26.7 34.7 28.2 78 4.0 0.00 980.69 255 32.2 1.9 28.5 36.6 30.8 79 5.9 0.00 969.45 268 32.5 3.0 32.7 37.1 35.0 80 3.1 0.00 980.34 248 32.4 1.6 30.1 37.7 32.1 81 3.4 0.00 986.68 -999 32.7 1.5 28.1 36.7 29.1 82 4.7 0.00 976.71 251 32.9 1.2 30.5 35.7 31.5 83 6.3 0.00 977.80 258 32.5 3.7 31.2 34.3 31.0 84 7.1 0.00 976.41 258 33.1 4.5 27.6 37.1 27.8 85 2.7 0.00 987.90 241 33.5 1.3 24.8 39.2 26.9 86 3.9 0.00 987.05 235 33.3 1.5 26.4 -999.0 28.1 87 9.1 0.00 942.26 307 33.7 4.9 26.7 31.6 -999.0 88 7.0 0.00 976.02 264 33.3 3.9 30.1 35.5 31.6 89 3.7 0.00 977.35 264 32.6 2.1 27.9 34.0 28.6 90 2.6 0.00 992.27 66 31.2 1.2 30.1 32.2 -999.0 91 9.6 0.00 946.47 304 34.3 4.6 28.9 32.9 29.6 92 2.3 0.00 976.90 256 32.4 1.1 30.8 37.5 32.5 93 5.3 0.00 972.85 259 32.2 2.6 28.2 37.0 28.5 94 1.9 0.00 977.87 233 32.3 0.5 30.8 34.4 31.4 95 13.7 0.00 920.30 334 33.6 8.1 33.1 33.7 34.5 96 4.1 0.00 967.54 268 31.8 1.7 30.4 38.0 31.9 97 4.4 0.00 990.21 307 32.9 2.3 29.4 32.1 32.1 98 5.6 0.00 978.52 252 33.4 2.9 25.4 35.1 27.0 99 1.9 0.25 980.67 251 32.1 0.3 29.5 37.9 32.2 100 2.8 0.00 973.43 257 32.4 1.2 28.8 34.6 29.9 101 3.2 0.00 977.48 233 32.8 1.6 27.4 34.0 29.3 102 4.8 0.00 984.20 244 33.1 2.7 28.4 36.2 30.0 103 2.7 0.00 986.77 237 32.3 0.6 31.3 35.5 32.0 104 11.2 0.00 964.45 294 33.8 6.0 28.5 37.0 27.8 105 6.8 0.00 979.18 252 31.1 3.3 30.2 39.1 30.0 106 3.1 0.00 986.08 242 33.5 1.3 27.4 34.8 28.5 107 0.9 5.08 996.17 99 28.3 0.0 28.0 30.0 29.4 108 3.7 0.00 983.44 236 32.8 1.8 28.9 31.4 29.3 109 7.9 0.00 972.43 277 33.0 4.5 26.1 37.2 27.9 110 5.3 0.00 970.63 286 32.3 2.7 27.1 35.4 29.5 111 9.5 0.00 950.74 299 32.9 5.3 30.2 35.1 -999.0 112 5.8 0.00 977.31 268 33.2 2.8 29.6 38.3 28.2 113 11.5 0.00 948.10 297 32.7 6.2 30.2 37.1 31.0 114 8.3 0.51 993.83 64 27.0 3.5 27.2 36.4 28.9 115 3.8 0.00 971.36 244 31.3 1.3 25.8 30.5 29.7 116 5.3 0.00 987.14 235 32.3 2.6 28.3 31.0 28.2 117 3.5 0.00 993.88 212 32.0 0.6 25.5 35.7 27.6 118 9.5 0.00 937.70 310 33.9 5.7 27.6 35.6 27.7 119 4.1 0.00 979.18 241 31.8 2.0 32.9 35.2 32.1 120 7.7 0.00 963.71 149 31.9 4.0 26.0 34.5 27.4 121 NA NA NA NA NA NA NA NA NA TS25 TS60 TR05 TR25 TR60 1 25.2 21.7 3.09 2.22 1.48 2 26.8 -998.0 2.61 1.88 -998.00 3 26.1 -998.0 3.39 2.47 -998.00 4 22.6 -998.0 2.70 1.60 -998.00 5 26.8 23.8 1.96 1.73 1.33 6 28.2 22.8 1.79 1.53 1.78 7 26.2 23.5 2.59 1.41 1.42 8 26.9 22.6 2.64 3.02 2.57 9 27.1 22.8 3.53 2.43 2.11 10 26.2 -998.0 3.15 3.34 -998.00 11 23.0 20.5 2.01 1.44 1.49 12 20.3 18.0 2.14 2.97 3.40 13 25.3 21.7 3.82 3.70 3.79 14 23.7 20.6 2.92 2.19 1.63 15 26.8 23.5 1.66 1.47 1.43 16 -998.0 -998.0 -999.00 -998.00 -998.00 17 26.6 23.1 2.99 2.70 2.22 18 -998.0 -998.0 2.11 -998.00 -998.00 19 25.8 23.5 2.20 1.84 1.66 20 24.6 20.1 2.11 2.78 2.27 21 27.1 23.8 2.10 1.39 1.49 22 25.2 -998.0 3.24 3.29 -998.00 23 24.6 21.2 3.36 3.54 2.50 24 24.1 21.9 2.11 1.60 -999.00 25 26.3 -998.0 1.73 1.40 -998.00 26 26.6 22.5 3.60 2.16 2.17 27 26.4 22.8 2.94 3.20 3.67 28 -998.0 -998.0 2.06 -998.00 -998.00 29 -998.0 -998.0 2.37 -998.00 -998.00 30 27.2 -998.0 1.90 1.90 -998.00 31 -998.0 -998.0 2.38 -998.00 -998.00 32 24.9 21.6 1.84 1.35 1.38 33 27.5 24.2 2.11 1.31 1.38 34 22.4 19.8 3.06 3.29 2.61 35 22.9 19.8 2.54 2.07 1.51 36 26.9 23.3 1.53 1.93 2.15 37 27.4 23.4 1.89 1.46 1.32 38 23.2 20.4 3.78 3.90 3.86 39 24.4 20.8 2.23 1.91 1.72 40 24.3 21.7 3.13 2.02 1.43 41 25.1 21.3 3.02 1.42 1.35 42 25.3 21.2 3.67 2.26 2.57 43 27.9 24.8 2.02 1.60 1.67 44 25.7 20.9 3.89 3.52 3.67 45 25.1 22.5 3.31 2.24 1.40 46 27.8 -998.0 3.20 2.43 -998.00 47 23.6 20.6 1.80 1.43 1.38 48 25.5 23.3 2.06 1.80 1.44 49 27.6 23.0 1.86 2.26 1.69 50 25.0 21.3 2.99 2.82 3.55 51 27.3 23.1 2.01 1.34 1.42 52 26.3 23.1 3.65 3.38 3.28 53 26.6 23.1 2.64 3.26 3.71 54 -996.0 -998.0 -996.00 -996.00 -998.00 55 27.4 -998.0 2.80 1.33 -998.00 56 24.2 20.4 1.79 1.39 1.43 57 23.8 -998.0 1.32 1.43 -998.00 58 26.3 -998.0 3.67 3.73 -998.00 59 26.9 23.4 2.36 2.03 1.62 60 27.1 23.3 2.82 2.21 2.06 61 22.9 19.8 2.19 2.99 2.16 62 26.1 23.0 1.58 1.68 1.38 63 -998.0 -998.0 2.30 -998.00 -998.00 64 25.7 -998.0 -999.00 -999.00 -998.00 65 24.0 21.0 2.79 2.22 1.54 66 25.3 21.0 3.27 2.67 2.15 67 28.9 -998.0 1.77 1.79 -998.00 68 -998.0 -998.0 2.26 -998.00 -998.00 69 28.5 -998.0 3.27 2.71 -998.00 70 24.6 20.5 1.50 1.44 1.38 71 25.3 -998.0 2.43 2.18 -998.00 72 25.5 -998.0 2.52 2.13 -998.00 73 -998.0 -998.0 2.08 -998.00 -998.00 74 24.8 21.0 2.09 1.61 1.35 75 -998.0 -998.0 -999.00 -998.00 -998.00 76 24.4 21.5 1.87 1.43 1.44 77 24.0 20.9 2.97 2.03 1.35 78 26.2 22.2 3.25 2.28 1.55 79 28.9 24.2 2.62 1.99 1.69 80 26.8 -998.0 1.93 1.53 -998.00 81 23.8 -998.0 2.35 1.84 -998.00 82 26.5 23.0 2.14 1.48 1.49 83 25.7 21.7 2.53 2.95 1.49 84 24.9 21.8 2.77 1.99 1.37 85 23.4 21.1 2.10 1.39 1.45 86 24.3 -998.0 1.45 1.35 -998.00 87 26.4 22.2 3.63 2.65 2.62 88 25.1 22.4 2.21 1.70 1.33 89 25.3 -998.0 1.83 2.22 -998.00 90 27.2 23.2 1.87 1.33 1.35 91 25.7 22.8 2.73 3.09 2.31 92 27.7 23.6 2.32 1.34 1.34 93 25.0 21.6 2.21 1.53 1.40 94 25.2 21.9 1.48 1.50 1.53 95 28.1 24.4 3.14 2.16 2.04 96 28.1 23.1 1.63 1.65 1.77 97 27.2 23.2 1.76 1.66 1.36 98 23.5 20.7 2.85 2.76 2.11 99 26.7 22.9 2.64 1.64 1.42 100 -998.0 -998.0 1.96 -998.00 -998.00 101 -998.0 -998.0 2.08 -998.00 -998.00 102 24.8 21.1 1.96 1.36 2.13 103 27.7 -998.0 1.36 1.39 -998.00 104 26.0 23.7 2.53 1.83 1.56 105 27.1 -998.0 2.16 2.25 -998.00 106 24.5 21.8 2.32 1.37 1.35 107 26.5 23.7 1.49 1.47 1.38 108 24.5 20.9 1.75 1.34 1.37 109 24.2 21.9 1.57 2.81 1.62 110 25.6 22.9 1.72 1.67 1.40 111 26.3 21.4 2.49 3.73 3.56 112 26.7 23.6 2.28 1.86 1.46 113 25.4 -998.0 3.52 3.19 -998.00 114 24.7 22.3 2.23 1.77 1.82 115 24.2 -998.0 1.38 1.42 -998.00 116 25.3 22.3 2.01 1.40 1.45 117 23.3 20.8 1.70 1.48 1.39 118 24.9 21.9 1.97 2.53 2.02 119 27.4 -998.0 2.24 1.37 -998.00 120 24.7 21.0 2.58 1.42 1.38 121 NA NA NA NA NA The readr package creates data-frame like objects called tibbles (really, they’re a souped-up data frame), but it is much friendlier to use. Tibbles also do not have the problems with factors (see the introduction to factors) - they will always read characters in as characters. library(readr) # Better data importing in R Attaching package: &#39;readr&#39; The following object is masked from &#39;package:rvest&#39;: guess_encoding read_table(url, skip = 2) # Gosh, that was much easier! Parsed with column specification: cols( .default = col_double(), STID = col_character() ) See spec(...) for full column specifications. # A tibble: 121 x 24 STID STNM TIME RELH TAIR WSPD WVEC WDIR WDSD WSSD WMAX RAIN PRES &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 ACME 110 0 53 31.8 5.2 5.1 146 8.5 0.7 6.9 0 965. 2 ADAX 1 0 55 32.4 1 0.8 108 36.5 0.4 2.2 0 976. 3 ALTU 2 0 31 35.6 8.9 8.7 147 10.9 1.1 11.5 0 961. 4 ALV2 116 0 27 35.8 6.7 6.7 145 8.2 1.2 9 0 957. 5 ANT2 135 0 73 27.8 0 0 0 0 0 0 0 990. 6 APAC 111 0 52 32.3 6.2 6.1 133 9.8 0.8 7.9 0 960. 7 ARD2 126 0 46 32.9 2.6 2.5 150 11.8 0.5 3.6 0 979. 8 ARNE 6 0 28 33.5 6.5 6.3 163 11.9 1.5 10 0 927. 9 BEAV 8 0 23 34.9 11.2 11.1 165 7.3 1.4 15.2 0 921. 10 BESS 9 0 37 33.8 8.3 8.3 156 6.6 1.3 11.2 0 951. # … with 111 more rows, and 11 more variables: SRAD &lt;dbl&gt;, TA9M &lt;dbl&gt;, # WS2M &lt;dbl&gt;, TS10 &lt;dbl&gt;, TB10 &lt;dbl&gt;, TS05 &lt;dbl&gt;, TS25 &lt;dbl&gt;, TS60 &lt;dbl&gt;, # TR05 &lt;dbl&gt;, TR25 &lt;dbl&gt;, TR60 &lt;dbl&gt; In SAS, it’s a bit more complicated. There’s a non-reproducible GUI method in enterprise guide. Alternately, we can use a data step: /* This downloads the file to my machine */ /* x &quot;curl https://www.mesonet.org/index.php/dataMdfMts/dataController/getFile/202006070000/mdf/TEXT/ &gt; ~/Projects/Class/unl-stat850/2020-stat850/data/mesodata.txt&quot; */ /* only run this once */ data mesodata; infile &quot;~/Projects/Class/unl-stat850/2020-stat850/data/mesodata.txt&quot; firstobs = 4; /* Skip the first 3 rows */ length STID $ 4; /* define ID length */ input STID $ STNM TIME RELH TAIR WSPD WVEC WDIR WDSD WSSD WMAX RAIN PRES SRAD TA9M WS2M TS10 TB10 TS05 TS25 TS60 TR05 TR25 TR60; run; proc print data=mesodata (obs=10); /* print the first 10 observations */ run; Obs STID STNM TIME RELH TAIR WSPD WVEC WDIR WDSD WSSD WMAX RAIN PRES SRAD TA9M WS2M TS10 TB10 TS05 TS25 TS60 TR05 TR25 TR60 1 ACME 110 0 53 31.8 5.2 5.1 146 8.5 0.7 6.9 0 964.79 272 31.8 4.0 29.2 36.2 31.6 25.2 21.7 3.09 2.22 1.48 2 ADAX 1 0 55 32.4 1.0 0.8 108 36.5 0.4 2.2 0 976.20 245 32.0 0.2 28.8 38.2 29.6 26.8 -998.0 2.61 1.88 -998.00 3 ALTU 2 0 31 35.6 8.9 8.7 147 10.9 1.1 11.5 0 960.94 296 34.7 6.8 29.3 34.1 30.7 26.1 -998.0 3.39 2.47 -998.00 4 ALV2 116 0 27 35.8 6.7 6.7 145 8.2 1.2 9.0 0 957.45 298 35.5 5.4 24.7 34.7 25.6 22.6 -998.0 2.70 1.60 -998.00 5 ANT2 135 0 73 27.8 0.0 0.0 0 0.0 0.0 0.0 0 990.11 213 27.8 0.0 29.5 31.1 30.2 26.8 23.8 1.96 1.73 1.33 6 APAC 111 0 52 32.3 6.2 6.1 133 9.8 0.8 7.9 0 959.54 277 31.9 4.6 30.4 35.2 34.7 28.2 22.8 1.79 1.53 1.78 7 ARD2 126 0 46 32.9 2.6 2.5 150 11.8 0.5 3.6 0 979.23 256 32.6 2.1 30.2 37.1 30.1 26.2 23.5 2.59 1.41 1.42 8 ARNE 6 0 28 33.5 6.5 6.3 163 11.9 1.5 10.0 0 927.19 334 33.4 4.3 31.9 35.0 33.1 26.9 22.6 2.64 3.02 2.57 9 BEAV 8 0 23 34.9 11.2 11.1 165 7.3 1.4 15.2 0 921.20 335 34.6 8.9 32.2 30.6 34.2 27.1 22.8 3.53 2.43 2.11 10 BESS 9 0 37 33.8 8.3 8.3 156 6.6 1.3 11.2 0 950.82 306 33.4 6.4 32.5 35.5 33.5 26.2 -998.0 3.15 3.34 -998.00 In SAS data statements, you generally need to specify the data names explicitly. 4.2.2 Delimited Text Files Delimited text files are files where fields are separated by a specific character, such as &quot; “,”,&quot;, tab, etc. Often, delimited text files will have the column names as the first row in the file. As long as you know the delimiter, it’s pretty easy to read in data from these files in R using the readr package. url &lt;- &quot;https://raw.githubusercontent.com/shahinrostami/pokemon_dataset/master/pokemon_gen_1_to_8.csv&quot; pokemon_info &lt;- read_csv(url) Warning: Missing column names filled in: &#39;X1&#39; [1] Parsed with column specification: cols( .default = col_double(), name = col_character(), german_name = col_character(), japanese_name = col_character(), status = col_character(), species = col_character(), type_1 = col_character(), type_2 = col_character(), ability_1 = col_character(), ability_2 = col_character(), ability_hidden = col_character(), growth_rate = col_character(), egg_type_1 = col_character(), egg_type_2 = col_character() ) See spec(...) for full column specifications. pokemon_info[1:6, 1:6] # Show only the first 6 lines &amp; cols # A tibble: 6 x 6 X1 pokedex_number name german_name japanese_name generation &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 0 1 Bulbasaur Bisasam フシギダネ (Fushigidane)… 1 2 1 2 Ivysaur Bisaknosp フシギソウ (Fushigisou)… 1 3 2 3 Venusaur Bisaflor フシギバナ (Fushigibana)… 1 4 3 3 Mega Venusa… Bisaflor フシギバナ (Fushigibana)… 1 5 4 4 Charmander Glumanda ヒトカゲ (Hitokage) 1 6 5 5 Charmeleon Glutexo リザード (Lizardo) 1 # a file delimited with | url &lt;- &quot;https://raw.githubusercontent.com/srvanderplas/unl-stat850/master/data/NE_Features_20200501.txt&quot; nebraska_locations &lt;- read_delim(url, delim = &quot;|&quot;) Parsed with column specification: cols( .default = col_character(), FEATURE_ID = col_double(), PRIM_LAT_DEC = col_double(), PRIM_LONG_DEC = col_double(), SOURCE_LAT_DEC = col_double(), SOURCE_LONG_DEC = col_double(), ELEV_IN_M = col_double(), ELEV_IN_FT = col_double() ) See spec(...) for full column specifications. nebraska_locations[1:6, 1:6] # A tibble: 6 x 6 FEATURE_ID FEATURE_NAME FEATURE_CLASS STATE_ALPHA STATE_NUMERIC COUNTY_NAME &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 171013 Peetz Table Area CO 08 Logan 2 171029 Sidney Draw Valley NE 31 Cheyenne 3 182687 Highline Canal Canal CO 08 Sedgwick 4 182688 Cottonwood Cre… Stream CO 08 Sedgwick 5 182689 Sand Draw Valley CO 08 Sedgwick 6 182690 Sedgwick Draw Valley CO 08 Sedgwick You can also read in the same files using read.csv and read.delim, which are the equivalent base R functions. url &lt;- &quot;https://raw.githubusercontent.com/shahinrostami/pokemon_dataset/master/pokemon_gen_1_to_8.csv&quot; pokemon_info &lt;- read.csv(url, header = T, stringsAsFactors = F) pokemon_info[1:6, 1:6] # Show only the first 6 lines &amp; cols X pokedex_number name german_name japanese_name 1 0 1 Bulbasaur Bisasam フシギダネ (Fushigidane) 2 1 2 Ivysaur Bisaknosp フシギソウ (Fushigisou) 3 2 3 Venusaur Bisaflor フシギバナ (Fushigibana) 4 3 3 Mega Venusaur Bisaflor フシギバナ (Fushigibana) 5 4 4 Charmander Glumanda ヒトカゲ (Hitokage) 6 5 5 Charmeleon Glutexo リザード (Lizardo) generation 1 1 2 1 3 1 4 1 5 1 6 1 # a file delimited with | url &lt;- &quot;https://raw.githubusercontent.com/srvanderplas/unl-stat850/master/data/NE_Features_20200501.txt&quot; nebraska_locations &lt;- read.delim(url, sep = &quot;|&quot;, header = T) nebraska_locations[1:6, 1:6] FEATURE_ID FEATURE_NAME FEATURE_CLASS STATE_ALPHA STATE_NUMERIC 1 171013 Peetz Table Area CO 8 2 171029 Sidney Draw Valley NE 31 3 182687 Highline Canal Canal CO 8 4 182688 Cottonwood Creek Stream CO 8 5 182689 Sand Draw Valley CO 8 6 182690 Sedgwick Draw Valley CO 8 COUNTY_NAME 1 Logan 2 Cheyenne 3 Sedgwick 4 Sedgwick 5 Sedgwick 6 Sedgwick SAS also has procs to accommodate CSV and other delimited files. PROC IMPORT may be the simplest way to do this, but of course PROC DATA will work as well. We do have to tell SAS to treat the data file as a UTF-8 file (because of the japanese characters) and that it needs to think carefully about the delimiters (the DSD option – this tells it sequential delimiters = missing values, among other things). While writing this code, I got an error of “Invalid logical name” because originally the filename was pokemonloc. It turns out your dataset names in SAS are limited to 8 characters. Ugh. /* x &quot;curl https://raw.githubusercontent.com/shahinrostami/pokemon_dataset/master/pokemon_gen_1_to_8.csv &gt; ~/Projects/Class/unl-stat850/2020-stat850/data/pokemon.csv&quot;; only run this once... */ filename pokeloc &quot;~/Projects/Class/unl-stat850/2020-stat850/data/pokemon.csv&quot; encoding=&quot;utf-8&quot; DSD; proc import datafile = pokeloc out=poke DBMS = csv; /* comma delimited file */ GETNAMES = YES ; proc print data=poke (obs=10); /* print the first 10 observations */ run; Note: Due to UTF-8 issues, this code chunk runs when I paste it into SAS, but does not run in bookdown. The only abnormal thing is that on my computer, the japanese characters don’t render. /* x &quot;curl https://raw.githubusercontent.com/srvanderplas/unl-stat850/master/data/NE_Features_20200501.txt &gt; ~/Projects/Class/unl-stat850/2020-stat850/data/NE_Features_20200501.txt&quot;; only run this once... */ data nefeatures; infile &quot;~/Projects/Class/unl-stat850/2020-stat850/data/NE_Features_20200501.txt&quot; dlm=&#39;|&#39; /* specify delimiter */ encoding=&quot;utf-8&quot; /* specify encoding */ DSD /* delimiter sensitive data */ missover /* keep going if missing obs encountered */ firstobs=2; /* skip header row */ input FEATURE_ID $ FEATURE_NAME $ FEATURE_CLASS $ STATE_ALPHA $ STATE_NUMERIC COUNTY_NAME $ COUNTY_NUMERIC $ PRIMARY_LAT_DMS $ PRIM_LONG_DMS $ PRIM_LAT_DEC PRIM_LONG_DEC SOURCE_LAT_DMS $ SOURCE_LONG_DMS $ SOURCE_LAT_DEC SOURCE_LONG_DEC ELEV_IN_M ELEV_IN_FT MAP_NAME $ DATE_CREATED $ DATE_EDITED $ ; run; proc print data=nefeatures (obs=10); /* print the first 10 observations */ run; In this example, it was easier to use a data step to import things, because for some reason proc import didn’t like the delimiter. It’s ok to use a roundabout way to solve a problem - you only really need to know one or two good solutions to a problem. 4.3 Binary Files Both R and SAS have binary data files that store data in a more compact form. It is relatively common for government websites, in particular, to provide SAS data in binary form. Luckily, it is possible to read the binary data files in both programs. We can read the same file into R using the sas7bdat library: if (!&quot;sas7bdat&quot; %in% installed.packages()) install.packages(&quot;sas7bdat&quot;) library(sas7bdat) data &lt;- read.sas7bdat(&quot;https://github.com/srvanderplas/unl-stat850/raw/master/data/cen10pub.sas7bdat&quot;) str(data) &#39;data.frame&#39;: 150147 obs. of 8 variables: $ HOUSEID : Factor w/ 150147 levels &quot;20000017&quot;,&quot;20000231&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... $ HH_CBSA10 : Factor w/ 20 levels &quot;-1&quot;,&quot;-9&quot;,&quot;12060&quot;,..: 20 20 20 12 1 20 14 20 8 20 ... $ RAIL10 : Factor w/ 2 levels &quot;01&quot;,&quot;02&quot;: 2 2 2 1 2 2 2 2 2 2 ... $ CBSASIZE10: Factor w/ 7 levels &quot;-9&quot;,&quot;01&quot;,&quot;02&quot;,..: 3 4 4 6 7 4 6 4 6 3 ... $ CBSACAT10 : Factor w/ 5 levels &quot;-9&quot;,&quot;01&quot;,&quot;02&quot;,..: 4 4 4 2 5 4 3 4 3 4 ... $ URBAN10 : Factor w/ 5 levels &quot;-9&quot;,&quot;01&quot;,&quot;02&quot;,..: 5 2 2 2 5 2 2 2 2 2 ... $ URBSIZE10 : Factor w/ 7 levels &quot;-9&quot;,&quot;01&quot;,&quot;02&quot;,..: 7 4 4 6 7 3 5 3 5 2 ... $ URBRUR10 : Factor w/ 3 levels &quot;-9&quot;,&quot;01&quot;,&quot;02&quot;: 3 2 2 2 3 2 2 2 2 2 ... - attr(*, &quot;pkg.version&quot;)= chr &quot;0.5&quot; - attr(*, &quot;column.info&quot;)=List of 8 ..$ :List of 12 .. ..$ name : chr &quot;HOUSEID&quot; .. ..$ offset: int 0 .. ..$ length: int 8 .. ..$ type : chr &quot;character&quot; .. ..$ format: chr &quot;$&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 68 .. ..$ flen : int 1 .. ..$ label : chr &quot;HH eight-digit ID number&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 44 .. ..$ llen : int 24 ..$ :List of 12 .. ..$ name : chr &quot;HH_CBSA10&quot; .. ..$ offset: int 8 .. ..$ length: int 5 .. ..$ type : chr &quot;character&quot; .. ..$ format: chr &quot;$CHAR&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 148 .. ..$ flen : int 5 .. ..$ label : chr &quot;HH CBSA location, 2013 CBSA definitions based on 2010 Census&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 88 .. ..$ llen : int 60 ..$ :List of 11 .. ..$ name : chr &quot;RAIL10&quot; .. ..$ offset: int 13 .. ..$ length: int 2 .. ..$ type : chr &quot;character&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 0 .. ..$ flen : int 0 .. ..$ label : chr &quot;CBSA (2010) heavy rail status for HH&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 172 .. ..$ llen : int 36 ..$ :List of 11 .. ..$ name : chr &quot;CBSASIZE10&quot; .. ..$ offset: int 15 .. ..$ length: int 2 .. ..$ type : chr &quot;character&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 0 .. ..$ flen : int 0 .. ..$ label : chr &quot;CBSA (2010) population size for the HH home address&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 220 .. ..$ llen : int 51 ..$ :List of 11 .. ..$ name : chr &quot;CBSACAT10&quot; .. ..$ offset: int 17 .. ..$ length: int 2 .. ..$ type : chr &quot;character&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 0 .. ..$ flen : int 0 .. ..$ label : chr &quot;CBSA category for the HH home address&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 284 .. ..$ llen : int 37 ..$ :List of 11 .. ..$ name : chr &quot;URBAN10&quot; .. ..$ offset: int 19 .. ..$ length: int 2 .. ..$ type : chr &quot;character&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 0 .. ..$ flen : int 0 .. ..$ label : chr &quot;Home address in urbanized area&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 332 .. ..$ llen : int 30 ..$ :List of 11 .. ..$ name : chr &quot;URBSIZE10&quot; .. ..$ offset: int 21 .. ..$ length: int 2 .. ..$ type : chr &quot;character&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 0 .. ..$ flen : int 0 .. ..$ label : chr &quot;Size of urban area in which home address is located&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 376 .. ..$ llen : int 51 ..$ :List of 11 .. ..$ name : chr &quot;URBRUR10&quot; .. ..$ offset: int 23 .. ..$ length: int 2 .. ..$ type : chr &quot;character&quot; .. ..$ fhdr : int 0 .. ..$ foff : int 0 .. ..$ flen : int 0 .. ..$ label : chr &quot;Household in urban/rural area (2010 Urban definition)&quot; .. ..$ lhdr : int 0 .. ..$ loff : int 436 .. ..$ llen : int 53 - attr(*, &quot;date.created&quot;)= POSIXct, format: &quot;2014-06-30 14:35:55&quot; - attr(*, &quot;date.modified&quot;)= POSIXct, format: &quot;2014-06-30 14:35:55&quot; - attr(*, &quot;SAS.release&quot;)= chr &quot;9.0202M2&quot; - attr(*, &quot;SAS.host&quot;)= chr &quot;W32_VSPR&quot; - attr(*, &quot;OS.version&quot;)= chr &quot;&quot; - attr(*, &quot;OS.maker&quot;)= chr &quot;&quot; - attr(*, &quot;OS.name&quot;)= chr &quot;&quot; - attr(*, &quot;endian&quot;)= chr &quot;little&quot; - attr(*, &quot;winunix&quot;)= chr &quot;windows&quot; If you are curious about what this data means, then by all means, take a look at the codebook (XLSX file). For now, it’s enough that we can see roughly how it’s structured. 4.4 Importing Tabular Data into R 4.5 Importing Tabular Data into SAS 4.6 Exploratory Data Analysis tables summary statistics basic plots? unique values 4.7 References Reading JSON in SAS – You know SAS documentation is getting weird when they advertise a method as “the sexiest way to import JSON data into SAS”. Reading Rdata files in SAS Common problems with SAS data files U.S. Department of Transportation, Federal Highway Administration, 2009 National Household Travel Survey. URL: http://nhts.ornl.gov. Data acquired from data.world. though there are a seemingly infinite number of actual formats, and they pop up at the most inconvenient times↩ "],
["manipulating-data.html", "Module 5 Manipulating Data Module Objectives 5.1 Filter 5.2 Select 5.3 Group By 5.4 Summarize", " Module 5 Manipulating Data Module Objectives Filter, subset, and clean data to prepare a dataset for analysis Describe and document operations performed on a data set transparently, and implement the operations using reproducible steps. 5.1 Filter 5.2 Select 5.3 Group By 5.4 Summarize "],
["transforming-data.html", "Module 6 Transforming Data Module Objectives 6.1 Pivot operations 6.2 Summaries 6.3 Separating one variable into many", " Module 6 Transforming Data Module Objectives Create summaries of data appropriate for additional analysis or display Reshape data Transform variables to support analysis and visualization of data 6.1 Pivot operations 6.1.1 Wider 6.1.2 Longer 6.2 Summaries 6.3 Separating one variable into many "],
["debugging.html", "Module 7 Principles of Debugging Module Objectives 7.1 Ideal Function Design 7.2 Debugging Tools in R 7.3 Debugging Tools in SAS 7.4 Minimal Working Examples 7.5 Researching Error Messages", " Module 7 Principles of Debugging Module Objectives Break down a complex procedure into simpler steps, mapping each step to a separate function which performs a single task. Simplify a problem to the minimal components necessary to reproduce the error, and use that information to ask for help appropriately. Use built-in debugging tools to trace an error to its source Use online forums and mailing lists to research error messages Note: The skills in this chapter take a lifetime to truly master. The real goal here is that you know how to ask for help appropriately (and in a way that people will respond positively to) and that you know how to do the research to get help yourself. 7.1 Ideal Function Design 7.2 Debugging Tools in R 7.3 Debugging Tools in SAS 7.4 Minimal Working Examples 7.5 Researching Error Messages "],
["data-vis-intro.html", "Module 8 Introduction to Data Visualization Module Objectives 8.1 Creating Charts in SAS 8.2 Creating Charts in R (base) 8.3 The Grammar of Graphics 8.4 Good charts", " Module 8 Introduction to Data Visualization Module Objectives Create statistical charts in SAS and R Use the grammar of graphics to describe different types of charts and graphs Use the grammar of graphics to create layered graphics and highlight different features of a data set Modify or construct alternate charts showing the same material with better readability and accessibility 8.1 Creating Charts in SAS 8.2 Creating Charts in R (base) 8.3 The Grammar of Graphics There are a lot of different types of charts. How do we classify them all? Introduce grammar of graphics as implemented in ggplot2 8.4 Good charts Good charts are important "],
["data-analysis.html", "Module 9 Introduction to Data Analysis Module Objectives 9.1 Models in SAS 9.2 Models in R", " Module 9 Introduction to Data Analysis Module Objectives Analyze data using simple statistical analyses Assess model fit for different model types using generic tools. 9.1 Models in SAS 9.2 Models in R 9.2.1 Standard Models 9.2.2 Tidymodels "],
["simulation.html", "Module 10 Simulation and Reproducibility Module Objectives 10.1 Pseudorandom Number Generation 10.2 Random Number Generation and Reproducibility", " Module 10 Simulation and Reproducibility Module Objectives Understand how pseudorandom number generation works and necessary conditions for reproducibility Be able to implement a simulation for a specific statistical task or model 10.1 Pseudorandom Number Generation 10.2 Random Number Generation and Reproducibility 10.2.1 Seeds 10.2.2 Rmarkdown Reproducibility "],
["docs-reports.html", "Module 11 Documents and Reports Module Objectives 11.1 Slides 11.2 Posters 11.3 Other options", " Module 11 Documents and Reports Module Objectives Create presentation slides in LaTeX and rmarkdown Create posters in LaTeX and rmarkdown Create a CV in LaTeX and/or rmarkdown 11.1 Slides 11.1.1 Beamer (LaTeX) and knitr 11.1.2 xaringan 11.2 Posters 11.2.1 Beamer (LaTeX) and knitr 11.2.2 Pagedown 11.2.3 xaringan 11.2.4 pagedown 11.3 Other options Jupyter with SAS "],
["presentations.html", "Module 12 Dynamic Presentations 12.1 Slides 12.2 Posters", " Module 12 Dynamic Presentations 12.1 Slides 12.1.1 Beamer (LaTeX) and knitr 12.1.2 xaringan 12.2 Posters 12.2.1 Beamer (LaTeX) and knitr 12.2.2 Pagedown "],
["references-2.html", "References", " References "]
]
