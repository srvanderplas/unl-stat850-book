[
["debugging.html", "Module 7 Principles of Debugging Module Objectives 7.1 Defensive Programming 7.2 General Debugging Strategies 7.3 Debugging Tools in R 7.4 Debugging Tools in SAS 7.5 Minimal Working Examples References", " Module 7 Principles of Debugging Module Objectives Break down a complex procedure into simpler steps, mapping each step to a separate function which performs a single task. Simplify a problem to the minimal components necessary to reproduce the error, and use that information to ask for help appropriately. Use built-in debugging tools to trace an error to its source Use online forums and mailing lists to research error messages Note: The skills in this chapter take a lifetime to truly master. The real goal here is that you know how to ask for help appropriately (and in a way that people will respond positively to) and that you know how to do the research to get help yourself. “It has a ghost in it. Take it back.” “No.” (xkcd #1316) 7.1 Defensive Programming One of the best debugging strategies (that isn’t a debugging strategy at all, really) is to code defensively. By that, I mean, code in a way that you will make debugging things easier later. Modularize your code. Each function should do only one task, ideally in the least-complex way possible. Make your code readable. If you can read the code easily, you’ll be able to narrow down the location of the bug more quickly. Comment your code. This makes it more likely that you will be able to locate the spot where the bug is likely to have occurred, and will remind you how things are calculated. Remember, comments aren’t just for your collaborators or others who see the code. They’re for future you. Don’t duplicate code. If you have the same code (or essentially the same code) in two or three different places, put that code in a function and call the function instead. This will save you trouble when updating the code in the future, but also makes narrowing down the source of the bug less complex. Reduce the number of dependencies you have on outside software packages. Often bugs are introduced when a dependency is updated and the functionality changes slightly. The tidyverse is notorious for this. It’s ok to write code using lots of dependencies, but as you transition from “experimental” code to “production” code (you’re using the code without tinkering with it) you should work to reduce the dependencies. Add safeguards against unexpected inputs. Check to make sure inputs to the function are valid. Check to make sure intermediate results are reasonable (e.g. you don’t compute the derivative of a function and come up with “a”.) Don’t reinvent the wheel. If you have working, tested code for a task, use that! If someone else has working code that’s used by the community, don’t write your own unless you have a very good reason. The implementation of lm has been better tested than your homegrown linear regression. (This is easier if you’re writing modular code to begin with) Collect your often-reused code in packages (R) or scripts (SAS) that you can easily load and make available to “future you” Wikipedia’s article on defensive programming is much more general than the applications to statistical programming, but may be worth scanning. 7.2 General Debugging Strategies Debugging: Being the detective in a crime movie where you are also the murderer. - some t-shirt I saw once While defensive programming is a nice idea, if you’re already at the point where you have an error you can’t diagnose, then… it doesn’t help that much. At that point, you’ll need some general debugging strategies to work with. The overall process is well described in Advanced R by H. Wickham1; I’ve copied it here because it’s such a succinct distillation of the process, but I’ve adapted some of the explanations to this class rather than the original c ontext of package development. Realize that you have a bug Google! In R you can automate this with the errorist and searcher packages. In SAS, if the error message isn’t that clear you’ll find a SAS forum page where someone else has made the same mistake - I can almost guarantee it. Make the error repeatable: This makes it easier to figure out what the error is, faster to iterate, and easier to ask for help. Use binary search (remove 1/2 of the code, see if the error occurs, if not go to the other 1/2 of the code. Repeat until you’ve isolated the error.) Generate the error faster - use a minimal test dataset, if possible, so that you can ask for help easily and run code faster. This is worth the investment if you’ve been debugging the same error for a while. Note which inputs don’t generate the bug – this negative “data” is helpful when asking for help. Figure out where it is. Debuggers may help with this, but you can also use the scientific method to explore the code, or the tried-and-true method of using lots of print() statements. Fix it and test it. The goal with tests is to ensure that the same error doesn’t pop back up in a future version of your code. Generate an example that will test for the error, and add it to your documentation. If you’re developing a package, unit test suites offer a more formalized way to test errors and you can automate your testing so that every time your code is changed, tests are run and checked. There are several other general strategies for debugging: Visualize your data as it moves through the program. This may be done using print() statements, or the debugger, or some other strategy depending on your application. Tracing statements. Again, this is part of print() debugging, but these messages indicate progress - “got into function x”, “returning from function y”, and so on. Rubber ducking. Have you ever tried to explain a problem you’re having to someone else, only to have a moment of insight and “oh, nevermind”? Rubber ducking outsources the problem to a nonjudgemental entity, such as a rubber duck2. You simply explain, in terms simple enough for your rubber duck to understand, exactly what your code does, line by line, until you’ve found the problem. A more thorough explanation can be found at gitduck.com. Figure 7.1: You may find it helpful to procure a rubber duck expert for each language you work in. I use color-your-own rubber ducks to endow my ducks with certain language expertise. Other people use plain rubber ducks and give them capes. Do not be surprised if, in the process of debugging, you encounter new bugs. This is a problem that’s well-known enough that it has its own t-shirt, in addition to an xkcd comic. At some point, getting up and going for a walk may help. Redesigning your code to be more modular and more organized is also a good idea. 7.3 Debugging Tools in R Now that we’ve discussed general strategies for debugging that will work in any language, lets get down to the dirty details of debugging in R. 7.3.1 Low tech debugging with print() and other tools Sometimes called “tracing” techniques, the most common, universal, and low tech strategy for debugging involves scattering messages throughout your code. When the code is executed, you get a window into what the variables look like during execution. Simple example Imagine we start with this: a &lt;- function(x) { b &lt;- function(y) { c &lt;- function(z) { z + y } c(3) } x + b(4) } a(5) ## [1] 12 and the goal is to understand what’s happening in the code. We might add some lines: a &lt;- function(x) { print(paste(&quot;Entering a(). x = &quot;, x)) b &lt;- function(y) { print(paste(&quot;Entering b(). x = &quot;, x, &quot;y = &quot;, y)) c &lt;- function(z) { print(paste(&quot;Entering c(). x = &quot;, x, &quot;y = &quot;, y, &quot;z = &quot;, z)) cres &lt;- z + y print(paste(&quot;Returning&quot;, cres, &quot;from c()&quot;)) cres } bres &lt;- c(3) print(paste(&quot;Returning&quot;, bres, &quot;from b()&quot;)) bres } ares &lt;- x + b(4) print(paste(&quot;Returning&quot;,ares, &quot;from a()&quot;)) ares } a(5) ## [1] &quot;Entering a(). x = 5&quot; ## [1] &quot;Entering b(). x = 5 y = 4&quot; ## [1] &quot;Entering c(). x = 5 y = 4 z = 3&quot; ## [1] &quot;Returning 7 from c()&quot; ## [1] &quot;Returning 7 from b()&quot; ## [1] &quot;Returning 12 from a()&quot; ## [1] 12 For more complex data structures, it can be useful to add str(), head(), or summary() functions. Real world example I was recently writing a webscraper to get election polling data from the RealClearPolitics site as part of the electionViz package. I wrote the function search_for_parent() to get the parent HTML tag which matched the “tag” argument, that had the “node” argument as a descendant. I was assuming that the order of the parents would be “html”, “body”, “div”, “table”, “tbody”, “tr” - descending from outer to inner (if you know anything about HTML/XML structure). library(xml2) # read html search_for_parent &lt;- function(node, tag) { # Get all of the parent nodes parents &lt;- xml2::xml_parents(node) # Get the tags of every parent node tags &lt;- purrr::map_chr(parents, rvest::html_name) print(tags) # Find matching taggs matches &lt;- which(tags == tag) print(matches) # Take the minimum matching tag min_match &lt;- min(matches) if (length(matches) == 1) return(parents[min_match]) else return(NULL) } page &lt;- read_html(&quot;data/realclearpolitics_frag.html&quot;) node &lt;- xml_find_all(page, &quot;//td[@class=&#39;lp-results&#39;]&quot;) # find all poll results in any table search_for_parent(node[1], &quot;table&quot;) # find the table that contains it ## [1] &quot;tr&quot; &quot;tbody&quot; &quot;table&quot; &quot;div&quot; &quot;body&quot; &quot;html&quot; ## [1] 3 ## {xml_nodeset (1)} ## [1] &lt;table cellpadding=&quot;2&quot; cellspacing=&quot;0&quot; class=&quot;sortable&quot;&gt;\\n&lt;thead&gt;&lt;tr clas ... By printing out all of the tags that contain node, I could see the order – inner to outer. I asked the function to return the location of the first table node, so the index (2nd value printed out) should match table in the character vector that was printed out first. I could then see that the HTML node that is returned is in fact the table node. Try it out Not all bugs result in error messages, unfortunately, which makes higher-level techniques like traceback() less useful. The low-tech debugging tools, however, still work wonderfully. library(ggplot2) library(dplyr) library(magrittr) library(maps) library(ggthemes) worldmap &lt;- map_data(&quot;world&quot;) # Load the data data(storms, package = &quot;dplyr&quot;) The code below is supposed to print out a map of the tracks of all hurricanes of a specific category, 1 to 5, in 2013. Use print statements to figure out what’s wrong with my code. # Make base map to be used for each iteration basemap &lt;- ggplot() + # Country shapes geom_polygon(aes(x = long, y = lat, group = group), data = worldmap, fill = &quot;white&quot;, color = &quot;black&quot;) + # Zoom in coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + # Don&#39;t need scales b/c maps provide their own geographic context... theme_map() for (i in 1:5) { # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(status == i) # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) print(plot) } Solution First, lets split the setup from the loop. # Make base map to be used for each iteration basemap &lt;- ggplot() + # Country shapes geom_polygon(aes(x = long, y = lat, group = group), data = worldmap, fill = &quot;white&quot;, color = &quot;black&quot;) + # Zoom in coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + # Don&#39;t need scales b/c maps provide their own geographic context... theme_map() print(basemap) # make sure the basemap is fine # Load the data data(storms, package = &quot;dplyr&quot;) str(storms) # make sure the data exists and is formatted as expected ## tibble [10,010 × 13] (S3: tbl_df/tbl/data.frame) ## $ name : chr [1:10010] &quot;Amy&quot; &quot;Amy&quot; &quot;Amy&quot; &quot;Amy&quot; ... ## $ year : num [1:10010] 1975 1975 1975 1975 1975 ... ## $ month : num [1:10010] 6 6 6 6 6 6 6 6 6 6 ... ## $ day : int [1:10010] 27 27 27 27 28 28 28 28 29 29 ... ## $ hour : num [1:10010] 0 6 12 18 0 6 12 18 0 6 ... ## $ lat : num [1:10010] 27.5 28.5 29.5 30.5 31.5 32.4 33.3 34 34.4 34 ... ## $ long : num [1:10010] -79 -79 -79 -79 -78.8 -78.7 -78 -77 -75.8 -74.8 ... ## $ status : chr [1:10010] &quot;tropical depression&quot; &quot;tropical depression&quot; &quot;tropical depression&quot; &quot;tropical depression&quot; ... ## $ category : Ord.factor w/ 7 levels &quot;-1&quot;&lt;&quot;0&quot;&lt;&quot;1&quot;&lt;&quot;2&quot;&lt;..: 1 1 1 1 1 1 1 1 2 2 ... ## $ wind : int [1:10010] 25 25 25 25 25 25 25 30 35 40 ... ## $ pressure : int [1:10010] 1013 1013 1013 1013 1012 1012 1011 1006 1004 1002 ... ## $ ts_diameter: num [1:10010] NA NA NA NA NA NA NA NA NA NA ... ## $ hu_diameter: num [1:10010] NA NA NA NA NA NA NA NA NA NA ... Everything looks ok in the setup chunk… for (i in 1:5) { print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(status == i) print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # str(subdata) works too, but produces more clutter. I started # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) # print(plot) # Don&#39;t print plots - clutters up output at the moment } ## [1] &quot;Category 1 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 2 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 3 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 4 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 5 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; Ok, so from this we can see that something is going wrong with our filter statement - we have no rows of data. head(storms) ## # A tibble: 6 x 13 ## name year month day hour lat long status category wind pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropi… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropi… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropi… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropi… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropi… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropi… -1 25 1012 ## # … with 2 more variables: ts_diameter &lt;dbl&gt;, hu_diameter &lt;dbl&gt; Whoops. I meant “category” when I typed “status”. for (i in 1:5) { print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(category == i) print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # str(subdata) works too, but produces more clutter. I started # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) # print(plot) # Don&#39;t print plots - clutters up output at the moment } ## [1] &quot;Category 1 storms&quot; ## [1] &quot;subdata dims: nrow 13 ncol 13&quot; ## [1] &quot;Category 2 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 3 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 4 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; ## [1] &quot;Category 5 storms&quot; ## [1] &quot;subdata dims: nrow 0 ncol 13&quot; Ok, that’s something, at least. We now have some data for category 1 storms… filter(storms, year == 2013) %&gt;% # Get max category for each named storm group_by(name) %&gt;% filter(category == max(category)) %&gt;% ungroup() %&gt;% # See what categories exist select(name, category) %&gt;% unique() ## # A tibble: 14 x 2 ## name category ## &lt;chr&gt; &lt;ord&gt; ## 1 Andrea 0 ## 2 Barry 0 ## 3 Chantal 0 ## 4 Dorian 0 ## 5 Erin 0 ## 6 Fernand 0 ## 7 Gabrielle 0 ## 8 Eight -1 ## 9 Humberto 1 ## 10 Ingrid 1 ## 11 Jerry 0 ## 12 Karen 0 ## 13 Lorenzo 0 ## 14 Melissa 0 It looks like 2013 was just an incredibly quiet year for tropical activity. 2004, however, was not. So let’s just make sure our code works by checking out 2004. for (i in 1:5) { print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2004) %&gt;% filter(category == i) print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # str(subdata) works too, but produces more clutter. I started # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) print(plot) # Don&#39;t print plots - clutters up output at the moment } ## [1] &quot;Category 1 storms&quot; ## [1] &quot;subdata dims: nrow 45 ncol 13&quot; ## [1] &quot;Category 2 storms&quot; ## [1] &quot;subdata dims: nrow 39 ncol 13&quot; ## [1] &quot;Category 3 storms&quot; ## [1] &quot;subdata dims: nrow 29 ncol 13&quot; ## [1] &quot;Category 4 storms&quot; ## [1] &quot;subdata dims: nrow 32 ncol 13&quot; ## [1] &quot;Category 5 storms&quot; ## [1] &quot;subdata dims: nrow 12 ncol 13&quot; If we want to only print informative plots, we could add an if statement. Now that the code works, we can also comment out our print() statements (we could delete them, too, depending on whether we anticipate future problems with the code). for (i in 1:5) { # print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(category == i) # print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # # str(subdata) works too, but produces more clutter. I started # # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) if (nrow(subdata) &gt; 0) print(plot) } 7.3.2 After an error has occurred - traceback() traceback() can help you narrow down where an error occurs by taking you through the series of function calls that led up to the error. This can help, but it can also be pretty arcane. traceback() example a &lt;- function(x) { b &lt;- function(y) { c &lt;- function(z) { stop(&#39;there was a problem&#39;) # This generates an error } c() } b() } a() ## Error in c(): there was a problem For more information, you could run traceback traceback() Which will provide the following output: 4: stop(&quot;there was a problem&quot;) at #4 3: c() at #6 2: b() at #8 1: a() Reading through this, we see that a() was called, b() was called, c() was called, and then there was an error. It’s even kind enough to tell us that the error occurred at line 4 of the code. If you are running this code interactively in RStudio, it’s even easier to run traceback() by clicking on the “Show Traceback” option that appears when there is an error. Figure 7.2: Both Show Traceback and Rerun with Debug are useful tools If you are using source() to run the code in Rstudio, it will even provide a link to the file and line location of the error. 7.3.3 browser() - debugging your own code, interactively The browser() function is useful for debugging your own code. If you’re writing a function and something isn’t working quite right, you can insert a call to browser() in that function, and examine what’s going on. Example of using browser() Suppose that I want to write a function that will plot an xkcd comic in R. I start with library(png) library(xml2) # get the most current xkcd or the specified number get_xkcd &lt;- function(id = NULL) { url &lt;- &quot;http://xkcd.com&quot; page &lt;- read_html(url) # Find the comic image &lt;- xml_find_first(page, &quot;//div[@id=&#39;comic&#39;]/img&quot;) %&gt;% # pull the address out of the tag xml_attr(&quot;src&quot;) readPNG(source = image) } Watch this live-coding video to see how I use browser() to figure out what’s going on in the function and how to fix it. Here’s the final function library(png) library(xml2) library(tidyverse) ## ── Attaching packages ────────────────────────────────────────────────────────────────────────────────── tidyverse 1.3.0 ── ## ✓ tibble 3.0.1 ✓ purrr 0.3.4 ## ✓ tidyr 1.1.0 ✓ stringr 1.4.0 ## ✓ readr 1.3.1 ✓ forcats 0.4.0 ## ── Conflicts ───────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## x tidyr::extract() masks magrittr::extract() ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() ## x purrr::map() masks maps::map() ## x purrr::set_names() masks magrittr::set_names() # get the most current xkcd or the specified number get_xkcd &lt;- function(id = NULL) { url &lt;- &quot;http://xkcd.com&quot; page &lt;- read_html(url) # Find the comic image &lt;- xml_find_first(page, &quot;//div[@id=&#39;comic&#39;]/img&quot;) %&gt;% # pull the address out of the tag xml_attr(&quot;src&quot;) # Fix image address so that we can access the image image &lt;- substr(image, 3, nchar(image)) # Download the file to a temp file and read from there file_location &lt;- tempfile(fileext = &quot;.png&quot;) download.file(image, destfile = file_location, quiet = T) readPNG(source = file_location) } get_xkcd() %&gt;% as.raster() %&gt;% plot() 7.3.4 debug() - the general debugging workhorse In the traceback() Rstudio output, the other option is “rerun with debug”. In short, debug mode opens up a new interactive session inside the function evaluation environment. This lets you observe what’s going on in the function, pinpoint the error (and what causes it), and potentially fix the error, all in one neat workflow. debug() is most useful when you’re working with code that you didn’t write yourself. So, if you can’t change the code in the function causing the error, debug() is the way to go. Otherwise, using browser() is generally easier. Essentially, debug() places a browser() statement at the first line of a function, but without having to actually alter the function’s source code. Example of using debug data(iris) tmp &lt;- lm(Species ~ ., data = iris) ## Warning in model.response(mf, &quot;numeric&quot;): using type = &quot;numeric&quot; with a factor ## response will be ignored ## Warning in Ops.factor(y, z$residuals): &#39;-&#39; not meaningful for factors summary(tmp) ## Warning in Ops.factor(r, 2): &#39;^&#39; not meaningful for factors ## ## Call: ## lm(formula = Species ~ ., data = iris) ## ## Residuals: ## Error in quantile.default(resid): factors are not allowed We get this weird warning, and then an error about factors when we use summary() to look at the coefficients. debug(lm) # turn debugging on tmp &lt;- lm(Species ~ ., data = iris) summary(tmp) undebug(lm) # turn debugging off) The first thing I see when I run lm after turning on debug (screenshot) The variables passed into the lm function are available as named and used in the function. In addition, we have some handy buttons in the console window that will let us ‘drive’ through the function After pressing “next” a few times, you can see that I’ve stepped through the first few lines of the lm function. We can see that once we’re at line 21, we get a warning about using type with a factor response, and that the warning occurs during a call to the model.response function. So, we’ve narrowed our problem down - we passed in a numeric variable as the response (y) variable, but it’s a factor, so our results aren’t going to mean much. We were using the function wrong. We probably could have gotten there from reading the error message carefully, but this has allowed us to figure out exactly what happened, where it happened, and why it happened. I can hit “Stop” or type “Q” to exit the debug environment. But, until I run undebug(lm), every call to lm will take me into the debug window. undebug(f) will remove the debug flag on the function f. debugonce(f) will only debug f the first time it is run. Try it out larger(x, y) is supposed to return the elementwise maximum of two vectors. larger &lt;- function(x, y) { y.is.bigger &lt;- y &gt; x x[y.is.bigger] &lt;- y[y.is.bigger] x } larger(c(1, 5, 10), c(2, 4, 11)) ## [1] 2 5 11 larger(c(1, 5, 10), 6) ## [1] 6 NA 10 Why is there an NA in the second example? It should be a 6. Figure out why this happens, then try to fix it. Solution I’ll replicate “debug” in non-interactive mode by setting up an environment where x and y are defined x &lt;- c(1, 5, 10) y &lt;- 6 # Inside of larger() with x = c(1, 5, 10), y = 6 (y.is.bigger &lt;- y &gt; x ) # putting something in () prints it out ## [1] TRUE TRUE FALSE y[y.is.bigger] # This isn&#39;t quite what we were going for, but it&#39;s what&#39;s causing the issue ## [1] 6 NA x[y.is.bigger] # What gets replaced ## [1] 1 5 # Better option larger &lt;- function(x, y) { y.is.bigger &lt;- y &gt; x ifelse(y.is.bigger, y, x) } 7.4 Debugging Tools in SAS In SAS, there are two stages that occur after you submit lines to the console. - The Compilation Phase: code is parsed. In this step, SAS will catch the logic errors, misspellings, missing key words, etc. - The Execution Phase: program is run. In this step, SAS will catch any wrong assignments, loop issues, etc. Sas recognizes four types of errors: - Syntax errors - violations of the language structure - Semantic errors - structure of the statement is incorrect, but the syntax is correct. e.g. trying to reference an index that doesn’t exist. - Execution-time errors - errors that occur when the compiled function is run on data values – e.g. division by zero - Data errors - errors that occur when statements are correct but data is invalid (taking the log of a negative number, etc.) SAS is built around enterprise users, as opposed to R’s open-source philosophy. SAS code also is more formulaic than R code, which means it is usually easier to figure out what is going wrong with the code. As a result, you may find that errors in your SAS code are much easier to diagnose than errors in your R code. Generally, it will tell you exactly where you are missing a semicolon, or exactly what word it thinks you’ve misspelled (and usually, it tries to correct that for you, but it doesn’t always succeed). In my experience with SAS (which is very limited and mostly contained in this book), SAS error messages are much easier to google and find solutions, right up until you’re working in Linux or some other not-well-supported system and the error is related to how the underlying OS handles some task. As a downside, though, trying to do a task SAS doesn’t think you need to do can be much more difficult than necessary. See the references section for a couple of good guides to SAS error statements and warnings. These guides are likely sufficient for most of your SAS debugging needs. There are certainly other errors which can occur in SAS – logic errors are not something SAS can protect you from . These errors can have dramatic consequences, as demonstrated in this twitter thread about a JAMA retraction due to a coding error. To debug these types of errors, you can use the same print() techniques demonstrated in R. For these types of errors, there’s nothing special about what language you’re using (outside of the usual quirks of every language) - the error is in the logic, not the encoding of that logic. 7.5 Minimal Working Examples If all else has failed, and you can’t figure out what is causing your error, it’s probably time to ask for help. If you have a friend or buddy that knows the language you’re working in, by all means ask for help sooner - use them as a rubber duck if you have to. But when you ask for help online, often you’re asking people who are much more knowledgeable about the topic - members of R core and SAS browse stackoverflow and may drop in and help you out. Under those circumstances, it’s better to make the task of helping you as easy as possible because it shows respect for their time. The same thing goes for your supervisors and professors. So, with that said, there are numerous resources for writing what’s called a “minimal working example”, “reproducible example” (commonly abbreviated reprex), or MCVE (minimal complete verifiable example). Much of this is lifted directly from the StackOverflow post describing a minimal reproducible example. The goal is to reproduce the error message with information that is - minimal - as little code as possible to still reproduce the problem - complete - everything necessary to reproduce the issue is contained in the description/question - reproducible - test the code you provide to reproduce the problem. You should format your question to make it as easy as possible to help you. Make it so that code can be copied from your post directly and pasted into a terminal. Describe what you see and what you’d hope to see if the code were working. References Stalking the elusive computer bug - the etymology and historical use of the term “debugging”, from Thomas Edison to Grace Hopper. Debugging (lecture materials from software construction class at MIT) - written with java, but mostly comprehensible for any language. Debugging with RStudio An Introduction to the Interactive Debugging Tools in R Stackoverflow: General Suggestions for Debugging in R WTF R - What They Forgot to Teach You about R Debugging chapter Debugging 101 in SAS Debugging SAS Programs - Ch. 1: The Basics of Debugging A webinar by Jenny Bryan/RStudio on Reproducible Examples the 0th step is from the 1st edition, the remaining steps are from the 2nd.↩ Some people use cats, but I find that they don’t meet the nonjudgemental criteria. Of course, they’re equally judgemental whether your code works or not, so maybe that works if you’re a cat person, which I am not. Dogs, in my experience, can work, but often will try to comfort you when they realize you’re upset, which both helps and lessens your motivation to fix the problem. A rubber duck is the perfect dispassionate listener.↩ "]
]
