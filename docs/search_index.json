[
["index.html", "Stat 850: Computing Tools for Statisticians Introduction", " Stat 850: Computing Tools for Statisticians Susan Vanderplas 2020-05-22 Introduction "],
["tools.html", "Module 1 Tools for Statistical Computing 1.1 Course Outline 1.2 R and RStudio 1.3 SAS 1.4 LaTeX 1.5 Version Control with Git", " Module 1 Tools for Statistical Computing This course requires that you have the following software installed on your machine: git SAS 9.4 (or later) R (3.5 or higher) RStudio LaTeX You will also need to sign up for a GitHub account This chapter will provide instructions for how to install and configure these programs (or how to obtain them), but first, it may be useful to get a “big picture” overview of how the course is structured 1.1 Course Outline The goal of this class is to expose you to basic computing skills in R and SAS, which are two of the more common languages for statistical computing (python is the 3rd most common, and is particularly popular in data science and machine learning, but will not be explicitly taught in this class.) SAS is another extensively used statistical programming language. … 1.2 R and RStudio R is a statistical computing language which originated as an open-source clone of Bell labs S computing language. S was inspired by Scheme, but also has features which are similar to Lisp. It is a scripting language (you don’t have to compile the code before it runs) and is natively accessed using a command-line prompt. One feature of R that is relatively unique is that it uses vector-based math, which means that mathematical operations on vectors occur for the entire vector without having to use loops to iterate through the vector line-by-line. R is optimized for working on data: unlike more general-purpose programming languages such as Python, R was built with the idea of facilitating data analysis. As a result, data structures in R tend to be more natural for statistical work. From a computer science perspective, though, R seems like an extremely odd language because the design choices that make data analysis easier are unconventional for more general-purpose languages. RStudio is an integrated development environment for R. Basically, it adds a pretty graphical layer on top of R, providing an easy way to develop R code, evaluate that code, and keep track of all of the variables which are available in the computing environment. RStudio contains integrations which provide syntax highlighting, code folding, basic checks (missing parentheses, etc.), and many other features. RStudio was designed around the idea of making R easier to use and making it easy to develop statistical software reproducibly. RStudio (the company) is responsible for adding many features to the R ecosystem which facilitate running statistical analyses and presenting the results in user-friendly ways. 1.2.1 Getting Set up: R 1.2.2 Getting Set up: RStudio 1.2.3 Exploring RStudio 1.3 SAS 1.4 LaTeX LaTeX purpose Overleaf vs. TexMaker and other GUIs For now, LaTeX is going to sit there under the hood and be used by other programs 1.5 Version Control with Git Explanation of why version control matters (phD comic) 1.5.1 Getting set up: git 1.5.2 Getting set up: github 1.5.3 Git and Github Explain the difference between the two "],
["intro-prog.html", "Module 2 Introduction to Statistical Programming 2.1 Statistical Programming Concepts 2.2 Overgrown Calculators 2.3 Basic Programming in R 2.4 Basic Programming in SAS", " Module 2 Introduction to Statistical Programming Many programming resources talk about 3, or 5, or 10 core concepts in any programming language. In this module, we’re going to discuss the generic concepts, and then how these concepts are implemented in R and SAS. Interestingly, the “core concepts” aren’t necessarily the same across lists. So, here is a consensus list of concepts which are generic across languages and usually important: Variables - a symbolic name or reference to some kind of information. In the expression a + b &gt; a, both a and b are variables. Variables may have a specific type (what data can be stored in the variable), scope (where the variable can be accessed), location (in memory). Here is a nice explanation of the difference between variables in programming and variables in math. Conditional statements (if statements) - These statements allow the program to handle information adaptively - if a statement is true, one set of instructions will be used, and if the statement is false, a different set of instructions will be used. Looping and iteration - An iteration is any time a sequence of steps is executed. Most languages have several different types of loops or iteration: for loops, which allow for the sequence of steps to be executed a specific number of times, while loops, which allow for the sequence of steps to be executed while a conditional statement is true, recursion, where a block of code calls itself. Data types and data structures - these concepts determine what information a variable can hold. Data types are lower-level, simple objects (floating-point numbers, integers, boolean T/F, characters, strings). Data structures may include lists (sequences of many objects) and vectors (sequences of many objects of the same type), dictionaries (a list of key-value pairs), objects (data structures which may hold multiple related pieces of information). Functions, or self-contained modules of code that accomplish a particular task. Syntax, the set of rules that define which combinations of symbols consist of correctly structured and interpretable commands in the language. Tools, the set of external programs which may help with development and writing code. Some common tools are IDEs (Integrated Development Environments), which may correct syntax and typos, organize files for you, allow you to keep track of which variables you have defined, and assist you with code organization and navigation. Other tools include compilers (which take human-written code and translate it into efficient machine code), version control systems (which help you track changes to code over time), debuggers, and documentation generators. Not all of these tools are necessary for all languages - scripting languages such as python and R do not require compilers by default, for instance. Sequence of commands: It’s important to have the right commands in the right order. Some recipes, like bread dough, are flexible, and you can add the ingredients in almost any order, but in other recipes, the order matters as much as the correct quantity of ingredients (try putting the cheese powder in before the noodles are boiled when making macaroni and cheese. Yuck.). Programming tends to be like these less flexible recipes. Non-Exhaustive List of Sources: https://blog.upperlinecode.com/computer-language-fundamentals-five-core-concepts-1aa43e929f40 https://howtoprogramwithjava.com/programming-101-the-5-basic-concepts-of-any-programming-language/ https://dev.to/lucpattyn/basic-programming-concepts-for-beginners-2o73 http://livecode.byu.edu/programmingconcepts/ControlStruct.php http://holowczak.com/programming-concepts-tutorial-programmers/ 2.1 Statistical Programming Concepts Having established the generic definitions of the concepts which apply to almost any programming language, we now must examine how R and SAS implement these concepts. R and SAS are both statistical programming languages - they are specifically designed to work with data, which means that they make compromises that other languages do not in order to make it easier to write code where the data (rather than the functions, classes, methods, or objects) are the primary concern. Both R and SAS have long histories. SAS in particular dates back to the 1960s, and has syntax which is unique compared to more modern languages such as C, python, Java, and R. R’s predecessor, S, dates back to 1976 and was designed for internal use at Bell Labs. The histories of both languages are useful in understanding why they are useful for their respective tasks, but are not essential for this course (so read them at your leisure). 2.1.1 Variable types 2.1.1.1 R In R, there are 4 commonly-used types: Type Description character holds text-based information: “abcd” or “3.24a” are examples of values which would be stored as characters in R logical holds binary information: 0/1, or FALSE/TRUE. Logical variables are stored as single bit information (e.g. either a 0 or 1), but display as TRUE and FALSE (which are reserved words and constants). It is possible to use the shorthand F and T, but be careful with this, because F and T are not reserved, and other information can be stored within them. integer holds (as you might expect) integers. Note that integers are handled differently than doubles (floating point numbers), but in general, R will implicitly convert integers to doubles to avoid common pitfalls with integer divison (which does not allow for decimals). double holds floating point numbers. By default, most numeric variables in R are doubles. You can test to see whether a variable holds a value of a specific type using the is.xxx() functions, which are demonstrated below. Note that &lt;- is used for assigning a value to a variable. So the first line in the code below is read “x gets ‘R is awesome’” or “x is assigned the value ‘R is awesome’”. Character Variables x &lt;- &quot;R is awesome&quot; is.character(x) [1] TRUE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] FALSE Logical Variables x &lt;- FALSE is.character(x) [1] FALSE is.logical(x) [1] TRUE is.integer(x) [1] FALSE is.double(x) [1] FALSE Integer Variables x &lt;- 2 is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] TRUE Wait, 2 is an integer, right? It is, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically. x &lt;- 2L # The L immediately after the 2 indicates that it is an integer. is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] TRUE is.double(x) [1] FALSE is.numeric(x) [1] TRUE Double Variables x &lt;- 2.45 is.character(x) [1] FALSE is.logical(x) [1] FALSE is.integer(x) [1] FALSE is.double(x) [1] TRUE is.numeric(x) [1] TRUE A fifth common type, numeric is really the union of two types: integer and double. This mostly exists because when doing math, we can add an integer and a double, but adding an integer and a string is … trickier. Testing for numeric variables guarantees that we’ll be able to do math with those variables. The general case of this property of a language is called implicit type conversion - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double. R will generally work hard to seamlessly convert variables to different types. So, for instance, TRUE + 2 [1] 3 2L + 3.1415 [1] 5.1415 &quot;abcd&quot; + 3 Error in &quot;abcd&quot; + 3: non-numeric argument to binary operator This conversion doesn’t always work - there’s no clear way to make “abcd” into a number we could use in addition. So instead, R will issue an error. This error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops. When you want to, you can also use as.xxx() to make the type conversion explicit. So, the analogue of the code above, with explicit conversions would be: as.double(TRUE) + 2 [1] 3 as.double(2L) + 3.1415 [1] 5.1415 as.numeric(&quot;abcd&quot;) + 3 Warning: NAs introduced by coercion [1] NA When we make our intent explicit (convert “abcd” to a numeric variable) we get an NA - a missing value. There’s still no easy way to figure out where “abcd” is on a number line, but our math will still have a result - NA + 3 is NA. If you are unsure what the type of a variable is, use the class() function to find out. w &lt;- &quot;a string&quot; x &lt;- 3L y &lt;- 3.1415 z &lt;- FALSE class(w) [1] &quot;character&quot; class(x) [1] &quot;integer&quot; class(y) [1] &quot;numeric&quot; class(z) [1] &quot;logical&quot; Notice that the generic type name for double is “numeric”. R’s typing scheme is pretty flexible, which can sometimes lead to apparent inconsistencies. 2.1.1.2 SAS In SAS, there are two basic variable types: numeric and character variables. Thus, SAS does not differentiate between integers and floats or doubles. Functionally, though, the same basic operations can be performed in SAS. As with R, SAS does attempt to implicitly convert variable types, and will notify you that the conversion has taken place in the log file. SAS will attempt to implicitly convert variables when: a character value is assigned to a previously defined numeric variable a character value is used in arithmetic operations a character value is compared to a numeric value using a comparison operator (&lt;, &gt;, &lt;=, &gt;=) a character value is specified in a function that takes numeric arguments Note that implicit conversion does not occur in WHERE statements. (This will make more sense later, but is here for reference) If you want to manually convert a value, the INPUT statement can be used. Unlike in R, the INPUT statement has the ability to read numbers which are formatted differently. For instance proc printto log=&quot;saslog.log&quot; new; data set1; /* This tells SAS we&#39;re defining some variables */ x = 3; y = &#39;3.1415&#39;; z = x * y; /* this is arithmetic, so y will be converted */ x = &#39;3.14159&#39;; /* x previously had a number in it, */ /* so it will be converted to a number here */ zz = y&lt;=2; /* comparison operator: y will be converted */ put z; /* This prints the result to the log */ put x=; put zz=; run; Notice that in SAS, zz, which is the result of the logical statement y&lt;=2, is a numeric variable. The value 0 signifies that the comparison was false. SAS does not have a logical data type, it uses the numeric variable with 0:=FALSE, 1:=TRUE. NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 7 data set1; /* This tells SAS we&#39;re defining some variables */ 8 x = 3; 9 y = &#39;3.1415&#39;; 10 z = x * y; 11 /* this is arithmetic, so y will be converted */ 12 x = &#39;3.14159&#39;; 13 /* x previously had a number in it, */ 14 /* so it will be converted to a number here */ 15 zz = y&lt;=2; 16 /* comparison operator: y will be converted */ 17 18 put z; /* This prints the result to the log */ 19 put x=; 20 put zz=; 21 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 10:11 12:7 15:8 9.4245 x=3.14159 zz=0 NOTE: The data set WORK.SET1 has 1 observations and 4 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.01 seconds Try it out: Variable types In R Create variables string, integer, decimal, and logical, with types that match the relevant variable names. string &lt;- integer &lt;- decimal &lt;- logical &lt;- Can you get rid of the error that occurs when this chunk is run? logical + decimal integer + decimal string + integer What happens when you add string to string? logical to logical? In SAS Create variables string1 and string2 that each have text/character values. “Bob” and “Jane” might be good options. How does logical operation work with actual character values? What happens if you use string1 and add 3 to it? Answers string &lt;- &quot;hi, I&#39;m a string&quot; integer &lt;- 4L decimal &lt;- 5.412 logical &lt;- TRUE logical + decimal [1] 6.412 integer + decimal [1] 9.412 as.numeric(string) + integer Warning: NAs introduced by coercion [1] NA &quot;abcd&quot; + &quot;defg&quot; Error in &quot;abcd&quot; + &quot;defg&quot;: non-numeric argument to binary operator TRUE + TRUE [1] 2 In R, adding a string to a string creates an error (“non-numeric argument to binary operator”). Adding a logical to a logical, e.g. TRUE + TRUE, results in 2, which is a numeric value. proc printto log=&quot;saslog.log&quot; new; data set1; string1 = &#39;Bob&#39;; string2 = &#39;Jane&#39;; x = string1 &lt; string2; put x=; /* This prints the result to the log */ run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 8 data set1; 9 string1 = &#39;Bob&#39;; 10 string2 = &#39;Jane&#39;; 11 x = string1 &lt; string2; 12 put x=; /* This prints the result to the log */ 13 run; x=1 NOTE: The data set WORK.SET1 has 1 observations and 3 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 14 SAS will actually compare strings based on the first letter: Bob comes before Jane, so Bob &lt; Jane. proc printto log=&quot;saslog.log&quot; new; data set2; string1 = &#39;Bob&#39;; y = string1 + 3; put y=; run; NOTE: PROCEDURE PRINTTO used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 8 data set2; 9 string1 = &#39;Bob&#39;; 10 y = string1 + 3; 11 put y=; 12 run; NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column). 10:7 NOTE: Invalid numeric data, string1=&#39;Bob&#39; , at line 10 column 7. y=. string1=Bob y=. _ERROR_=1 _N_=1 NOTE: Missing values were generated as a result of performing an operation on missing values. Each place is given by: (Number of times) at (Line):(Column). 1 at 10:15 NOTE: The data set WORK.SET2 has 1 observations and 2 variables. NOTE: DATA statement used (Total process time): real time 0.00 seconds cpu time 0.00 seconds 2.1.2 Data structures Data structures are more complex arrangements of information than single variables. Of primary interest in statistical programming are the following types of structures:   Homogeneous Heterogeneous 1d vector list 2d matrix data frame (R) or data set (SAS) nd array (R) In the table above, homogeneous means that all entries in the structure must be of the same type. Heterogeneous means that the entries are allowed to be of different types. Figuring out what to call these types with two languages is hard - in SAS, an array is a group of columns of a data set, but in R, it’s a multi-dimensional matrix. In this section, we’ll discuss the generic concepts relevant to both languages. The differences between the two languages will be discussed as appropriate. 2.1.2.1 Homogeneous data structures (R and SAS) R does not have scalar types - even single-value variables are technically vectors of length 1. SAS does have scalar types. If we try to create a heterogeneous vector in R, using the concatenate function, c(), which combines scalar entries into a vector, what happens? c(1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) [1] &quot;1&quot; &quot;2&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; Because there were 3 character entries, the entire vector is now a character vector. Watch Out This behavior can cause some errors - for instance, R does not read in numeric data formatted with commas as numeric data. You may thus get the result x &lt;- c(356, 452, &quot;1,325&quot;) mean(x) Warning in mean.default(x): argument is not numeric or logical: returning NA [1] NA If you are reading in data from a file, this will cause some issues - the whole column of data will be formatted as characters. Keep an eye out for errors of this type. The 1, 2, and multi-dimensional homogeneous data types should be familiar from e.g. linear algebra and calculus. Single elements of a vector can be extracted using single square brackets, e.g. x[1] will get the first element of the vector x. In a matrix, elements are indexed as row, column, so to get the (2, 2) entry of a matrix x, you would use x[2,2]. This is extended for multi-dimensional arrays in R, with each dimension added, e.g. x[3,1,2] or x[4, 3, 2, 1]. To get a full row or column from a matrix (in both SAS and R) you would use x[1,] (get the first row) or x[,3] (get the 3rd column). To select multiple rows or columns from a matrix, you would use x[, c(1, 3)] in R or x[,{1 3}] in SAS - both options get the first and third column of the matrix, with all rows of data included. In both R and SAS, a:b where a and b are numbers will form a sequence from a to b by 1s. So 1:4 is 1, 2, 3, 4. This is often used to get a set of rows or columns: x[3:4, 1:2]. x &lt;- matrix(1:20, nrow = 5, byrow = T) # Create a matrix with values 1 to 20, 5 rows, and fill by row x [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 [4,] 13 14 15 16 [5,] 17 18 19 20 x[3:4, 1:2] [,1] [,2] [1,] 9 10 [2,] 13 14 # Gets a submatrix In SAS, the same basic code works (though matrix definition is a bit more manual). proc iml; /* Interactive Matrix Language */ x = {1 2 3 4 5, 6 7 8 9 10, 11 12 13 14 15, 16 17 18 19 20}; y = x[3:4, 1:2]; print x; /* Here, print is used instead of put */ print y; quit; /* exit proc IML */ x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 y 11 12 16 17 Both R and SAS are 1-indexed languages, so the elements of a list or vector are indexed as 1, 2, 3, 4, …1 The heterogeneous data types are not much harder to grasp. 2.1.2.2 Heterogeneous data structures Lists (R only) A list is, well, a list - a sequence of potentially different-typed values. Unlike when concatenating values, the list() command in R allows each value to keep its natural type. You can access elements of a list using [] (this will extract a subset of the list items) or [[]], which will extract a single item from the list. x &lt;- list(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3) x [[1]] [1] &quot;a&quot; [[2]] [1] &quot;b&quot; [[3]] [1] &quot;c&quot; [[4]] [1] 1 [[5]] [1] 2 [[6]] [1] 3 x[[3]] [1] &quot;c&quot; x[[4]] + x[[5]] [1] 3 x[1:2] # This will work [[1]] [1] &quot;a&quot; [[2]] [1] &quot;b&quot; x[[1:2]] # This won&#39;t work Error in x[[1:2]]: subscript out of bounds Some lists consist of named variables. These list components can be accessed either by index (as above) or by name, using the $ operator. Names which have spaces or special characters must be enclosed in backticks (next to the 1 on the keyboard). Named components can also be accessed using the [[ ]] operator. dog &lt;- list(name = &quot;Edison Vanderplas&quot;, age = 8, breed = &quot;Jack Russell Terrorist&quot;, `favorite toy` = &quot;a blue and orange stuffed duck. Or rawhide.&quot;, `link(video)` = &quot;https://youtu.be/zVeoQTOTIuQ&quot;) dog $name [1] &quot;Edison Vanderplas&quot; $age [1] 8 $breed [1] &quot;Jack Russell Terrorist&quot; $`favorite toy` [1] &quot;a blue and orange stuffed duck. Or rawhide.&quot; $`link(video)` [1] &quot;https://youtu.be/zVeoQTOTIuQ&quot; dog$name [1] &quot;Edison Vanderplas&quot; dog$breed [1] &quot;Jack Russell Terrorist&quot; dog$`favorite toy` [1] &quot;a blue and orange stuffed duck. Or rawhide.&quot; dog[[&quot;link(video)&quot;]] [1] &quot;https://youtu.be/zVeoQTOTIuQ&quot; Most complicated structures in R are lists. You should be able to access any of the pieces of a list using a combination of named references and indexing. You can get a sense of the structure of a list (or any other object) in R using the str() command. str(dog) List of 5 $ name : chr &quot;Edison Vanderplas&quot; $ age : num 8 $ breed : chr &quot;Jack Russell Terrorist&quot; $ favorite toy: chr &quot;a blue and orange stuffed duck. Or rawhide.&quot; $ link(video) : chr &quot;https://youtu.be/zVeoQTOTIuQ&quot; Lists can also contain other lists. When accessing a list-within-a-list, just add another index or name reference (see below). grocery_list &lt;- list( dairy = list(&quot;asiago&quot;, &quot;fontina&quot;, &quot;mozzarella&quot;, &quot;blue cheese&quot;), baking = list(&quot;flour&quot;, &quot;yeast&quot;, &quot;salt&quot;), canned_goods = list(&quot;pepperoni&quot;, &quot;pizza sauce&quot;, &quot;olives&quot;), meat = list(&quot;bacon&quot;, &quot;sausage&quot;, &quot;anchovies&quot;), veggies = list(&quot;bell pepper&quot;, &quot;onion&quot;, &quot;scallions&quot;, &quot;tomatoes&quot;, &quot;basil&quot;) ) ick &lt;- c(grocery_list[[4]][2:3], grocery_list$canned_goods[[3]]) ick [[1]] [1] &quot;sausage&quot; [[2]] [1] &quot;anchovies&quot; [[3]] [1] &quot;olives&quot; crust_ingredients &lt;- c(grocery_list$baking, &quot;water&quot;) crust_ingredients [[1]] [1] &quot;flour&quot; [[2]] [1] &quot;yeast&quot; [[3]] [1] &quot;salt&quot; [[4]] [1] &quot;water&quot; essential_toppings &lt;- c(grocery_list$dairy[3], grocery_list$canned_goods[2]) essential_toppings [[1]] [1] &quot;mozzarella&quot; [[2]] [1] &quot;pizza sauce&quot; yummy_toppings &lt;- c(grocery_list$dairy[c(1, 2, 4)], grocery_list$meat[1], grocery_list[[5]][c(3, 5)]) yummy_toppings [[1]] [1] &quot;asiago&quot; [[2]] [1] &quot;fontina&quot; [[3]] [1] &quot;blue cheese&quot; [[4]] [1] &quot;bacon&quot; [[5]] [1] &quot;scallions&quot; [[6]] [1] &quot;basil&quot; Try it out Using the list of pizza toppings above as a starting point, make your own list of pizza toppings organized by grocery store section (approximately). Create your own vectors of yummy, essential, and ick toppings. Data frames (R only) A data frame is a special type of list - one in which each element in the list is a vector of the same length. If you put these vectors side-by-side, you get a table of data that looks like a spreadsheet. When you examine the structure of a data frame, as shown below, you get each column shown in a row, with its type and the first few values in the column. The head() command shows the first 6 rows of a data frame (enough to see what’s there, not enough to overflow your screen). head(mtcars) ## A data frame included in base R mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 str(mtcars) &#39;data.frame&#39;: 32 obs. of 11 variables: $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... $ disp: num 160 160 108 258 360 ... $ hp : num 110 110 93 110 175 105 245 62 95 123 ... $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... $ wt : num 2.62 2.88 2.32 3.21 3.44 ... $ qsec: num 16.5 17 18.6 19.4 17 ... $ vs : num 0 0 1 1 0 1 0 1 1 1 ... $ am : num 1 1 1 0 0 0 0 0 0 0 ... $ gear: num 4 4 4 3 3 3 3 4 4 4 ... $ carb: num 4 4 1 1 2 1 4 2 2 4 ... You can change column values or add new columns easily using assignment. It’s also easy to access specific columns to perform summary operations. Often, it is useful to know the dimensions of a data frame. The number of rows can be obtained by using nrow(df) and similarly, the columns can be obtained using ncol(df). There is also an easy way to get a summary of each column in the data frame, using summary(). mtcars$gpm &lt;- 1/mtcars$mpg # gpm is sometimes used to assess efficiency summary(mtcars$gpm) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.02950 0.04386 0.05208 0.05423 0.06483 0.09615 summary(mtcars$mpg) Min. 1st Qu. Median Mean 3rd Qu. Max. 10.40 15.43 19.20 20.09 22.80 33.90 summary(mtcars) mpg cyl disp hp Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 Median :19.20 Median :6.000 Median :196.3 Median :123.0 Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 drat wt qsec vs Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 Median :3.695 Median :3.325 Median :17.71 Median :0.0000 Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 am gear carb gpm Min. :0.0000 Min. :3.000 Min. :1.000 Min. :0.02950 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 1st Qu.:0.04386 Median :0.0000 Median :4.000 Median :2.000 Median :0.05208 Mean :0.4062 Mean :3.688 Mean :2.812 Mean :0.05423 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 3rd Qu.:0.06483 Max. :1.0000 Max. :5.000 Max. :8.000 Max. :0.09615 Missing variables in an R data frame are indicated with NA. Try it out Using the list of pizza toppings above as a starting point, make your own list of pizza toppings organized by grocery store section (approximately). Create your own vectors of yummy, essential, and ick toppings. Data Sets (SAS) The SAS data set structure is similar to a R data frame. This is a schematic of a data set as taken from the SAS documentation The biggest difference is that in SAS, missing values are indicated with . SAS datasets also come with a description which is attached to the table. The descriptor portion of the data set records names of variables (and attributes), numbers of observations, and date/time stamps of creation and updates. 2.1.3 Control structures Non-exhaustive list of references: SAS Matrix reference: http://www.math.wpi.edu/saspdf/iml/chap4.pdf Data structures in Advanced R: http://adv-r.had.co.nz/Data-structures.html SAS Data set documentation 2.2 Overgrown Calculators R and SAS for basic numerical operations Matrix algebra 2.3 Basic Programming in R 2.4 Basic Programming in SAS Most languages are 0-indexed languages: C, C++, python, Java, javascript. Vectors in these languages are indexed as 0, 1, 2, 3. Other 1-indexed languages include FORTRAN, Matlab, Julia, Mathematica, and Lua, many of which were intended for mathematical processing or data analysis.↩ "],
["organization.html", "Module 3 Organization: Packages, Functions, Scripts, and Documents 3.1 Reproducibility 3.2 Markdown 3.3 Functions and Procs 3.4 Scripts 3.5 Packages 3.6 Comparisons - SAS and R", " Module 3 Organization: Packages, Functions, Scripts, and Documents 3.1 Reproducibility Why reproducibility is important in science and statistics Why reproducibility is convenient 3.2 Markdown 3.3 Functions and Procs 3.4 Scripts 3.5 Packages 3.6 Comparisons - SAS and R "],
["reading-data.html", "Module 4 External Data 4.1 External Data Formats 4.2 Importing Tabular Data into R 4.3 Importing Tabular Data into SAS 4.4 Exploratory Data Analysis", " Module 4 External Data 4.1 External Data Formats txt tsv csv fixed width excel/spreadsheet databases structured data (xml, json) 4.2 Importing Tabular Data into R 4.3 Importing Tabular Data into SAS 4.4 Exploratory Data Analysis tables summary statistics basic plots? unique values "],
["manipulating-data.html", "Module 5 Manipulating Data 5.1 Filter 5.2 Select 5.3 Group By 5.4 Summarize", " Module 5 Manipulating Data 5.1 Filter 5.2 Select 5.3 Group By 5.4 Summarize "],
["transforming-data.html", "Module 6 Transforming Data 6.1 Pivot operations 6.2 Separating one variable into many", " Module 6 Transforming Data 6.1 Pivot operations 6.1.1 Wider 6.1.2 Longer 6.2 Separating one variable into many "],
["data-analysis.html", "Module 7 Introduction to Data Analysis 7.1 Models in SAS 7.2 Models in R", " Module 7 Introduction to Data Analysis 7.1 Models in SAS 7.2 Models in R 7.2.1 Standard Models 7.2.2 Tidymodels "],
["data-vis-intro.html", "Module 8 Introduction to Data Visualization 8.1 Creating Charts in SAS 8.2 Creating Charts in R (base) 8.3 The Grammar of Graphics", " Module 8 Introduction to Data Visualization 8.1 Creating Charts in SAS 8.2 Creating Charts in R (base) 8.3 The Grammar of Graphics There are a lot of different types of charts. How do we classify them all? Introduce grammar of graphics as implemented in ggplot2 "],
["graphical-communication.html", "Module 9 Graphical Communication 9.1 something", " Module 9 Graphical Communication Good charts are important 9.1 something "],
["simulation.html", "Module 10 Simulation and Reproducibility 10.1 Pseudorandom Number Generation 10.2 Random Number Generation and Reproducibility", " Module 10 Simulation and Reproducibility 10.1 Pseudorandom Number Generation 10.2 Random Number Generation and Reproducibility 10.2.1 Seeds 10.2.2 Rmarkdown Reproducibility "],
["debugging.html", "Module 11 Principles of Debugging 11.1 Ideal Function Design 11.2 Debugging Tools in R 11.3 Debugging Tools in SAS 11.4 Minimal Working Examples 11.5 Researching Error Messages", " Module 11 Principles of Debugging 11.1 Ideal Function Design 11.2 Debugging Tools in R 11.3 Debugging Tools in SAS 11.4 Minimal Working Examples 11.5 Researching Error Messages "],
["presentations.html", "Module 12 Dynamic Presentations 12.1 Slides 12.2 Posters", " Module 12 Dynamic Presentations 12.1 Slides 12.1.1 Beamer (LaTeX) and knitr 12.1.2 xaringan 12.2 Posters 12.2.1 Beamer (LaTeX) and knitr 12.2.2 Pagedown "],
["references.html", "References", " References "]
]
