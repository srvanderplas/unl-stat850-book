[["debugging.html", "Module 8 Principles of Debugging Module Objectives 8.1 Step 1: Check your spelling. 8.2 Defensive Programming 8.3 General Debugging Strategies 8.4 Dividing Problems into Smaller Parts 8.5 Debugging Tools in R 8.6 Debugging Tools in SAS 8.7 Minimal Working (or Reproducible) Examples References", " Module 8 Principles of Debugging Module Objectives Create reproducible examples of problems Use built in debugging tools to trace errors Use online resources to research errors Note: The skills in this chapter take a lifetime to truly master. The real goal here is that you know how to ask for help appropriately (and in a way that people will respond positively to) and that you know how to do the research to get help yourself. The faces of debugging (by Allison Horst) 8.1 Step 1: Check your spelling. I’ll guess that 80% of my personal debugging comes down to spelling errors and misplaced punctuation. 8.2 Defensive Programming One of the best debugging strategies (that isn’t a debugging strategy at all, really) is to code defensively. By that, I mean, code in a way that you will make debugging things easier later. Modularize your code. Each function should do only one task, ideally in the least-complex way possible. Make your code readable. If you can read the code easily, you’ll be able to narrow down the location of the bug more quickly. Comment your code. This makes it more likely that you will be able to locate the spot where the bug is likely to have occurred, and will remind you how things are calculated. Remember, comments aren’t just for your collaborators or others who see the code. They’re for future you. Don’t duplicate code. If you have the same code (or essentially the same code) in two or three different places, put that code in a function and call the function instead. This will save you trouble when updating the code in the future, but also makes narrowing down the source of the bug less complex. Reduce the number of dependencies you have on outside software packages. Often bugs are introduced when a dependency is updated and the functionality changes slightly. The tidyverse is notorious for this. It’s ok to write code using lots of dependencies, but as you transition from “experimental” code to “production” code (you’re using the code without tinkering with it) you should work to reduce the dependencies, where possible. In addition, if you do need packages with lots of dependencies, try to make sure those packages are relatively popular, used by a lot of people, and currently maintained. (The tidyverse is a bit better from this perspective, because the constituent packages are some of the most installed R packages on CRAN.) Another way to handle dependency management is to use the renv package, which creates a local package library with the appropriate versions of your packages stored in the same directory as your project. This will at least help you minimize issues with code not working after unintentional package updates. Add safeguards against unexpected inputs. Check to make sure inputs to the function are valid. Check to make sure intermediate results are reasonable (e.g. you don’t compute the derivative of a function and come up with “a.”) Don’t reinvent the wheel. If you have working, tested code for a task, use that! If someone else has working code that’s used by the community, don’t write your own unless you have a very good reason. The implementation of lm has been better tested than your homegrown linear regression. (This is easier if you’re writing modular code to begin with) Collect your often-reused code in packages (R) or scripts (SAS) that you can easily load and make available to “future you” Wikipedia’s article on defensive programming is much more general than the applications to statistical programming, but may be worth scanning. 8.3 General Debugging Strategies Debugging: Being the detective in a crime movie where you are also the murderer. - some t-shirt I saw once While defensive programming is a nice idea, if you’re already at the point where you have an error you can’t diagnose, then… it doesn’t help that much. At that point, you’ll need some general debugging strategies to work with. The overall process is well described in Advanced R by H. Wickham1; I’ve copied it here because it’s such a succinct distillation of the process, but I’ve adapted some of the explanations to this class rather than the original context of package development. Realize that you have a bug Google! In R you can automate this with the errorist and searcher packages. In SAS, if the error message isn’t that clear you’ll find a SAS forum page where someone else has made the same mistake - I can almost guarantee it. Make the error repeatable: This makes it easier to figure out what the error is, faster to iterate, and easier to ask for help. Use binary search (remove 1/2 of the code, see if the error occurs, if not go to the other 1/2 of the code. Repeat until you’ve isolated the error.) Generate the error faster - use a minimal test dataset, if possible, so that you can ask for help easily and run code faster. This is worth the investment if you’ve been debugging the same error for a while. Note which inputs don’t generate the bug – this negative “data” is helpful when asking for help. Figure out where it is. Debuggers may help with this, but you can also use the scientific method to explore the code, or the tried-and-true method of using lots of print() statements. Fix it and test it. The goal with tests is to ensure that the same error doesn’t pop back up in a future version of your code. Generate an example that will test for the error, and add it to your documentation. If you’re developing a package, unit test suites offer a more formalized way to test errors and you can automate your testing so that every time your code is changed, tests are run and checked. There are several other general strategies for debugging: Retype (from scratch) your code This works well if it’s a short function or a couple of lines of code, but it’s less useful if you have a big script full of code to debug. However, it does sometimes fix really silly typos that are hard to spot, like having typed &lt;-- instead of &lt;- in R and then wondering why your answers are negative. Visualize your data as it moves through the program. This may be done using print() statements, or the debugger, or some other strategy depending on your application. Tracing statements. Again, this is part of print() debugging, but these messages indicate progress - “got into function x,” “returning from function y,” and so on. Rubber ducking. Have you ever tried to explain a problem you’re having to someone else, only to have a moment of insight and “oh, never mind?” Rubber ducking outsources the problem to a nonjudgmental entity, such as a rubber duck2. You simply explain, in terms simple enough for your rubber duck to understand, exactly what your code does, line by line, until you’ve found the problem. A more thorough explanation can be found at gitduck.com. Figure 8.1: You may find it helpful to procure a rubber duck expert for each language you work in. I use color-your-own rubber ducks to endow my ducks with certain language expertise. Other people use plain rubber ducks and give them capes. Do not be surprised if, in the process of debugging, you encounter new bugs. This is a problem that’s well-known enough that it has its own t-shirt, in addition to an xkcd comic. At some point, getting up and going for a walk may help. Redesigning your code to be more modular and more organized is also a good idea. 8.4 Dividing Problems into Smaller Parts “Divide each difficulty into as many parts as is feasible and necessary to resolve it.” -René Descartes, Discourse on Method In programming, as in life, big, general problems are very hard to solve effectively. Instead, the goal is to break a problem down into smaller pieces that may actually be solveable. We’ll start with a non-programming example: General problem statement : “I’m exhausted all the time” Ok, so this is a problem that many of us have from time to time (or all the time). If we get a little bit more specific at outlining the problem, though, we can sometimes get a bit more insight into how to solve it. Specific problem statement: “I wake up in the morning and I don’t have any energy to do anything. I want to go back to sleep, but I have too much to do to actually give in and sleep. I spend my days worrying about how I’m going to get all of the things on my to-do list done, and then I lie awake at night thinking about how many things there are to do tomorrow. I don’t have time for hobbies or exercise, so I drink a lot of coffee instead to make it through the day.” This is a much more specific list of issues, and some of these issues are actually things we can approach separately. Separating things into solvable problems: Moving through the list above, we can isolate a few issues. Some of these issues are undoubtedly related to each other, but we can approach them separately (for the most part). Poor quality sleep (tired in the morning, lying awake at night) Too many things to do (to-do list) Chemical solutions to low energy (coffee during the day) Anxiety about completing tasks (worrying, insomnia) Lack of personal time for hobbies or exercise Brainstorm Solutions: Get a check-up to rule out any other issues that could cause sleep quality degradation - depression, anxiety, sleep apnea, thyroid conditions, etc. Ask the doctor about taking melatonin supplements for a short time to ensure that sleep starts off well (note, don’t take medical advice from a stats textbook!) Reformat your to-do list: Set time limits for things on the to-do list Break the to-do list into smaller, manageable tasks that can be accomplished within a relatively short interval - such as an hour Sort the to-do list by priority and level of “fun” so that each day has a few hard tasks and a couple of easy/fun tasks. Do the hard tasks first, and use the easy/fun tasks as a reward. Set a time limit for caffeine (e.g. no coffee after noon) so that caffeine doesn’t contribute to poor quality sleep Address anxiety with medication (from 1), scheduled time for mindfulness meditation, and/or self-care activities Scheduling time for exercise/hobbies scheduling exercise in the morning to take advantage of the endorphins generated by working out scheduling hobbies in the evening to reward yourself for a day’s work and wind down work well before bedtime Approach each sub-problem separately When the sub-problem has a viable solution, move on to the next sub-problem. Don’t try to tackle everything at once. 8.5 Debugging Tools in R Now that we’ve discussed general strategies for debugging that will work in any language, lets get down to the dirty details of debugging in R. 8.5.1 Low tech debugging with print() and other tools Sometimes called “tracing” techniques, the most common, universal, and low tech strategy for debugging involves scattering messages throughout your code. When the code is executed, you get a window into what the variables look like during execution. Simple example Imagine we start with this: a &lt;- function(x) { b &lt;- function(y) { c &lt;- function(z) { z + y } c(3) } x + b(4) } a(5) [1] 12 and the goal is to understand what’s happening in the code. We might add some lines: a &lt;- function(x) { print(paste(&quot;Entering a(). x = &quot;, x)) b &lt;- function(y) { print(paste(&quot;Entering b(). x = &quot;, x, &quot;y = &quot;, y)) c &lt;- function(z) { print(paste(&quot;Entering c(). x = &quot;, x, &quot;y = &quot;, y, &quot;z = &quot;, z)) cres &lt;- z + y print(paste(&quot;Returning&quot;, cres, &quot;from c()&quot;)) cres } bres &lt;- c(3) print(paste(&quot;Returning&quot;, bres, &quot;from b()&quot;)) bres } ares &lt;- x + b(4) print(paste(&quot;Returning&quot;,ares, &quot;from a()&quot;)) ares } a(5) [1] &quot;Entering a(). x = 5&quot; [1] &quot;Entering b(). x = 5 y = 4&quot; [1] &quot;Entering c(). x = 5 y = 4 z = 3&quot; [1] &quot;Returning 7 from c()&quot; [1] &quot;Returning 7 from b()&quot; [1] &quot;Returning 12 from a()&quot; [1] 12 For more complex data structures, it can be useful to add str(), head(), or summary() functions. Real world example I was recently writing a webscraper to get election polling data from the RealClearPolitics site as part of the electionViz package. I wrote the function search_for_parent() to get the parent HTML tag which matched the “tag” argument, that had the “node” argument as a descendant. I was assuming that the order of the parents would be “html,” “body,” “div,” “table,” “tbody,” “tr” - descending from outer to inner (if you know anything about HTML/XML structure). library(xml2) # read html search_for_parent &lt;- function(node, tag) { # Get all of the parent nodes parents &lt;- xml2::xml_parents(node) # Get the tags of every parent node tags &lt;- purrr::map_chr(parents, rvest::html_name) print(tags) # Find matching taggs matches &lt;- which(tags == tag) print(matches) # Take the minimum matching tag min_match &lt;- min(matches) if (length(matches) == 1) return(parents[min_match]) else return(NULL) } page &lt;- read_html(&quot;data/realclearpolitics_frag.html&quot;) node &lt;- xml_find_all(page, &quot;//td[@class=&#39;lp-results&#39;]&quot;) # find all poll results in any table search_for_parent(node[1], &quot;table&quot;) # find the table that contains it [1] &quot;tr&quot; &quot;tbody&quot; &quot;table&quot; &quot;div&quot; &quot;body&quot; &quot;html&quot; [1] 3 {xml_nodeset (1)} [1] &lt;table cellpadding=&quot;2&quot; cellspacing=&quot;0&quot; class=&quot;sortable&quot;&gt;\\n&lt;thead&gt;&lt;tr clas ... By printing out all of the tags that contain node, I could see the order – inner to outer. I asked the function to return the location of the first table node, so the index (2nd value printed out) should match table in the character vector that was printed out first. I could then see that the HTML node that is returned is in fact the table node. Try it out Not all bugs result in error messages, unfortunately, which makes higher-level techniques like traceback() less useful. The low-tech debugging tools, however, still work wonderfully. library(ggplot2) library(dplyr) library(magrittr) library(maps) library(ggthemes) worldmap &lt;- map_data(&quot;world&quot;) # Load the data data(storms, package = &quot;dplyr&quot;) The code below is supposed to print out a map of the tracks of all hurricanes of a specific category, 1 to 5, in 2013. Use print statements to figure out what’s wrong with my code. # Make base map to be used for each iteration basemap &lt;- ggplot() + # Country shapes geom_polygon(aes(x = long, y = lat, group = group), data = worldmap, fill = &quot;white&quot;, color = &quot;black&quot;) + # Zoom in coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + # Don&#39;t need scales b/c maps provide their own geographic context... theme_map() for (i in 1:5) { # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(status == i) # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) print(plot) } Solution First, lets split the setup from the loop. # Make base map to be used for each iteration basemap &lt;- ggplot() + # Country shapes geom_polygon(aes(x = long, y = lat, group = group), data = worldmap, fill = &quot;white&quot;, color = &quot;black&quot;) + # Zoom in coord_quickmap(xlim = c(-100, -10), ylim = c(10, 50)) + # Don&#39;t need scales b/c maps provide their own geographic context... theme_map() print(basemap) # make sure the basemap is fine # Load the data data(storms, package = &quot;dplyr&quot;) str(storms) # make sure the data exists and is formatted as expected tibble[,13] [10,010 × 13] (S3: tbl_df/tbl/data.frame) $ name : chr [1:10010] &quot;Amy&quot; &quot;Amy&quot; &quot;Amy&quot; &quot;Amy&quot; ... $ year : num [1:10010] 1975 1975 1975 1975 1975 ... $ month : num [1:10010] 6 6 6 6 6 6 6 6 6 6 ... $ day : int [1:10010] 27 27 27 27 28 28 28 28 29 29 ... $ hour : num [1:10010] 0 6 12 18 0 6 12 18 0 6 ... $ lat : num [1:10010] 27.5 28.5 29.5 30.5 31.5 32.4 33.3 34 34.4 34 ... $ long : num [1:10010] -79 -79 -79 -79 -78.8 -78.7 -78 -77 -75.8 -74.8 ... $ status : chr [1:10010] &quot;tropical depression&quot; &quot;tropical depression&quot; &quot;tropical depression&quot; &quot;tropical depression&quot; ... $ category : Ord.factor w/ 7 levels &quot;-1&quot;&lt;&quot;0&quot;&lt;&quot;1&quot;&lt;&quot;2&quot;&lt;..: 1 1 1 1 1 1 1 1 2 2 ... $ wind : int [1:10010] 25 25 25 25 25 25 25 30 35 40 ... $ pressure : int [1:10010] 1013 1013 1013 1013 1012 1012 1011 1006 1004 1002 ... $ ts_diameter: num [1:10010] NA NA NA NA NA NA NA NA NA NA ... $ hu_diameter: num [1:10010] NA NA NA NA NA NA NA NA NA NA ... Everything looks ok in the setup chunk… for (i in 1:5) { print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(status == i) print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # str(subdata) works too, but produces more clutter. I started # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) # print(plot) # Don&#39;t print plots - clutters up output at the moment } [1] &quot;Category 1 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 2 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 3 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 4 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 5 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; Ok, so from this we can see that something is going wrong with our filter statement - we have no rows of data. head(storms) # A tibble: 6 x 13 name year month day hour lat long status category wind pressure &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;ord&gt; &lt;int&gt; &lt;int&gt; 1 Amy 1975 6 27 0 27.5 -79 tropical de… -1 25 1013 2 Amy 1975 6 27 6 28.5 -79 tropical de… -1 25 1013 3 Amy 1975 6 27 12 29.5 -79 tropical de… -1 25 1013 4 Amy 1975 6 27 18 30.5 -79 tropical de… -1 25 1013 5 Amy 1975 6 28 0 31.5 -78.8 tropical de… -1 25 1012 6 Amy 1975 6 28 6 32.4 -78.7 tropical de… -1 25 1012 # … with 2 more variables: ts_diameter &lt;dbl&gt;, hu_diameter &lt;dbl&gt; Whoops. I meant “category” when I typed “status.” for (i in 1:5) { print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(category == i) print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # str(subdata) works too, but produces more clutter. I started # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) # print(plot) # Don&#39;t print plots - clutters up output at the moment } [1] &quot;Category 1 storms&quot; [1] &quot;subdata dims: nrow 13 ncol 13&quot; [1] &quot;Category 2 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 3 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 4 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; [1] &quot;Category 5 storms&quot; [1] &quot;subdata dims: nrow 0 ncol 13&quot; Ok, that’s something, at least. We now have some data for category 1 storms… filter(storms, year == 2013) %&gt;% # Get max category for each named storm group_by(name) %&gt;% filter(category == max(category)) %&gt;% ungroup() %&gt;% # See what categories exist select(name, category) %&gt;% unique() # A tibble: 14 x 2 name category &lt;chr&gt; &lt;ord&gt; 1 Andrea 0 2 Barry 0 3 Chantal 0 4 Dorian 0 5 Erin 0 6 Fernand 0 7 Gabrielle 0 8 Eight -1 9 Humberto 1 10 Ingrid 1 11 Jerry 0 12 Karen 0 13 Lorenzo 0 14 Melissa 0 It looks like 2013 was just an incredibly quiet year for tropical activity. 2004, however, was not. So let’s just make sure our code works by checking out 2004. for (i in 1:5) { print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2004) %&gt;% filter(category == i) print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # str(subdata) works too, but produces more clutter. I started # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) print(plot) # Don&#39;t print plots - clutters up output at the moment } [1] &quot;Category 1 storms&quot; [1] &quot;subdata dims: nrow 45 ncol 13&quot; [1] &quot;Category 2 storms&quot; [1] &quot;subdata dims: nrow 39 ncol 13&quot; [1] &quot;Category 3 storms&quot; [1] &quot;subdata dims: nrow 29 ncol 13&quot; [1] &quot;Category 4 storms&quot; [1] &quot;subdata dims: nrow 32 ncol 13&quot; [1] &quot;Category 5 storms&quot; [1] &quot;subdata dims: nrow 12 ncol 13&quot; If we want to only print informative plots, we could add an if statement. Now that the code works, we can also comment out our print() statements (we could delete them, too, depending on whether we anticipate future problems with the code). for (i in 1:5) { # print(paste0(&quot;Category &quot;, i, &quot; storms&quot;)) # Subset the data subdata &lt;- storms %&gt;% filter(year == 2013) %&gt;% filter(category == i) # print(paste0(&quot;subdata dims: nrow &quot;, nrow(subdata), &quot; ncol &quot;, ncol(subdata))) # # str(subdata) works too, but produces more clutter. I started # # with str() and moved to dim() when I saw the problem # Plot the data - path + points to show the observations plot &lt;- basemap + geom_path(aes(x = long, y = lat, color = name), data = subdata) + geom_point(aes(x = long, y = lat, color = name), data = subdata) + ggtitle(paste0(&quot;Category &quot;, i, &quot; storms in 2013&quot;)) if (nrow(subdata) &gt; 0) print(plot) } 8.5.2 After an error has occurred - traceback() traceback() can help you narrow down where an error occurs by taking you through the series of function calls that led up to the error. This can help, but it can also be pretty arcane. traceback() example a &lt;- function(x) { b &lt;- function(y) { c &lt;- function(z) { stop(&#39;there was a problem&#39;) # This generates an error } c() } b() } a() Error in c(): there was a problem For more information, you could run traceback traceback() Which will provide the following output: 4: stop(&quot;there was a problem&quot;) at #4 3: c() at #6 2: b() at #8 1: a() Reading through this, we see that a() was called, b() was called, c() was called, and then there was an error. It’s even kind enough to tell us that the error occurred at line 4 of the code. If you are running this code interactively in RStudio, it’s even easier to run traceback() by clicking on the “Show Traceback” option that appears when there is an error. Figure 8.2: Both Show Traceback and Rerun with Debug are useful tools If you are using source() to run the code in Rstudio, it will even provide a link to the file and line location of the error. 8.5.3 browser() - debugging your own code, interactively The browser() function is useful for debugging your own code. If you’re writing a function and something isn’t working quite right, you can insert a call to browser() in that function, and examine what’s going on. Example of using browser() Suppose that I want to write a function that will plot an xkcd comic in R. I start with library(png) library(xml2) # get the most current xkcd get_xkcd &lt;- function(id = NULL) { url &lt;- &quot;http://xkcd.com&quot; page &lt;- read_html(url) # Find the comic image &lt;- xml_find_first(page, &quot;//div[@id=&#39;comic&#39;]/img&quot;) %&gt;% # pull the address out of the tag xml_attr(&quot;src&quot;) readPNG(source = image) } Watch this live-coding video to see how I use browser() to figure out what’s going on in the function and how to fix it. Vidgrid link. Alternate YouTube Link Here’s the final function library(png) library(xml2) # get the most current xkcd get_xkcd &lt;- function(id = NULL) { url &lt;- &quot;http://xkcd.com&quot; page &lt;- read_html(url) # Find the comic image &lt;- xml_find_first(page, &quot;//div[@id=&#39;comic&#39;]/img&quot;) %&gt;% # pull the address out of the tag xml_attr(&quot;src&quot;) # Fix image address so that we can access the image image &lt;- substr(image, 3, nchar(image)) # Download the file to a temp file and read from there file_location &lt;- tempfile(fileext = &quot;.png&quot;) download.file(image, destfile = file_location, quiet = T) readPNG(source = file_location) } get_xkcd() %&gt;% as.raster() %&gt;% plot() Try it out Each xkcd has a corresponding ID number (ordered sequentially from 1 to 2328 at the time this was written). Modify the XKCD function above to make use of the id parameter, so that you can pass in an ID number and get the relevant comic. Use browser() to help you figure out what logic you need to add. You should not need to change the web scraping code - the only change should be to the URL. What things might you add to make this function “defensive programming” compatible? Solution # get the most current xkcd or the specified number get_xkcd &lt;- function(id = NULL) { if (is.null(id)) { # Have to get the location of the image ourselves url &lt;- &quot;http://xkcd.com&quot; } else if (is.numeric(id)) { url &lt;- paste0(&quot;http://xkcd.com/&quot;, id, &quot;/&quot;) } else { # only allow numeric or null input stop(&quot;To get current xkcd, pass in NULL, otherwise, pass in a valid comic number&quot;) } page &lt;- read_html(url) # Find the comic image &lt;- xml_find_first(page, &quot;//div[@id=&#39;comic&#39;]/img&quot;) %&gt;% # pull the address out of the tag xml_attr(&quot;src&quot;) # Fix image address so that we can access the image image &lt;- substr(image, 3, nchar(image)) # cut the first 2 characters off # make temp file location &lt;- tempfile(fileext = &quot;png&quot;) download.file(image, destfile = location, quiet = T) # This checks to make sure we saved the file correctly if (file.exists(location)) { readPNG(source = location) } else { # Give a good informative error message stop(paste(&quot;Something went wrong saving the image at &quot;, image, &quot; to &quot;, location)) } } get_xkcd(2259) %&gt;% as.raster() %&gt;% plot() 8.5.4 debug() - the general debugging workhorse In the traceback() Rstudio output, the other option is “rerun with debug.” In short, debug mode opens up a new interactive session inside the function evaluation environment. This lets you observe what’s going on in the function, pinpoint the error (and what causes it), and potentially fix the error, all in one neat workflow. debug() is most useful when you’re working with code that you didn’t write yourself. So, if you can’t change the code in the function causing the error, debug() is the way to go. Otherwise, using browser() is generally easier. Essentially, debug() places a browser() statement at the first line of a function, but without having to actually alter the function’s source code. Example of using debug data(iris) tmp &lt;- lm(Species ~ ., data = iris) Warning in model.response(mf, &quot;numeric&quot;): using type = &quot;numeric&quot; with a factor response will be ignored Warning in Ops.factor(y, z$residuals): &#39;-&#39; not meaningful for factors summary(tmp) Warning in Ops.factor(r, 2): &#39;^&#39; not meaningful for factors Call: lm(formula = Species ~ ., data = iris) Residuals: Error in quantile.default(resid): (unordered) factors are not allowed We get this weird warning, and then an error about factors when we use summary() to look at the coefficients. debug(lm) # turn debugging on tmp &lt;- lm(Species ~ ., data = iris) summary(tmp) undebug(lm) # turn debugging off) The first thing I see when I run lm after turning on debug (screenshot) The variables passed into the lm function are available as named and used in the function. In addition, we have some handy buttons in the console window that will let us ‘drive’ through the function After pressing “next” a few times, you can see that I’ve stepped through the first few lines of the lm function. We can see that once we’re at line 21, we get a warning about using type with a factor response, and that the warning occurs during a call to the model.response function. So, we’ve narrowed our problem down - we passed in a numeric variable as the response (y) variable, but it’s a factor, so our results aren’t going to mean much. We were using the function wrong. We probably could have gotten there from reading the error message carefully, but this has allowed us to figure out exactly what happened, where it happened, and why it happened. I can hit “Stop” or type “Q” to exit the debug environment. But, until I run undebug(lm), every call to lm will take me into the debug window. undebug(f) will remove the debug flag on the function f. debugonce(f) will only debug f the first time it is run. Try it out larger(x, y) is supposed to return the elementwise maximum of two vectors. larger &lt;- function(x, y) { y.is.bigger &lt;- y &gt; x x[y.is.bigger] &lt;- y[y.is.bigger] x } larger(c(1, 5, 10), c(2, 4, 11)) [1] 2 5 11 larger(c(1, 5, 10), 6) [1] 6 NA 10 Why is there an NA in the second example? It should be a 6. Figure out why this happens, then try to fix it. Solution I’ll replicate “debug” in non-interactive mode by setting up an environment where x and y are defined x &lt;- c(1, 5, 10) y &lt;- 6 # Inside of larger() with x = c(1, 5, 10), y = 6 (y.is.bigger &lt;- y &gt; x ) # putting something in () prints it out [1] TRUE TRUE FALSE y[y.is.bigger] # This isn&#39;t quite what we were going for, but it&#39;s what&#39;s causing the issue [1] 6 NA x[y.is.bigger] # What gets replaced [1] 1 5 # Better option larger &lt;- function(x, y) { y.is.bigger &lt;- y &gt; x ifelse(y.is.bigger, y, x) } 8.6 Debugging Tools in SAS In SAS, there are two stages that occur after you submit lines to the console. The Compilation Phase: code is parsed. In this step, SAS will catch the logic errors, misspellings, missing key words, etc. The Execution Phase: program is run. In this step, SAS will catch any wrong assignments, loop issues, etc. Sas recognizes four types of errors: Syntax errors - violations of the language structure Semantic errors - structure of the statement is incorrect, but the syntax is correct. e.g. trying to reference an index that doesn’t exist. Execution-time errors - errors that occur when the compiled function is run on data values – e.g. division by zero Data errors - errors that occur when statements are correct but data is invalid (taking the log of a negative number, etc.) SAS is built around enterprise users, as opposed to R’s open-source philosophy. SAS code also is more formulaic than R code, which means it is usually easier to figure out what is going wrong with the code. As a result, you may find that errors in your SAS code are much easier to diagnose than errors in your R code. Generally, it will tell you exactly where you are missing a semicolon, or exactly what word it thinks you’ve misspelled (and usually, it tries to correct that for you, but it doesn’t always succeed). In my experience with SAS (which is very limited and mostly contained in this book), SAS error messages are much easier to google and find solutions, right up until you’re working in Linux or some other not-well-supported system and the error is related to how the underlying OS handles some task. As a downside, though, trying to do a task SAS doesn’t think you need to do can be much more difficult than necessary. See the references section for a couple of good guides to SAS error statements and warnings. These guides are likely sufficient for most of your SAS debugging needs. There are certainly other errors which can occur in SAS – logic errors are not something SAS can protect you from . These errors can have dramatic consequences, as demonstrated in this twitter thread about a JAMA retraction due to a coding error. To debug these types of errors, you can use the same print() techniques demonstrated in R. For these types of errors, there’s nothing special about what language you’re using (outside of the usual quirks of every language) - the error is in the logic, not the encoding of that logic. 8.7 Minimal Working (or Reproducible) Examples If all else has failed, and you can’t figure out what is causing your error, it’s probably time to ask for help. If you have a friend or buddy that knows the language you’re working in, by all means ask for help sooner - use them as a rubber duck if you have to. But when you ask for help online, often you’re asking people who are much more knowledgeable about the topic - members of R core and SAS browse stackoverflow and may drop in and help you out. Under those circumstances, it’s better to make the task of helping you as easy as possible because it shows respect for their time. The same thing goes for your supervisors and professors. The reprex R package will help you make a reproducible example (drawing by Allison Horst) So, with that said, there are numerous resources for writing what’s called a “minimal working example,” “reproducible example” (commonly abbreviated reprex), or MCVE (minimal complete verifiable example). Much of this is lifted directly from the StackOverflow post describing a minimal reproducible example. The goal is to reproduce the error message with information that is minimal - as little code as possible to still reproduce the problem complete - everything necessary to reproduce the issue is contained in the description/question reproducible - test the code you provide to reproduce the problem. You should format your question to make it as easy as possible to help you. Make it so that code can be copied from your post directly and pasted into a terminal. Describe what you see and what you’d hope to see if the code were working. Other resources: - reprex package: Do’s and Don’ts - How to use the reprex package - vignette with videos from Jenny Bryan - reprex magic - Vignette adapted from a blog post by Nick Tierney 8.7.1 Example: MWEs You haven’t gotten to module 8 yet, but at one point I had issues with SAS graphs rendering in black and white most of the time. I started debugging the issue with the following code chunk: {r sas-cat-aes-map-07, engine=&quot;sashtml&quot;, engine.path=&quot;sas&quot;, fig.path = &quot;image/&quot;} libname classdat &quot;sas/&quot;; PROC SGPLOT data=classdat.fbiwide; SCATTER x = Population y = Assault / markerattrs=(size=8pt symbol=circlefilled) group = Abb; /* maps to point color by default */ RUN; QUIT; PROC SGPLOT data=classdat.fbiwide NOAUTOLEGEND; /* dont generate a legend */ SCATTER x = Population y = Assault / markercharattrs=(size=8) markerchar = Abb /* specify marker character variable */ group = Abb ; RUN; QUIT; (I moved the chunk header to the next line so that you can see the whole chunk) After running the code separately in SAS and getting a figure that looked like what I’d expected, I set out to construct a reproducible example so that I could post to the SASmarkdown github issues page and ask for help. The first thing I did was strip out all of the extra stuff that didn’t need to be in the chunk - this chunk generates 2 pictures; I only need one. This chunk requires the fbiwide data; I replaced it with a dataset in the sashelp library. When I was done, the chunk looked like this: PROC SGPLOT data=sashelp.snacks; SCATTER x = date y = QtySold / markerattrs=(size=8pt symbol=circlefilled) group = product; /* maps to point color by default */ RUN; QUIT; Then, I started constructing my reproducible example. I ran ?sas_enginesetup to get to a SASmarkdown help page, because I remembered it had a nice way to generate and run markdown files from R directly (without saving the Rmd file). I copied the example from that page: indoc &lt;- &#39; --- title: &quot;Basic SASmarkdown Doc&quot; author: &quot;Doug Hemken&quot; output: html_document --- # I&#39;ve deleted the intermediate chunks because they screw # everything up when I print this chunk out &#39; knitr::knit(text=indoc, output=&quot;test.md&quot;) rmarkdown::render(&quot;test.md&quot;) Then, I created several chunks which would do the following: 1. Write the minimal example SAS code above to a file 2. Call that file in a SASmarkdown chunk using the %include macro, which dumps the listed file into the SAS program 3. Call the file using SAS batch mode Finally, I included the image generated from the batch mode call manually. You can see the resulting code here. I pasted my example into the issues page, and then included some additional information: A screenshot of the rendered page The image files themselves A description of what happened My suspicions (some obvious option I’m missing?) An additional line of R code that would delete any files created if someone ran my example. Because file clutter sucks. This process took me about 45 minutes, but that was still much shorter than the time I’d spent rerunning code trying to get it to work with no success. In less than 24 hours, the package maintainer responded with a (admittedly terse) explanation of what he thought caused the problem. I had to do some additional research to figure out what that meant, but once I had my reproducible example working in color, I posted that code (so that anyone else with the same problem would know what to do). Then, I had to tinker with the book a bit to figure out if there were easier ways to get the same result. Hopefully, at this point, all of the SAS graphs are now in full color, as modern graphics intended. 8.7.2 Try It Out Use this list of StackOverflow posts to try out your new debugging techniques. Can you figure out what’s wrong? What information would you need from the poster in order to come up with a solution? References The 500 mile email problem - a true story Stalking the elusive computer bug - the etymology and historical use of the term “debugging,” from Thomas Edison to Grace Hopper. Debugging (lecture materials from software construction class at MIT) - written with java, but mostly comprehensible for any language. Debugging with RStudio An Introduction to the Interactive Debugging Tools in R Stackoverflow: General Suggestions for Debugging in R WTF R - What They Forgot to Teach You about R Debugging chapter Debugging 101 in SAS Debugging SAS Programs - Ch. 1: The Basics of Debugging A webinar by Jenny Bryan/RStudio on Reproducible Examples the 0th step is from the 1st edition, the remaining steps are from the 2nd.↩︎ Some people use cats, but I find that they don’t meet the nonjudgmental criteria. Of course, they’re equally judgmental whether your code works or not, so maybe that works if you’re a cat person, which I am not. Dogs, in my experience, can work, but often will try to comfort you when they realize you’re upset, which both helps and lessens your motivation to fix the problem. A rubber duck is the perfect dispassionate listener.↩︎ "]]
