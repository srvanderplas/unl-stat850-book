# Manipulating Data {#manipulating-data}


## Module Objectives {-}

- Filter, subset, and clean data to prepare a dataset for analysis
- Describe and document operations performed on a data set transparently, and implement the operations using reproducible steps.

In this section, we're going to start out by learning how to work with data. Generally speaking, data doesn't come in a form suitable for analysis - you have to clean it up, create the variables you care about, get rid of those you don't care about, and so on. 

In R, we'll be using the `tidyverse` for this. It's a meta-package (a package that just loads other packages) that [collects packages designed with the same philosophy^[The philosophy includes a preference for pipes, but this preference stems from the belief that code should be readable in the same way that text is readable.] and interface (basically, the commands will use predictable argument names and structure). You've already been introduced to the tidyverse - specifically, `readr`. 

In SAS, there is no tidyverse, but there is a relatively consistent structure for how to accomplish each task. Most data cleaning in SAS is accomplished in data steps. In the interests of not confusing terms too much between languages, I'm going to use the tidyverse "verbs" to describe operations in both SAS and R. 

`dplyr` (one of the packages in the tidyverse) creates a "grammar of data manipulation" to make it easier to describe different operations. I find the `dplyr` grammar to be extremely useful when talking about data operations, so I'm going to attempt to show you how to do the same operations in R with dplyr, and in SAS (without the underlying framework). Each verb describes a common task when doing both exploratory data analysis and more formal statistical modeling. In all tidyverse functions, data comes first -- literally, as it's the first argument to any function. In addition, you don't use df$variable to access a variable - you refer to the variable by its name alone. This makes the syntax much cleaner and easier to read, which is another principle of the tidy philosophy. 

<div class="learn-more">
[There is an excellent dplyr cheatsheet available from RStudio](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf). You may want to print it out to have a copy to reference as you work through this chapter. </div>

## Tidy Data

There are infinitely many ways to configure "messy" data, but data that is "tidy" has 3 attributes:

1. Each variable has its own column
2. Each observation has its own row
3. Each value has its own cell

We'll get more into how to work with different "messy" data configurations in the next module, but it's worth keeping rules 1 and 3 in mind while working through this module. 



## Filter: Pick cases (rows) based on their values

Filter allows us to work with a subset of a larger data frame, keeping only the rows we're interested in. We provide one or more logical conditions, and only those rows which meet the logical conditions are returned from `filter()`. Note that unless we store the result from `filter()` in the original object, we don't change the original. 

Let's explore how it works, using the `starwars` dataset, which contains a comprehensive list of the characters in the Star Wars movies. 
<details><summary>Data set up</summary>

This data set is included in the `dplyr` package, so we load that package and then use the `data()` function to load dataset into memory. The loading isn't complete until we actually use the dataset though... so let's print the first few rows. 

```{r}
library(dplyr)
data(starwars)
starwars
```

In the interests of demonstrating the process on the same data, I've exported the starwars data to a CSV file using the `readr` package.

I had to remove the list-columns (films, vehicles, starships) because that format isn't supported by SAS. You can access the csv data [here](data/starwars.csv). Note that I exported the data using '.' as the NA/missing character so that it will be easy to read into SAS.

```{r starwars-data-export, eval = F}
readr::write_csv(starwars[,1:11], "data/starwars.csv", na = '.')
```

Let's set that data up first: 
```{sashtml sas-setup-data}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";
filename swdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/data/starwars.csv";

PROC IMPORT DATAFILE = swdat OUT = classdat.starwars 
    DBMS = CSV 
    REPLACE; 
    GETNAMES = YES;
RUN;

PROC PRINT DATA=classdat.starwars (obs=10);
RUN;
```

If you want to directly load the SAS datafile, you can find it [here](sas/starwars.sas7bdat)
</details>

Once the data is set up, using `filter` is actually very simple.

<details><summary>Demonstration of `filter()` in R</summary>
```{r r-filter-data}
# Get only the people
filter(starwars, species == "Human")

# Get only the people who come from Tatooine
filter(starwars, species == "Human", homeworld == "Tatooine")
```
</details>

In SAS, as in SQL, the `filter()` operation is accomplished using a `where` clause. Multiple clauses can be connected using `and`, and compound statements can be grouped with parentheses. 
<details><summary>Demonstration of `where` in SAS</summary>
Rather than output the whole data table (which would take up a lot of space), I've linked the log file from each chunk below the chunk. 

```{sashtml sas-filter1}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

/* SAS limits dataset names to 8 characters, which is super annoying. */
/* Sorry the names aren't descriptive... */

proc printto log="other/05-filter-1.log" new; /* shows output log in bookdown */
DATA tmp1; /* this is the out dataset */
/* By not having a library attached, SAS places this in WORK */
/* It's a temporary dataset */
  set classdat.starwars;
  where (species = 'Human');
  run;
```
See the log file [here](other/05-filter-1.log)

```{sashtml sas-filter2}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

proc printto log="other/05-filter-2.log" new; /* shows output log in bookdown */
DATA tmp2; 
  set classdat.starwars;
  where (species = 'Human') and (homeworld = 'Tatooine');
  run;
```
See the log file [here](other/05-filter-2.log)
</details>

#### Try it out {- .tryitout}

Using the pokemon data, can you create a new data set or data frame (SAS and R, respectively) that has only water type pokemon? Can you write a filter statement that looks for any pokemon which has water type for either type1 or type2?

<details><summary>R</summary>
```{r, message = F}
poke <- read_csv("data/pokemon_ascii.csv")

filter(poke, type_1 == "Water")

filter(poke, type_1 == "Water" | type_2 == "Water")
# The conditions have to be separated by |, which means "or"
```
</details>

<details><summary>SAS</summary>
```{sashtml}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

DATA water1;
SET classdat.poke;
WHERE type_1 = "Water";
RUN;

DATA water2;
SET classdat.poke;
WHERE (type_1 = "Water" OR type_2 = "Water");
RUN;
```

In the interests of only showing the parts of the log that are useful, I've just pasted them into this chunk. Not reproducible, but faster to read.

````
NOTE: There were 134 observations read from the data set CLASSDAT.POKE.
      WHERE type_1='Water';
NOTE: The data set WORK.WATER1 has 134 observations and 49 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      
NOTE: There were 153 observations read from the data set CLASSDAT.POKE.
      WHERE (type_1='Water') or (type_2='Water');
NOTE: The data set WORK.WATER2 has 153 observations and 49 variables.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
````
</details>


### Common filter operations

In `dplyr`, there are a few helper functions which may be useful when constructing filter statements. 

<details><summary>`row_number()` - this is only used inside of another dplyr function (e.g. filter). You might want to keep only even rows, or only the first 10 rows in a table.  </summary>
```{r}
filter(poke, (row_number() %% 2 == 0))
# There are several pokemon who have multiple entries in the table, 
# so the pokedex_number doesn't line up with the row number.
```
</details>

<details><summary>`slice_max()` - this will keep the top values of a specified variable.</summary>

It's like a filter statement, but it's a shortcut built to handle a common task. You could write a filter statement that would do this, but it would take a lot more code.
```{r}
slice_max(poke, order_by = total_points, n = 5) %>%
  arrange(desc(total_points)) # Sort decreasing
```
By default, `slice_max()` returns values tied with the nth value as well, which is why our result has 6 rows. 
```{r}
slice_max(poke, order_by = total_points, n = 5, with_ties = F) %>%
  arrange(desc(total_points)) # Sort decreasing
```
</details>


In SAS, these same tasks require a bit more code.

<details><summary>Keeping only certain rows in SAS</summary>

In SAS, to use a variable, you have to define it in one data step, then make another data step in order to use that variable. But, like `dplyr`, SAS has a row number counter that we can use for this purpose. 
```{sashtml rownumbers}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

DATA tmp;
SET classdat.poke;
  rownum=_n_; /* SAS shorthand for row number */
RUN; 

DATA evenrow;
  SET WORK.tmp;
  WHERE MOD(rownum, 2) = 0;
  DROP rownum; /* ditch temp variable */
RUN;
```
</details>

<details><summary>Top N values</summary>
We're going to want to use PROC SORT to get the data arranged before we take the top N values. 
According to [this](https://communities.sas.com/t5/General-SAS-Programming/if-and-where-statement-for-n/td-p/237647), we can't use `_n_` in a where statement, and the proposed solution isn't reliable. So we'll do it the long way.
```{sashtml topnvalues, error = T}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

PROC SORT DATA = classdat.poke 
  OUT = pokesort;
  BY descending total_points;
RUN;

DATA poken;
  SET WORK.pokesort;
  rownum = _n_;
RUN;
  
DATA poken;
  SET WORK.poken;
  WHERE rownum <= 5;
  DROP rownum;
RUN;

PROC PRINT DATA = poken;
  VAR pokedex_number name status species type_1 total_points;
RUN;
```
</details>

In both cases, the SAS statements required to perform the task require a WHERE clause, but also a few other statements to get things working. The equivalent base R code would be about the same (though tricky in different spots) - the thing that makes the `tidyverse` philosophy so addictive is that it makes these common, everyday tasks both easy and concise (that is, few lines of code are required). 


## Select: Pick columns

Sometimes, we don't want to work with a set of 50 variables when we're only interested in 5. When that happens, we might be able to pick the variables we want by index (e.g. `df[, c(1, 3, 5)]`, or VAR statements, but that can get tedious). 

In `dplyr`, the function to pick a few columns is `select()`. The syntax from the help file (`?select`) looks deceptively simple. 

> select(.data, ...)

So as with just about every other tidyverse function, the first argument in a select statement is the data. After that, though, you can put just about anything that R can interpret. `...` means something along the lines of "put in any additional arguments that make sense in context or might be passed on to other functions". 

So what can go in there? 

<details><summary>An exhaustive list of ways to select variables in `dplyr`</summary>
First, dplyr aims to work with standard R syntax, making it intuitive (and also, making it work with variable names instead of just variable indices).^[It accomplishes this through the magic of quasiquotation, which we will not cover in this course because it's basically witchcraft.] Most `dplyr` commands work with "bare" variable names - you don't need to put the variable name in quotes to reference it. There are a few exceptions to this rule, but they're very explicitly exceptions. 

- `var3:var5`: `select(df, var3:var5)` will give you a data frame with columns var3, anything between var3 and var 5, and var5

- `!(<set of variables>)` will give you any columns that aren't in the set of variables in parentheses

- `(<set of vars 1>) & (<set of vars 2>)` will give you any variables that are in both set 1 and set 2. `(<set of vars 1>) | (<set of vars 2>)` will give you any variables that are in either set 1 or set 2. 

- `c()` combines sets of variables. 

`dplyr` also defines a lot of variable selection "helpers" that can be used inside `select()` statements. These statements work with bare column names (so you don't have to put quotes around the column names when you use them). 

- `everything()` matches all variables
- `last_col()` matches the last variable. `last_col(offset = n)` selects the n-th to last variable.
- `starts_with("xyz")` will match any columns with names that start with xyz. Similarly, `ends_with()` does exactly what you'd expect as well. 
- `contains("xyz")` will match any columns with names containing the literal string "xyz". Note, `contains` does not work with regular expressions (you don't need to know what that means right now).
- `matches(regex)` takes a regular expression as an argument and returns all columns matching that expression. 
- `num_range(prefix, range)` selects any columns that start with prefix and have numbers matching the provided numerical range. 

There are also selectors that deal with character vectors. These can be useful if you have a list of important variables and want to just keep those variables. 

- `all_of(char)` matches all variable names in the character vector `char`. If one of the variables doesn't exist, this will return an error.
- `any_of(char)` matches the contents of the character vector `char`, but does not throw an error if the variable doesn't exist in the data set. 

There's one final selector - 

- `where()` applies a function to each variable and selects those for which the function returns TRUE. This provides a lot of flexibility and opportunity to be creative (but I've never actually needed to use it). 

</details>

<details>
<summary>Let's try these selector functions out and see what we can accomplish!</summary>

```{r}
if (!"nycflights13" %in% installed.packages()) install.packages("nycflights13")
library(nycflights13)

data(flights)
str(flights)
```

We'll start out with the `nycflights13` package, which contains information on all flights that left a NYC airport to destinations in the US, Puerto Rico, and the US Virgin Islands. 

::: {.tryitout}
You might want to try out your EDA skills from the previous module to see what you can find out about the dataset, before seeing how `select()` works.
:::


We could get a data frame of departure information for each flight:
```{r select-departure}
select(flights, flight, year:day, tailnum, origin, matches("dep"))
```

Perhaps we want the plane and flight ID information to be the first columns:
```{r select-rearrange}
flights %>%
  select(carrier:dest, everything())
```

Note that `everything()` won't duplicate columns you've already added.

Exploring the difference between bare name selection and `all_of()`/`any_of()`
```{r select-bare-vs-names, error = T}
flights %>% 
  select(carrier, flight, tailnum, matches("time"))

varlist <- c("carrier", "flight", "tailnum", 
             "dep_time", "sched_dep_time", "arr_time", "sched_arr_time", 
             "air_time")

flights %>%
  select(all_of(varlist))

varlist <- c(varlist, "whoops")

flights %>%
  select(all_of(varlist)) # this errors out b/c whoops doesn't exist

flights %>%
  select(any_of(varlist)) # this runs just fine
```
</details>

So for now, at least in R, you know how to cut your data down to size rowwise (with `filter`) and column-wise (with `select`). 

Unfortunately, SAS doesn't make column selection *quite* as easy. It's still not hard, but it can be tedious. In SAS, there are two primary methods to select variables: KEEP selects variables, DROP removes variables. 

```{r, eval = F}
# Export flights data for SAS
flights %>%
  sample_frac(size = .25) %>% # Keep file from being too big
write_csv("data/flights.csv", na = ".")
```

```
/* Read in data */
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";
filename fileloc '~/Projects/Class/unl-stat850/2020-stat850/data/flights.csv';
PROC IMPORT  datafile = fileloc out=classdat.flights
  DBMS = csv; /* comma delimited file */
  GETNAMES = YES;
RUN;
```

In SAS, a partial variable name either preceded or followed by `:` serves as  a wildcard.
Ranges of variables can be specified with two dashes, e.g. `var3 -- var5`. 

<details><summary>SAS KEEP statement</summary> 
Unfortunately, the wildcard doesn't work on both ends, so to get the equivalent of `matches("dep")`, we have to use two different options in our KEEP statement (plus the extra variables that don't have dep in them).

```{sashtml}

libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

DATA tmpfly;
  KEEP flight year--day tailnum origin dep: sched_dep:;
  SET classdat.flights;
RUN;

PROC PRINT DATA = tmpfly (obs=10); 
RUN;

```
Note also that SAS doesn't reorder the columns for us like `select()` does. 
</details>

If we'd prefer to carve out columns (rather than assembling a new dataset with the columns we want to keep), we can use a DROP statement, which works exactly the same way. Let's see what columns we removed implicitly last time by dropping everything we'd previously kept:

<details><summary>SAS DROP statement</summary>
```{sashtml sas-select-drop}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

DATA tmpfly;
  DROP flight year--day tailnum origin dep: sched_dep:;
  SET classdat.flights;
RUN;

PROC PRINT DATA = tmpfly (obs=10); 
RUN;
```
</details>
For the most part, that is what you need to functionally replicate `select()` syntax. It may be a bit more work because there aren't the same convenience functions, but it'll do and you don't have to remember as many keywords, so that's a plus. 

## Mutate: Add and transform variables

Up to this point, we've been primarily focusing on how to decrease the dimensionality of our dataset in various ways. But frequently, we also need to add columns for derived measures (e.g. BMI from weight and height information), change units, and replace missing or erroneous observations. The tidyverse verb for this is `mutate`. However, it's probably best to start this section out with a very short demonstration of how this process worked in R before the tidyverse came around.

<details><summary>Pre-tidyverse base R "mutating" a data frame</summary>
Lets use the police violence data to demonstrate. Remember the issues you identified with the data during EDA in Module 4 ([in SAS](#police-violence-eda-sas))([in R](#police-violence-eda-r))?

The `gsub` function is basically R's version of "find and replace". 

```{r}
library(readxl)
police_violence <- read_xlsx("data/police_violence.xlsx", guess_max = 7000)

# There are two categories for "unknown race"
table(police_violence$`Victim's race`, useNA = 'ifany')

# This line substitutes "race" for "Race" so that there's consistent capitalization
police_violence$race <- gsub("Race", "race", police_violence$`Victim's race`)

# Fixed!
table(police_violence$race)
```

You could do a simple operation like that in a single line, but you had to use the name of the data multiple times, and it very quickly becomes a complicated operation. 
</details>

The process in SAS is very similar. It's recommended that you use one data step to read in your data, and then a separate data step to clean the data, so that you are separating the two operations. 

<details><summary>SAS - create a new variable</summary>
We can create our variable a couple of different ways in SAS: 
- Use the [TRANWRD function](https://v8doc.sas.com/sashtml/lgref/z0215027.htm) for find and replace.
- Use an if statement and define the replacement ourselves

Both are demonstrated below:
```{sashtml}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";
/* Police violence data already in the library */

DATA pvtmp;
  SET classdat.police;
  race = tranwrd(victim_s_race, "Race", "race");
  race2 = victim_s_race; /* initialize it to current value */
  IF victim_s_race='Unknown Race' THEN race2 = 'Unknown race';
RUN;

PROC FREQ DATA = pvtmp ORDER=FREQ; /* Combinations of vars */
TABLES victim_s_race * race victim_s_race * race2 / 
  NOCUM NOPERCENT NOCOL NOROW MAXLEVELS=10;
RUN;
```
In both cases we can see that the recode worked the way we wanted and we've now gotten rid of the extra "unknown" category". 
</details>

In `dplyr`, the verb for this process is `mutate`, as mentioned above. The fundamentals of `mutate` are very similar to the approaches above; the power of the dplyr approach is only really evident when you are doing multiple operations in the same step. Once you're working at that level, the `dplyr` approach produces much more readable code. 

<details><summary>`mutate()` a new variable</summary>
```{r}
# The data was read in above...
library(dplyr)
police_violence %>% 
  mutate(race = gsub("Race", "race", `Victim's race`)) %>%
  select(`Victim's race`, race) %>%
  table()
```
The last 2 rows are just to organize the output - we keep only the two variables we're working with, and get a crosstab like PROC FREQ gave us in SAS. 
</details>

The learning curve here isn't actually knowing how to use mutate (though that's important). The challenge comes when you want to do something *new* and have to figure out how to e.g. use find and replace, or work with dates and times, or recode variables. I'm not going to be able to teach you how to handle every task you'll come across (people invent new ways to screw up data all the time!) but my goal is instead to teach you how to read documentation and google things intelligently, and to _understand what you're reading_ enough to actually implement it. This is something that comes with practice (and lots of googling, stack overflow searches, etc.). It's actually something of a common meme...

```{r, echo = F}
if(!"tweetrmd"%in%installed.packages()) devtools::install_github("gadenbuie/tweetrmd")
if(!"webshot2"%in%installed.packages()) devtools::install_github("rstudio/webshot2")
library(tweetrmd) # github.com/gadenbuie/tweetrmd
library(memoise) # cache screenshots
tweet_cached <- memoise(tweet_embed, cache = cache_filesystem('.tweets'))
tweet_shot_cached <- memoise(tweet_screenshot, cache = cache_filesystem('.tweets'))

tweet_screenshot(tweet_url("cszhu", "1230954186520461312"))
tweet_screenshot(tweet_url("grubes14", "1168946210868269057"))
```

I'm going to do my best to expose you to some of the solutions to common problems and even point you in the right direction, but I'm intentionally *not* formally teaching you some of these things, because part of learning how to program is learning how to read documentation and other resources to figure things out. It would be relatively easy to teach you how to do a set list of tasks, but you'll be better statisticians and programmers if you learn the skills to solve any niche problem on your own. 

```{r, echo = F, fig.cap = "Apologies for the noninclusive language, but the sentiment is real, even if not stated in an inclusive way."}
tweet_screenshot(tweet_url("abt_programming", "459414524303785984"))
```

What I will do is provide you with a quick list of packages in R which will solve some of the more common problems. Between that and the R cheatsheet, you should be set. In SAS, there are fewer options, so it's less bewildering to google solutions (but I'll link you to relevant pieces for the common SAS stuff too). 

::: learn-more
- Dates and times: `lubridate` package in R (esp. `ymd_hms()` and variants, `decimal_date()`, and other convenience functions). [SAS Dates and Times](https://documentation.sas.com/?docsetId=lrcon&docsetTarget=p1wj0wt2ebe2a0n1lv4lem9hdc0v.htm&docsetVersion=9.4&locale=en).
- String manipulation:
  - `stringr` package in R (`str_replace()`, `str_remove()`, `str_detect()`, `str_split()`) 
  - [Regular Expression Cheatsheet (R)](https://rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf)
  - [Common String operations in SAS](https://www.listendata.com/2014/12/sas-character-functions.html)
  - [Regular Expressions in SAS](https://support.sas.com/resources/papers/proceedings/proceedings/sugi29/265-29.pdf)
:::

## Group By

## Summarize
