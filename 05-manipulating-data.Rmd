# Manipulating Data {#manipulating-data}


## Module Objectives {-}

- Filter, subset, and clean data to prepare a dataset for analysis
- Describe and document operations performed on a data set transparently, and implement the operations using reproducible steps.

In this section, we're going to start out by learning how to work with data. Generally speaking, data doesn't come in a form suitable for analysis - you have to clean it up, create the variables you care about, get rid of those you don't care about, and so on. 

In R, we'll be using the `tidyverse` for this. It's a meta-package (a package that just loads other packages) that [collects packages designed with the same philosophy^[The philosophy includes a preference for pipes, ] and API (basically, the commands will use predictable argument names and structure). You've already been introduced to the tidyverse - specifically, `readr`. 

In SAS, there is no tidyverse, but there is a relatively consistent structure for how to accomplish each task. Most data cleaning in SAS is accomplished in data steps. In the interests of not confusing terms too much between languages, I'm going to use the tidyverse "verbs" to describe operations in both SAS and R. 

`dplyr` (one of the packages in the tidyverse) creates a "grammar of data manipulation" to make it easier to describe different operations. I find the `dplyr` grammar to be extremely useful when talking about data operations, so I'm going to attempt to show you how to do the same operations in R with dplyr, and in SAS (without the underlying framework). Each verb describes a common task when doing both exploratory data analysis and more formal statistical modeling. 

<div class="learn-more">
[There is an excellent dplyr cheatsheet available from RStudio](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf). You may want to print it out to have a copy to reference as you work through this chapter. </div>

## Tidy Data

There are infinitely many ways to configure "messy" data, but data that is "tidy" has 3 attributes:

1. Each variable has its own column
2. Each observation has its own row
3. Each value has its own cell

We'll get more into how to work with different "messy" data configurations in the next module, but it's worth keeping rules 1 and 3 in mind while working through this module. 



## Filter: Pick cases (rows) based on their values

Filter allows us to work with a subset of a larger data frame, keeping only the rows we're interested in. We provide one or more logical conditions, and only those rows which meet the logical conditions are returned from `filter()`. Note that unless we store the result from `filter()` in the original object, we don't change the original. 

Let's explore how it works, using the `starwars` dataset, which contains a comprehensive list of the characters in the Star Wars movies. 

<details><summary>Demonstration of `filter()` in R</summary>
```{r r-filter-data}
library(dplyr)
data(starwars)
starwars

# Get only the people
filter(starwars, species == "Human")

# Get only the people who come from Tatooine
filter(starwars, species == "Human", homeworld == "Tatooine")
```
</details>

```{r starwars-data-export, eval = F}
readr::write_csv(starwars[,1:11], "data/starwars.csv", na = '.')
```

In the interests of demonstrating the process on the same data, I've exported the starwars data to a CSV file using the `readr` package. I had to remove the list-columns (films, vehicles, starships) because that format isn't supported by SAS. You can access the csv data [here](data/starwars.csv). Note that I exported the data using '.' as the NA/missing character so that it will be easy to read into SAS.

Let's set that data up first: 
```{sashtml sas-setup-data}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";
filename swdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/data/starwars.csv";

PROC IMPORT DATAFILE = swdat OUT = classdat.starwars 
    DBMS = CSV 
    REPLACE; 
    GETNAMES = YES;
RUN;

PROC PRINT DATA=classdat.starwars (obs=10);
RUN;
```

If you want to directly load the SAS datafile, you can find it [here](sas/starwars.sas7bdat)

In SAS, as in SQL, the `filter()` operation is accomplished using the `where` clause. Multiple clauses can be connected using `and`, and compound statements can be grouped with parentheses. 
<details><summary>Demonstration of `where` in SAS</summary>
With these chunks, I am providing the SAS LOG output, because those tell us how many rows are left in the datasets. It's easier and hopefully less to read. 
```{saslog}
libname classdat "/home/susan/Projects/Class/unl-stat850/2020-stat850/sas/";

/* SAS limits dataset names to 8 characters, which is super annoying. */
/* Sorry the names aren't descriptive... */

DATA tmp1; /* this is the out dataset */
      /* By not having a library attached, I'm saying this is a temp dataset */
  set classdat.starwars;
  where (species = 'Human');
  run;
  
DATA tmp2; 
  set classdat.starwars;
  where (species = 'Human') and (homeworld = 'Tatooine');
  run;
```


## Select

## Group By

## Summarize
