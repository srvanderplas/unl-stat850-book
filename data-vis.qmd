# Data Visualization {#sec-data-vis}

## Module Objectives  {- #module11-objectives}

- Create charts designed to communicate specific aspects of the data
- Describe charts using the grammar of graphics 
- Create layered graphics that highlight multiple aspects of the data
- Evaluate existing charts and develop new versions that improve accessibility and readability


There are a lot of different types of charts, and equally many ways  to categorize and describe the different types of charts. 

::: callout-note
### A less serious classification scheme

![Mouseover text: I would describe my personal alignment as "lawful heterozygous silty liquid."](https://imgs.xkcd.com/comics/alignment_chart_alignment_chart.png)

IMO, Randall missed the opportunity to put a pie chart as Neutral Evil. 
:::

Hopefully by the end of this, you will be able to make most commonly used statistical charts. 

This is going to be a fairly extensive chapter (in terms of content) because I want you to have a resource to access later, if you need it. But, this is also the chapter where we really start to focus on R. Even the hardcore SAS users I know (in this department and others) go into R when they want to make a publication-quality chart, and while python has several different graphics libraries, it's hard to beat plotnine for simplicity if you're learning ggplot2 at the same time. 

::: aside
Visualization and statistical graphics are also my research area, so I'm probably going to be a bit more passionate about this chapter, which means there's probably going to be more to read. Sorry about that in advance. I'll do my best to indicate which content is actually mission-critical and which content you can skip if you're not that interested.
:::

## Why do we create graphics?

> The greatest possibilities of visual display lie in vividness and inescapability of the intended message. A visual display can stop your mental flow in its tracks and make you think. A visual display can force you to notice what you never expected to see. ("Why, that scatter diagram has a hole in the middle!") -- @tukeyDataBasedGraphicsVisual1990

::: {.callout-note collapse=true}
### Charts are easier to understand than raw data. 

When you think about it, data is a pretty artificial thing. We exist in a world of tangible objects, but data are an abstraction - even when the data record information about the tangible world, the measurements are a way of removing the physical and transforming the "real world" into a virtual thing. As a result, it can be hard to wrap our heads around what our data contain. The solution to this is to transform our data back into something that is "tangible" in some way -- if not physical and literally touch-able, at least something we can view and "wrap our heads around". 

Consider this thought experiment: You have a simple data set - 2 variables, 500 observations. You want to get a sense of how the variables relate to each other. You can do one of the following options:

1. Print out the data set
2. Create some summary statistics of each variable and perhaps the covariance between the two variables
3. Draw a scatter plot of the two variables

Which one would you rather use? Why?

Our brains are very good at processing large amounts of visual information quickly. Evolutionarily, it's important to be able to e.g. survey a field and pick out the tiger that might eat you. When we present information visually, in a format that can leverage our visual processing abilities, we offload some of the work of understanding the data to a chart that organizes it for us. You could argue that printing out the data is a visual presentation, but it requires that you read that data in as text, which we're not nearly as equipped to process quickly (and in parallel). 
:::

It's a lot easier to talk to non-experts about complicated statistics using visualizations. Moving the discussion from abstract concepts to concrete shapes and lines keeps people who are potentially already math or stat phobic from completely tuning out.

## General approaches to creating graphics

There are two general approaches to generating statistical graphics computationally: 
  
1. Manually specify the plot that you want, doing the preprocessing and summarizing before you create the plot.

2. Describe the relationship between the plot and the data, using sensible defaults that can be customized for common operations.

In the introduction to The Grammar of Graphics [@wilkinsonGrammarGraphics1999], Leland Wilkinson suggests that the first approach is what we would call "charts" - pie charts, line charts, bar charts - objects that are "instances of much more general objects". His argument is that elegant graphical design means we have to think about an underlying theory of graphics, rather than how to create specific charts. The 2nd approach is called the "grammar of graphics". 

Base R graphics, matplotlib graphics in Python, and the original SAS graphics engine fall firmly into the first camp. `ggplot2` was designed using the philosophy of the grammar of graphics, and is still the primary place that people learn about the grammar of graphics in statistics.

::: callout-note
You're going to learn how to make graphics by finding sample code, changing that code to match your data set, and tweaking things as you go. That's the best way to learn this, and while option 2 does have a structure and some syntax to learn, once you're familiar with the principles, you'll still want to learn graphics by doing it. 
:::

There are other graphics systems in R (namely, `lattice`, plus some web-based rendering engines) that you could explore, but it's far more important that you know how to functionally create plots in R and/or Python. I don't recommend you try to become proficient in all of them. Pick one (two at most) and get to know that, then google for the rest.

Before we delve into the grammar of graphics, let's motivate the philosophy using a simple task. Suppose we want to create a pie chart using some data. Pie charts are terrible, and we've known it for 100 years[@croxtonBarChartsCircle1927a], so in the interests of showing that we know that pie charts are awful, we'll also create a stacked bar chart, which is the most commonly promoted alternative to a pie chart. We'll talk about what makes pie charts terrible at the end of this module. 

::: callout-caution
### Example: Generations of Pokemon

Suppose we want to explore Pokemon. There's not just the original 150 (gotta catch 'em all!) - now there are over 1000! 
Let's start out by looking at the proportion of Pokemon added in each of the 8 generations.

::: panel-tabset

#### R setup {-}
```{r poke-read-data-r, message = F}
library(readr)
library(dplyr)
library(tidyr)
library(stringr)

# Setup the data
poke <- read_csv("data/pokemon_ascii.csv", na = '.') %>%
  mutate(generation = factor(generation))
```

#### Python setup {-}
```{python poke-read-data-py}
import pandas as pd
poke = pd.read_csv("data/pokemon_ascii.csv")
poke['generation'] = pd.Categorical(poke.generation)
```
:::

Once the data is read in, we can start plotting:

::: panel-tabset

#### Base R {-}

Let's start with what we want: for each generation, we want the total number of pokemon. 

To get a pie chart, we want that information mapped to a circle, with each generation represented by an angle whose size is proportional to the number of pokemon in that generation.

```{r base-pie}
# Create summary of pokemon by type
tmp <- poke %>%
  group_by(generation) %>%
  count() 

pie(tmp$n, labels = tmp$generation)

# with(., <base command>) let you use the pipe easily with a base R command
# that is otherwise not pipe friendly, e.g. 
# with(tmp, pie(n, labels = generation))
```

We could alternately make a bar chart and stack the bars on top of each other. This also shows proportion (section vs. total) but does so in a linear fashion.

```{r base-barplot}
# Create summary of pokemon by type
tmp <- poke %>%
  group_by(generation) %>%
  count() 

# Matrix is necessary for a stacked bar chart
matrix(tmp$n, nrow = 8, ncol = 1, dimnames = list(tmp$generation)) %>%
barplot(beside = F, legend.text = T, main = "Generations of Pokemon")
```

#### ggplot2 {-}
In ggplot2, we start by specifying which variables we want to be mapped to which features of the data. 

In a pie or stacked bar chart, we don't care about the x coordinate - the whole chart is centered at (0,0) or is contained in a single "stack". So it's easiest to specify our x variable as a constant, "". We care about the fill of the slices, though - we want each generation to have a different fill color, so we specify generation as our fill variable. 

Then, we want to summarize our data by the number of objects in each category - this is basically a stacked bar chart. Any variables specified in the plot statement are used to implicitly calculate the statistical summary we want -- that is, to count the rows (so if we had multiple x variables, the summary would be computed for both the x and fill variables). ggplot is smart enough to know that when we use `geom_bar`, we generally want the y variable to be the count, so we can get away with leaving that part out. We just have to specify that we want the bars to be stacked on top of one another (instead of next to each other, "dodge").

```{r gg-bar}
library(ggplot2)

ggplot(aes(x = "", fill = generation), data = poke) + 
  geom_bar(position = "stack") 
```

If we want a pie chart, we can get one very easily - we transform the coordinate plane from Cartesian coordinates to polar coordinates. We specify that we want angle to correspond to the "y" coordinate, and that we want to start at $\theta = 0$. 

```{r gg-pie, message = F}
ggplot(aes(x = "", fill = generation), data = poke) + 
  geom_bar(position = "stack") + 
  coord_polar("y", start = 0)
```

Notice how the syntax and arguments to the functions didn't change much between the bar chart and the pie chart? That's because the `ggplot` package uses what's called the **grammar of graphics**, which is a way to describe plots based on the underlying mathematical relationships between data and plotted objects. In base R and in matplotlib in Python, different types of plots will have different syntax, arguments, etc., but in ggplot2, the arguments are consistently named, and for plots which require similar transformations and summary observations, it's very easy to switch between plot types by changing one word or adding one transformation.

#### Matplotlib {-}

Let's start with what we want: for each generation, we want the total number of pokemon. 

To get a pie chart, we want that information mapped to a circle, with each generation represented by an angle whose size is proportional to the number of Pokemon in that generation.

```{python plt-pie}
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

# Create summary of pokemon by type
labels = list(set(poke.generation)) # create labels by getting unique values
sizes = poke.generation.value_counts(normalize=True)*100

# Draw the plot
fig1, ax1 = plt.subplots()
ax1.pie(sizes, labels = labels, autopct='%1.1f%%', startangle = 90)
ax1.axis('equal')
plt.show()
```


We could alternately make a bar chart and stack the bars on top of each other. This also shows proportion (section vs. total) but does so in a linear fashion.

```{python plt-bar}
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

# Create summary of pokemon by type
labels = list(set(poke.generation)) # create labels by getting unique values
sizes = poke.generation.value_counts()
sizes = sizes.sort_index()

# Find location of bottom of the bar for each bar
cumulative_sizes = sizes.cumsum() - sizes
width = 1

fig, ax = plt.subplots()

for i in sizes.index:
  ax.bar("Generation", sizes[i], width, label=i, bottom = cumulative_sizes[i])

ax.set_ylabel('# Pokemon')
ax.set_title('Pokemon Distribution by Generation')
ax.legend()

plt.show()
```

#### Plotnine {-}

As of August 2022, pie charts are [still not supported in plotnine](https://github.com/has2k1/plotnine/issues/10). So this demo will fall a bit flat. 

```{python gg-bar-py}
from plotnine import *
plt.cla() # clear out matplotlib buffer

ggplot(aes(x = "1", fill = "generation"), data = poke) + geom_bar(position = "stack")
```

:::

:::

If only because it provides us with a place to start (because otherwise, we would just work through a graph gallery or two, and that's boring), we'll talk first about the general idea behind the grammar of graphics. For each concept, I'll provide you first with the ggplot grammar of graphics code, and then, where it is possible to replicate the chart easily in base R or Python graphics, I will provide code for that as well - so that you can compare the approaches, but also so that you get a sense for what is easy and what is possible in each plotting system. 


## The Grammar of Graphics

<!-- A basic sentence has a subject and a predicate (usually, this contains a verb), but of course, there are infinintely many ways to combine and expand on a single sentence. The structure of the sentence describes how the subject relates to the predicate, with clauses and so on that modify the original meaning.  -->

<!-- The grammar of graphics is designed as an object-oriented graphics system. That is, the idea is that there are certain objects that communicate with each other. Each object does a few things well, and the intelligence is in the system, not in the objects themselves. This design principle means that objects can be repurposed for many things (because each object is relatively simple and modular).  -->

In the grammar of graphics, a plot consists of several mostly independent specifications:

1. **aesthetics** - links between data variables and graphical features (position, color, shape, size)
2. **layers** - geometric elements (points, lines, rectangles, text, ...) 
3. **transformations** - transformations specify a functional link between the data and the displayed information (identity, count, bins, density, regression). Transformations act on the variables. 
4. **scales** - scales map values in data space to values in the aesthetic space. Scales change the coordinate space of an aesthetic, but don't change the underlying value (so the change is at the visual level, not the mathematical level). 
5. **coordinate system** - e.g. polar or Cartesian
6. **faceting** - facets allow you to split plots by other variables to produce many sub-plots.
7. **theme** - formatting items, such as background color, fonts, margins...

We can contrast this with other plotting systems (e.g. Base R, matplotlib, seaborn), where transformations and scales must be handled manually, there may be separate plotting systems for different coordinate systems, etc. 

Functionally, the biggest difference between the two systems is that in the grammar of graphics system (as implemented in ggplot2), we work with a full tabular data set. So like the rest of the tidyverse, ggplot2 will allow you to reference bare column names as if they were variables, so long as you've passed in the data set to the `data =` argument.

::: aside
This can sometimes be a pain, because you may end up with labels that are repeated many, many times. As with any system, you just have to make sure you're formatting your data in a way that is consistent and compatible with the underlying philosophy.
:::

![Building a masterpiece, by Allison Horst](https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/ggplot2_masterpiece.png){fig-alt="A fuzzy monster in a beret and scarf, critiquing their own column graph on a canvas in front of them while other assistant monsters (also in berets) carry over boxes full of elements that can be used to customize a graph (like themes and geometric shapes). In the background is a wall with framed data visualizations. Stylized text reads “ggplot2: build a data masterpiece.”"}

::: panel-tabset
We'll use the [`palmerpenguins` package](https://allisonhorst.github.io/palmerpenguins/) in R to do this visualization demo [@palmerpenguins]. Palmerpenguins also exists as a python package which is installable using pip.

### R data setup
```{r graphics-data-setup-r}
if (!"palmerpenguins" %in% installed.packages()) install.packages("palmerpenguins")
data(penguins, package = "palmerpenguins")
head(penguins)
```

### Python data setup
```{python graphics-data-setup-py}
from palmerpenguins import load_penguins
penguins = load_penguins()
penguins.head
```
:::


### Basic Plot Components - Axes and Points

Let's start out with a basic scatterplot: we want to use x and y locations to show two variables, and we want to use points to indicate the space where the x location and y location meet in the Cartesian plane.

::: panel-tabset

#### ggplot2

Let's start out with a basic scatterplot: we want to use x and y locations to show two variables, and we want to use points to indicate the space where the x location and y location meet in the Cartesian plane. 

```{r aes-basic-gg}
library(ggplot2)
# This defines a blank coordinate plane
ggplot(data = penguins) + 
  aes(x = bill_length_mm, y = body_mass_g)

# This plot actually has points!
ggplot(data = penguins) + 
  aes(x = bill_length_mm, y = body_mass_g) + 
  geom_point() # add points
```

The `aes()` statement can also go inside of the `ggplot()` statement or inside of `geom_point(aes(...))`. It's useful to show it outside of the `ggplot()` statement to show you exactly how the plot is built up, but most people write the code as `ggplot(aes(x = ..., y = ...), data = ...) + geom_point()` by convention.

#### plotnine

```{python aes-basic-gg-py}
from plotnine import *
# Define a blank coordinate plane
ggplot(data = penguins) + aes(x = "bill_length_mm", y = "body_mass_g")

# Add a points layer
ggplot(data = penguins) + aes(x = "bill_length_mm", y = "body_mass_g") + geom_point()
```

#### Base R

In base R, we have to use `df$var` notation to reference the variables. 

```{r aes-basic-baser}
plot(x = penguins$bill_length_mm, y = penguins$body_mass_g)

# We can also use formula notation, which allows a data = ... argument
plot(body_mass_g ~ bill_length_mm, data = penguins)
```

#### Matplotlib

```{python aes-basic-plt}
import numpy as np
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

plt.scatter(penguins.bill_length_mm, penguins.body_mass_g)
plt.show()
```

:::


### Adding Labels and Titles


::: panel-tabset

#### ggplot2

```{r aes-label-gg}
library(ggplot2)
# This defines a blank coordinate plane
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g)) + 
  # add points
  geom_point() + 
  ggtitle("Penguin Bill Length and Body Mass") + 
  xlab("Bill Length (mm)") + 
  ylab("Body Mass (g)")
```

You can even add labels that have math symbols if you are careful about how you do it (or if you use the [`latex2exp` package](https://www.stefanom.io/latex2exp/) [@latex2exp]).

#### plotnine

```{python aes-label-gg-py}
from plotnine import *

(ggplot(aes(x = "bill_length_mm", y = "body_mass_g"), data = penguins) + 
  geom_point() + 
  ggtitle("Penguin Bill Length and Body Mass") + 
  xlab("Bill Length (mm)") + 
  ylab("Body Mass (g)")
)

```

#### Base R

```{r aes-label-baser}
plot(x = penguins$bill_length_mm, y = penguins$body_mass_g,
     main = "Penguin Bill Length and Body Mass",
     xlab = "Bill Length (mm)", ylab = "Body Mass (g)")
```

#### Matplotlib

```{python aes-label-plt}
import numpy as np
import matplotlib.pyplot as plt

plt.title("Penguin Bill Length and Body Mass")
plt.scatter(penguins.bill_length_mm, penguins.body_mass_g)
plt.xlabel("Bill Length (mm)")
plt.ylabel("Body Mass (g)")
plt.show()
```

:::

### Other Aesthetics: Color, Shape, Line Type, Alpha, and more 

When considering other aesthetics, such as the color or size of plotted objects, the shape of points, line types, and alpha blending, it is important to differentiate between mapping these quantities to **dataset variables** and setting **constant values**. Mapping quantities to a variable in the dataset requires considerably more work under the hood, as we have to set up a scale from the original values that maps to the aesthetic values, we have to generate the corresponding aesthetic values for each data point, and we usually want to create a legend. When we set constant values, however, we just... set the value and we're done. Constant values are usually set to adhere to style guides, to enhance visual appeal, and sometimes to "backwards-engineer" a scale. 

#### Mapping Categorical Variables

If the goal is to map an aesthetic to a variable in the dataset, then we need to ensure that each geometric object has an appropriately computed mapping (and each object is plotted with that mapping). This is more computationally complex than just setting a constant value for all objects plotted.

In grammar of graphics terminology, this is an **aesthetic mapping**, and in `ggplot2` and `plotnine`, aesthetic mappings go inside `aes()` statements. 

Here, I'll demonstrate mapping variables to color, shape, and size aesthetics, but the process is similar for other aesthetics, such as linetype, fill, etc.

::: panel-tabset

##### ggplot2

```{r aes-mapping-gg}
library(ggplot2)
# This defines a blank coordinate plane
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g)) + 
  # add points
  geom_point(aes(shape = species, color = species)) + 
  ggtitle("Penguin Bill Length and Body Mass") + 
  xlab("Bill Length (mm)") + 
  ylab("Body Mass (g)")
```

Notice that we haven't had to specify any sort of categorical mapping here - ggplot picks the shapes and colors we're using based on the number of categories we have. If we want to customize these default mappings, we can use `scale_color_discrete`, `scale_color_manual`, `scale_shape_discrete`, and so on. Only if we want to override the default mapping do we have to specify that we're working with a discrete variable.

##### plotnine

```{python aes-mapping-gg-py}
from plotnine import *

(ggplot(aes(x = "bill_length_mm", y = "body_mass_g"), data = penguins) + 
  geom_point(aes(shape = "species", color = "species")) + 
  ggtitle("Penguin Bill Length and Body Mass") + 
  xlab("Bill Length (mm)") + 
  ylab("Body Mass (g)")
)

```

##### Base R

I've used code from Jenny Bryan's Stat 545 at UBC website [@bryanPuttingColorsWork] and modified it, since I'm not an expert in base graphics. Regardless, the whole thing feels very clunky to me relative to the grammar-of-graphics approach in ggplot2/plotnine.

```{r aes-mapping-baser}
library(RColorBrewer)
# Create color and point mapping between data and plotted values
aes_mapping <- data.frame(
  species = unique(penguins$species), 
  color = brewer.pal(nlevels(penguins$species), name = 'Dark2'),
  shape = 1:3)

plot(x = penguins$bill_length_mm, y = penguins$body_mass_g,
     col = aes_mapping$color[match(penguins$species, aes_mapping$species)],
     pch = aes_mapping$shape[match(penguins$species, aes_mapping$species)],
     main = "Penguin Bill Length and Body Mass",
     xlab = "Bill Length (mm)", ylab = "Body Mass (g)")
# Manually create legend
legend(x = 'bottomright', 
       legend = as.character(aes_mapping$species),
       col = aes_mapping$color, pch = aes_mapping$shape, bty = 'n', xjust = 1)
```

##### Matplotlib

```{python aes-mapping-plt}
import numpy as np
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

penguins['species'] = pd.Categorical(penguins.species)

# Create categorical mapping to marker type
marker_types = {'Adelie':'o', 'Chinstrap':'*', 'Gentoo':'+'}
marker_color = {'Adelie':'orange', 'Chinstrap':'green', 'Gentoo':'purple'}

groups = penguins.groupby('species')
for name, group in groups:
  plt.plot(group.bill_length_mm, group.body_mass_g, marker = marker_types[name], color = marker_color[name], linestyle = '', label = name)

plt.xlabel("Bill Length (mm)")
plt.ylabel("Body Mass (g)")
plt.legend()
plt.show()
```

Python's dict type helps a lot here: we can create the mapping between species and shape/color a bit more naturally. But it's still a lot of details to think about and customize, where ggplot2 tries very hard to give you sensible default color/shape mappings that you don't have to customize unless the defaults aren't what you want.

:::

#### Mapping Continuous Variables

Above, we demonstrated mapping to categorical variables, where we had to select an appropriate color for each unique value in the variable. With continuous mappings, however, we have to instead specify a range of output values (e.g. color, size) and map those values to the values in the dataset. This is understandably more complicated: 

- We need some sort of one-to-one function from our variable's values to our color space, but it doesn't have to be linear (and in many cases, we may want to use a transformation).
- We need a way to interpolate between a vector of color values to get a continuous color space. Color spaces are [complicated](https://en.wikipedia.org/wiki/Color_space) [@wiki-color-space].


::: panel-tabset

##### ggplot2

```{r aes-mapping2-gg}
library(ggplot2)
# This defines a blank coordinate plane
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g)) + 
  # add points
  geom_point(aes(color = bill_depth_mm)) + 
  ggtitle("Penguin Bill Length and Body Mass") + 
  xlab("Bill Length (mm)") + 
  ylab("Body Mass (g)")
```


##### plotnine

```{python aes-mapping2-gg-py}
from plotnine import *

(ggplot(aes(x = "bill_length_mm", y = "body_mass_g"), data = penguins) + 
  geom_point(aes(color = "bill_depth_mm")) + 
  ggtitle("Penguin Bill Length and Body Mass") + 
  xlab("Bill Length (mm)") + 
  ylab("Body Mass (g)")
)

```

##### Base R
This uses a solution I found at [StackOverflow](https://stackoverflow.com/questions/18827214/one-colour-gradient-according-to-value-in-column-scatterplot-in-r).
```{r aes-mapping2-baser, include = F}
library(RColorBrewer)
cols <- brewer.pal(9, "Blues") # get colors
pal <- colorRampPalette(cols) # Define color palette

# Create interval of color levels corresponding to penguin bill depth
bill_depth_intervals <- seq(min(penguins$bill_depth_mm, na.rm = T), 
                            max(penguins$bill_depth_mm, na.rm = T), 
                            length.out = 100)
# Match values to bill depth intervals
value_match <- findInterval(penguins$bill_depth_mm, bill_depth_intervals)
# Translate value into color
bill_depth_color <- pal(100)[value_match]
# Color NAs
bill_depth_color[is.na(bill_depth_color)] <- "#FF0000" # red

# Do the same thing, but for the legend
leg_intervals <- seq(min(penguins$bill_depth_mm, na.rm = T),
                     max(penguins$bill_depth_mm, na.rm = T),
                     length.out = 8)
leg_color <- pal(8)

plot(x = penguins$bill_length_mm, y = penguins$body_mass_g,
     col = bill_depth_color,
     main = "Penguin Bill Length and Body Mass",
     xlab = "Bill Length (mm)", ylab = "Body Mass (g)")
legend(x = 31, 
       y = 6500, 
       legend = leg_intervals,
       col = leg_color, 
       pch = 16, 
       bty = "o",
       title = "Bill Depth (mm)",
       xpd = TRUE)
```

##### Matplotlib

```{python aes-mapping2-plt}
import numpy as np
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

fig, ax = plt.subplots()

scatter = ax.scatter(penguins.bill_length_mm, penguins.body_mass_g, c = penguins.bill_depth_mm, cmap = 'Greens')

# Produce a legend for the ranking (colors).
legend1 = ax.legend(*scatter.legend_elements(num=8),
                    loc="upper left", title="Bill Depth")
ax.add_artist(legend1)

plt.show()
```
:::

::: callout-tip
##### Try it out

::: panel-tabset

###### Problem

Use the Pokemon data to see if there is a relationship between a Pokemon's attack and special attack points (`attack` and `sp_attack`, respectively). Can you map a Pokemon's weight in kg to the point opacity (`alpha`) so that light Pokemon show up as semi-transparent?

###### R solution
```{r poke-tryitout-r}
library(ggplot2)

poke <- read_csv("data/pokemon_ascii.csv", na = '.') 
ggplot(data = poke, aes(x = attack, y = sp_attack, alpha = weight_kg)) + geom_point()
```

###### Python solution
```{python poke-tryitout-py}
from plotnine import *

poke = pd.read_csv("data/pokemon_ascii.csv")
poke['weight_kg'] = pd.to_numeric(poke.weight_kg, errors='coerce')

# Get rid of NA points - they mess up the scales
poke_sub = poke.dropna(axis = 0, subset=['weight_kg', 'attack', 'sp_attack'])
ggplot(data = poke_sub) + geom_point(aes(x = "attack", y = "sp_attack", alpha = "weight_kg"))
```
:::
:::

#### Customizing appearance

Here I'm focusing on characteristics like color and alpha value, but you can customize all sorts of different parameters. 

::: panel-tabset

##### ggplot2

```{r gg-adjust-aes-const}
ggplot(penguins, aes(x = bill_length_mm, y = body_mass_g)) +
  geom_point(color = "blue", alpha = .5, size = 4, shape = 6)
```

##### plotnine

```{python gg-adjust-aes-const-py, message = F}
(
  ggplot(penguins, aes(x = "bill_length_mm", y = "body_mass_g")) +
  geom_point(color = "blue", alpha = .5, size = 4, shape = 6)
)
```

##### Base R
Base R doesn't support alpha blending by default, so we have to load the `scales` package in order to get that functionality.
```{r base-adj-aes-const}
library(scales)
# Using constant alpha:
plot(body_mass_g ~ bill_length_mm, 
     col = alpha("blue", .5),
     pch = 6,
     cex = 3,
     data = penguins) 
```

##### Matplotlib

```{python plt-adj-aes-const}
import numpy as np
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

plt.scatter(penguins.bill_length_mm, penguins.body_mass_g, c = 'blue', marker = '^', alpha = .5, s = 200)
plt.show()
```

::: panel-tip
#### Try it out: Debugging plots

::: panel-tabset

##### Problem

Can you fix the following plot so that it has blue points? 

What mistake was made, and why did the plot end up having pink points?

```{r debugging-plots}
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g, color = "blue")) + geom_point()
```

##### Solution

```{r debugging-plots-solution}
ggplot(data = penguins, aes(x = bill_length_mm, y = body_mass_g)) + geom_point(color = "blue")
```

In the original code, `color = "blue"` was inside the AES statement, which set the color aesthetic to a string "blue". ggplot2 maps this string to a default value (the reddish-pink color). If we move the `color = "blue"` statement into `geom_point()`, then this specifies that we want all points to be a constant blue color, instead of mapping color to a variable that has constant value "blue" (which isn't interpreted by ggplot2 to indicate a color).

:::
:::

### Layers


One of the main advantages of ggplot2 is that the syntax is basically consistent across very different types of plots. In base R and matpotlib, this is not the case - you have to look up the available options for each different plot type. In ggplot2, I might have to look up what the aesthetic names are for a specific geom, but I can guess most of the time. So let's look a bit more into what ggplot2's approach to graph specification is and what it allows us to do.

You're fairly used to the syntax of the pipe by now; but ggplot works on a slightly different (but similar) concept that we've used implicitly up until this point. There is the initial plot statement, `ggplot()`, and successive layers are added using `+`. 

You can specify a data set and aesthetic variables in the `ggplot()` statement (which is what we'll usually do), but you can also have a completely blank `ggplot()` statement and specify your aesthetic mappings and data sets for each layer separately. This approach is more useful when you start creating complex plots, because you may need to plot summary information and raw data, or e.g. separate tables with city information, geographic boundaries, and rivers, all of which need to be represented in the same map. Technically, you can even specify the `aes()` statement outside of the `ggplot()` statement or a `geom_...()` layer call... but this is not typically done because auto complete then doesn't work.

In this extended example, we'll examine the different features we need to make a map and how to add new layers to a map. We'll also look at some new geoms: `geom_polygon` and `geom_path`.

#### Data Setup

Let's use some data from the state of Nebraska to generate a state map with important geographic features: state parks, railroads, and counties.

- [State parks](https://www.nebraskamap.gov/datasets/outdoornebraska::state-park-areas-1/explore?location=41.485819%2C-99.571578%2C7.17)  (I downloaded the GeoJSON file)
- [Railroads](https://www.nebraskamap.gov/datasets/railroads/explore?location=41.929514%2C-102.243474%2C6.05) (I downloaded the GeoJSON file)
- [County boundaries](https://www.nebraskamap.gov/datasets/county-boundaries/explore?location=41.369872%2C-99.634627%2C6.00)

::: panel-tabset
##### R

```{r read-in-neb-map-data-r}
if(!"sf" %in% installed.packages()) install.packages("sf")
library(sf)
library(ggplot2)

ne <- map_data("state", "nebraska") # state outline, built into R
ne_parks <- read_sf("data/State_Park_Areas.geojson")
ne_railroads <- read_sf("data/Railroads.geojson")
ne_counties <- read_sf("data/County_Boundaries.geojson")
```

##### Python
```{python read-in-neb-map-data-py}
# This installs the package in the current python environment
# %pip install geopandas
# (uncomment the line above to use)
import geopandas as gp

ne = r.ne # state outline (steal from R)
ne_parks = gp.read_file("data/State_Park_Areas.geojson")
ne_railroads = gp.read_file("data/Railroads.geojson")
ne_counties = gp.read_file("data/County_Boundaries.geojson")
```
:::

#### Data Exploration

We're working with GIS data (geographical information systems), which has a different format than most of the data we've worked with thus far. Geographic data tends to be nested, so that e.g. a railroad segment will contain a set of lat/long coordinates that define the segment, but there may be many different segments in a continuous track. 

Let's see how each of these data types are represented by doing a bit of EDA. 

First, let's look at the `ne` object, which contains the coordinates for the border of the state.
::: panel-tabset
##### R
```{r explore-map-data-r1}
head(ne)
```

##### Python
```{python explore-map-data-py}
ne.describe
```
:::

We have a series of latitude and longitude values, with a group variable and an order. That is, `group` defines which piece of the state we're working with (this is especially important in the case of states with disjoint regions, such as Michigan or Hawaii), and `order` defines the order in which the points are to be connected. This is important - it matters which order we connect the points.

The `ne` object is a bit lower-level than the objects containing the spatial information about parks, railroads, and counties. We've used the `sf` and `geopandas` packages, which store all of the data from the geojson file in a table-like structure, but under the hood, these objects are a bit more complicated. We're going to completely ignore these complexities for the moment.

::: panel-tabset
##### R
```{r explore-map-data-r2}
head(ne_parks)
head(ne_railroads)
head(ne_counties)
```

##### Python
```{python explore-map-data-py2}
ne_parks.describe
ne_railroads.describe
ne_counties.describe
```
:::

#### Plotting the state
The state is a good example of a polygon - it's a set of points which are connected and define the border of a region. Now, Nebraska is pretty boring, because we don't have any islands (ok, you could probably fill in a lot of things instead of islands in that sentence). But, in general, it's important to make sure that when dealing with generic polygons, we only connect points from the same polygon. Otherwise, you end up with a map like this:

```{r fail-connected-polygons-r, echo = F}
usa <- map_data("state", region = ".")
ggplot() + 
  geom_polygon(data = usa, aes(x = long, y = lat), fill = "white", color = "black")
```

::: panel-tabset
##### R
```{r polygon-r-state}
library(ggplot2)
library(mapproj)

ggplot() + 
  geom_polygon(data = ne, aes(x = long, y = lat, group = group), fill = "white", color = "black") + 
  coord_map() # This forces the right aspect ratio
```

##### Python
```{python polygon-py-state}
from plotnine import *

ggplot() + geom_polygon(aes(x = "long", y = "lat", group = "group"), data = ne, fill = "white", color = "black")
# coord_map isn't implemented in plotnine :(
```
:::

#### Plotting counties

::: panel-tabset
##### R
```{r polygon-r-county}
library(ggplot2)
library(mapproj)

ggplot() + 
  # geom_sf automatically uses lat/long and the type of data to choose the right geom
  geom_sf(data = ne_counties) + 
  coord_sf() # This forces the right aspect ratio
```

We could even add annotations to the counties showing what the county names are, if we want to do so - this requires a call to `geom_sf_text`, and an additional aesthetic mapping to label (the value of the text we're printing). The geographic centroid operation is handled automatically behind the scenes.

```{r polygon-r-county2}
ggplot() + 
  # geom_sf automatically uses lat/long and the type of data to choose the right geom
  geom_sf(data = ne_counties) + 
  geom_sf_text(data = ne_counties, aes(label = Cnty_Name), size = 2) + 
  coord_sf() # This forces the right aspect ratio
```

##### Python
```{python polygon-py-county}
from plotnine import *
import geopandas as gp

ggplot() + geom_map(data = ne_counties)
```

In python, it requires a bit more work to handle county names - we have to define a function to give us the centroid of each region. 

```{python polygon-py-county2}
from plotnine import *
import geopandas as gp

# from plotnine docs: https://plotnine.readthedocs.io/en/stable/generated/plotnine.geoms.geom_map.html?highlight=coord_map
def calculate_center(df):
  """
  Calculate the centre of a geometry

  This method first converts to a planar crs, gets the centroid
  then converts back to the original crs. This gives a more
  accurate
  """
  original_crs = df.crs
  planar_crs = 'EPSG:3857'
  return df['geometry'].to_crs(planar_crs).centroid.to_crs(original_crs)

ne_counties['center'] = calculate_center(ne_counties)

ggplot() + geom_map(data = ne_counties, fill = "#f0f0f0") +\
geom_text(ne_counties, aes("center.x", "center.y", label = 'Cnty_Name'), size = 5)

```
:::


#### Adding Polygons

Next, let's add some park information to our map. 

::: panel-tabset
##### R
```{r polygon-r-park}
library(ggplot2)
library(mapproj)

ggplot() + 
  # geom_sf automatically uses lat/long and the type of data to choose the right geom
  geom_sf(data = ne_counties) + 
  geom_sf(data = ne_parks, fill = "green", color = "darkgreen") + 
  coord_sf() # This forces the right aspect ratio
```


##### Python
```{python polygon-py-park}
from plotnine import *
import geopandas as gp

ggplot() +\
geom_map(data = ne_counties, fill = "#fafafa") +\
geom_map(data = ne_parks, color = "darkgreen", fill = "green")
```
:::

#### Adding Lines

So far, everything we've plotted on our map has been related to polygons. Not all geometric objects are polygons, though - railroads and rivers are (usually) lines, and points of interest may be actual points and not spatial regions. We can add this additional information by including extra layers on our plot.


::: panel-tabset
##### R
```{r polygon-r-railroad}
library(ggplot2)
library(mapproj)

ggplot() + 
  # geom_sf automatically uses lat/long and the type of data to choose the right geom
  geom_sf(data = ne_counties, fill = "white", color = "grey80") + 
  geom_sf(data = ne_parks, fill = "green", color = "darkgreen") + 
  geom_sf(data = ne_railroads, color = "black") + 
  coord_sf() # This forces the right aspect ratio
```


##### Python
```{python polygon-py-railroad}
from plotnine import *
import geopandas as gp

ggplot() +\
geom_map(data = ne_counties, fill = "#ffffff", color = "#f0f0f0") +\
geom_map(data = ne_parks, color = "darkgreen", fill = "green") +\
geom_map(data = ne_railroads, color = "black")
```
:::


::: {.callout-tip collapse = "true"}

### Try it out: Maps of Middle Earth
Dedicated fans have re-created middle earth in digital format using ArcGIS files. These map file formats, called shape files, can be read into R and plotted.

You may need to install a few spatial packages first ([Mac and Windows](http://www.nickeubank.com/wp-content/uploads/2015/10/RGIS1_SpatialDataTypes_part0_setup.html), [Linux](https://philmikejones.me/tutorials/2014-07-14-installing-rgdal-in-r-on-linux/))

The `sf` package in R contains a special geom, `geom_sf`, which will plot map objects with an appropriate geom, whether they are points, lines, or polygons. In complicated maps with many layers, this is a really awesome feature. Similarly, if you have `geopandas` in python, `plotnine`'s `geom_map` function will work with geopandas tables. 

I've provided some code to get you started, but there are many other shapefiles in the dataset. Pick some layers which you think are interesting, and plot them with appropriate geoms to make a map of Middle Earth. 

Unfortunately, in this map there is not an underlying polygon (the coastline is a series of shorter segments). To resolve this, I have provided a theme statement that will have a white background, so that you can add useful layers without the grey grid background. 

```{r middle-earth-map}
library(ggplot2)
library(ggthemes)
library(sf)

if (!file.exists("data/MiddleEarthMap.zip")) {
  download.file("https://github.com/jvangeld/ME-GIS/archive/master.zip", "data/MiddleEarthMap.zip", mode = "wb")
}
if (!dir.exists("data/ME-GIS-master/")) {
  unzip("data/MiddleEarthMap.zip", exdir = "data/")
}

coastline <- read_sf("data/ME-GIS-master/Coastline2.shp")
cities <- read_sf("data/ME-GIS-master/Cities.shp")
forests <- read_sf("data/ME-GIS-master/Forests.shp")
lakes <- read_sf("data/ME-GIS-master/Lakes.shp")
rivers <- read_sf("data/ME-GIS-master/Rivers.shp")
roads <- read_sf("data/ME-GIS-master/Roads.shp")

ggplot() + 
  geom_sf(data = coastline) + 
  geom_sf(data = forests, color = NA, fill = "darkgreen", alpha = .2) + 
  geom_sf(data = rivers, color = "blue", alpha = .1) + 
  geom_sf(data = lakes, fill = "blue", color = NA, alpha = .2) + 
  theme_map()
```

:::


### Statistics and Plot Types


At this point, we've primarily looked at charts which have two continuous variables - scatter plots, and line plots. There are a number of situations where these types of charts are inadequate. For one thing, we might want to only look at the distribution of a single variable. Or, we might want to look at how a continuous response variable changes when the level of a categorical variable changes. In this section, we'll hit the most common types of plots, but there are almost infinite variations. Sites like [the Data Viz Catalogue](https://datavizcatalogue.com/search.html) can be useful if you're trying to accomplish a specific task and want to know what type of plot to use. 

In all of the plots which we discuss in this section, there is an implicit statistical function applied to the data before plotting. So while you may specify e.g. `x = var1`,  what is plotted is `f(var1)`, where `f()` might be the mean/median/quartiles, a binned count, or a computed kernel density. 

In ggplot2, you can formally specify a statistic by using `stat_xxx` functions, but many geoms implicitly call these same functions. 


#### Box Plots, Violin Plots, and other alternatives

A box plot can show some summary information about the distribution of a single continuous variable, and usually is used to show differences in the level of a response variable at different levels of a categorical variable. 


Let's look at the distribution of penguin weight by species and sex. 
We'll return to this plot later when discussing how to create good charts.

::: callout-note
It's at this point in the chapter that I gave up trying to do everything in `matplotlib`. `Matplotlib` is the low-level plotting library, and when computing statistics and creating these types of plots, it's ... not ideal. I will instead demonstrate `plotnine`, which is grammar-of-graphics style, and [`seaborn`](https://seaborn.pydata.org/) [@waskomSeaborn2022], which is another plotting library in python that isn't strictly grammar-of-graphics but is at least somewhat higher level than `matplotlib`.

While standard `seaborn` isn't a grammar-of-graphics interface, it appears that the next generation of the package will be much more grammar-of-graphics like. [@waskomNextgenerationSeabornInterface2022]
:::

::: panel-tabset

##### ggplot2
```{r boxplot-ggplot-r}
library(ggplot2)
library(palmerpenguins)
library(dplyr)

penguins %>%
  filter(!is.na(sex)) %>% # Remove unknown sex penguins
  ggplot(aes(x = species, y = body_mass_g, color = sex)) + 
  geom_boxplot(outlier.shape = NA) + 
  # We can add another layer overlaying the actual points, 
  # with some random noise added to reduce overplotting
  geom_jitter(position = position_jitterdodge(), shape = 1) + 
  ylab("Body Mass (g)") + xlab("Species") + ggtitle("Penguin Weight by Species and Sex")
```


##### plotnine
```{python boxplot-plotnine-py}
import pandas as pd
from plotnine import *
from palmerpenguins import load_penguins
penguins = load_penguins()

# Remove NAs
tmp = penguins.dropna(axis = 0, subset = 'sex')

ggplot(aes(x = "species", y = "body_mass_g", color = "sex"), data = tmp) +\
geom_boxplot(outlier_shape='') +\
geom_jitter(position = position_jitterdodge(), shape = 'o') +\
ggtitle("Penguin Weight by Species and Sex") +\
ylab("Body Mass (g)") +\
xlab("Species")

```

##### Base R

Because base R doesn't have a default way to handle jittering or putting boxplots side-by-side, it's not easy to add points on top of these boxplots.

```{r boxplot-base-r}
boxplot(body_mass_g ~ species + sex, data = penguins, 
        # Manually color boxplots
        col = rep(c("red", "blue"), times = 3))
```

##### Seaborn

```{python boxplot-seaborn}
# Install and load the seaborn package
#!pip install seaborn; the alias "sns" stands for 
# Samuel Norman Seaborn from "The West Wing" television show
import seaborn as sns
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

# Initialize seaborn styling; context
sns.set_style('white')
sns.set_context('notebook')

sns.boxplot(x = penguins['species'], y = penguins['body_mass_g'], hue = penguins['sex'])
plt.show()
```

:::


There are other plots which can be used in place of box plots. One interesting alternative is a **violin plot**, which shows the full density of the data, reflected (usually in y) to form an object which could potentially look like a violin for e.g. bimodal data.


Seaborn has options to split the violin plots by sex - this is  a bit trickier in ggplot2 but it [can be done](https://stackoverflow.com/questions/35717353/split-violin-plot-with-ggplot2) with the help of the `introdataviz` package available on GitHub.

::: panel-tabset

##### ggplot2
```{r violinplot-ggplot-r}
library(ggplot2)
library(palmerpenguins)
library(dplyr)

penguins %>%
  filter(!is.na(sex)) %>% # Remove unknown sex penguins
  ggplot(aes(x = species, y = body_mass_g, color = sex)) + 
  geom_violin(outlier.shape = NA) + 
  # We can add another layer overlaying the actual points, 
  # with some random noise added to reduce overplotting
  geom_jitter(position = position_jitterdodge(), shape = 1) + 
  ylab("Body Mass (g)") + xlab("Species") + ggtitle("Penguin Weight by Species and Sex")
```
```{r violinplot-ggplot-r-split}
# devtools::install_github("psyteachr/introdataviz")
library(introdataviz)

penguins %>%
  filter(!is.na(sex)) %>% # Remove unknown sex penguins
  ggplot(aes(x = species, y = body_mass_g, color = sex)) + 
  geom_split_violin() + 
  # We can add another layer overlaying the actual points, 
  # with some random noise added to reduce overplotting
  geom_jitter(position = position_jitterdodge(), shape = 1) + 
  ylab("Body Mass (g)") + xlab("Species") + ggtitle("Penguin Weight by Species and Sex")
```

##### Seaborn

```{python violinplot-seaborn}
# Install and load the seaborn package
#!pip install seaborn; the alias "sns" stands for 
# Samuel Norman Seaborn from "The West Wing" television show
import seaborn as sns
import matplotlib.pyplot as plt
plt.cla() # clear out matplotlib buffer

# Initialize seaborn styling; context
sns.set_style('white')
sns.set_context('notebook')

sns.violinplot(data = penguins, x = 'species', y = 'body_mass_g', hue = 'sex', split = True)
plt.show()
```



:::

#### Histograms and Density Plots

Box plots aren't the only way to show distributions. If we want to, we can show distributions using histograms or density plots. A **histogram** is created by binning the variable, then counting the number of observations that fall within each specified range.
Usually, these ranges have constant width (but not always). 

Changing the binwidth can radically change the appearance and usefulness of the histogram.


::: panel-tabset
##### ggplot2
```{r gg-hist-r}
penguins %>%
  ggplot(aes(x = body_mass_g)) + 
  geom_histogram(color = "black", fill = "grey")

penguins %>%
  ggplot(aes(x = body_mass_g)) + 
  geom_histogram(color = "black", fill = "grey", binwidth = 60)

penguins %>%
  ggplot(aes(x = body_mass_g)) + 
  geom_histogram(color = "black", fill = "grey", binwidth = 300)
```
##### plotnine
```{python plotnine-hist-py}
ggplot(penguins.dropna(axis = 0, subset='body_mass_g'), aes(x = "body_mass_g")) + geom_histogram(color = "black", fill = "grey")
  
ggplot(penguins.dropna(axis = 0, subset='body_mass_g'), aes(x = "body_mass_g")) + geom_histogram(color = "black", fill = "grey", binwidth = 60)
  
ggplot(penguins.dropna(axis = 0, subset='body_mass_g'), aes(x = "body_mass_g")) + geom_histogram(color = "black", fill = "grey", binwidth = 300)
```
##### Base R

##### Seaborn

:::

### Beyond Points: Lines, Rectangles, and Other Geoms

There are many situations where points aren't the best way to display data. If we have several series of data connected over e.g. time, then we might want to join our individual observations with lines that suggest continuity. Or, we may want to display a range of values over each time point, at which point we might be better off with a ribbon-like area enclosing the maximum and minimum values over time. 

In the grammar of graphics, we need to select a geometric object and then provide variable mappings for each required spatial dimension. When working with non-grammar approaches, however, these different plots sometimes use very different syntax. 

#### Lines


::: callout-note
### Graph Galleries and Cheat Sheets

- [R Graph Gallery](https://r-graph-gallery.com/)
- [Python Graph Gallery](https://www.python-graph-gallery.com/)

- [Python graph library cheat sheets](https://www.python-graph-gallery.com/cheat-sheets/)
- [Ggplot2 cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)
- [Base R graphics cheat sheet](https://r-graph-gallery.com/134-general-plot-parameters-reminder.html)
:::

## References
