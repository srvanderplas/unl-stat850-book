
# Introduction to Statistical Programming {#intro-prog}

The only way to learn how to program effectively is to take something that works, break it, and then fix it again. There's plenty of theory and you should definitely learn that, but fundamentally, if you are not regularly breaking code, you're probably not programming.

```{r out.width = "50%", echo = F}
#| fig.cap: "This is the class in picture form"
#| fig.alt: "A parody of the O'Reilly programming books (O RLY?) called 'Changing Stuff and Seeing What Happens' with the subtitle 'How to actually learn any new programming concept'. A black-and-white kitten is featured on the cover."
knitr::include_graphics('images/intro-prog/learning_to_code_Orly.jpeg')
```

The goal for this chapter (and several chapters to come) is that you can modify example code and adapt it to the problem at hand. This is the best way to learn how to program, but it means you may break the code and not know how to fix it. If that happens, please try the following steps:

1.  Google the error and see if you can understand why it happened.
2.  Consult with a classmate to see if they can understand where things broke.
3.  Post to the discussion board and see if anyone in the class can understand where things broke.\
    (When you do this, post all of the code relevant to the problem, and the error you're getting, so that your classmates can replicate the problem)

If you do not hopelessly break code during this chapter, then please do your best to help others who may not have previously programmed (or previously programmed in these languages). While writing this chapter, I came across about 10 errors in SAS that I'd never encountered before.

If all else fails, while you're waiting for someone to help you figure out what an error message means... [try this approach](https://xkcd.com/1024/).

## Module Objectives {#module-2-objectives .unnumbered}

-   Create a program flow map by breaking a problem down into smaller steps
-   Write basic scripts to solve mathematical problems with variables, control structures, and scalar/matrix algebra

More informally, the goal is to get familiar with the basics of each programming language, and to show you where to find references for how to use each command -- because (at least) half of programming is knowing where to look something up.

## Definitions {.unnumbered}

Many programming resources talk about 3, or 5, or 10 core concepts in any programming language. In this module, we're going to discuss the generic concepts, and then how these concepts are implemented in the languages we're working with.

Interestingly, the "core concepts" aren't necessarily the same across lists. Here is a consensus list of concepts which are generic across languages and usually important[@pageBasicProgrammingConcepts2021,@mukitBasicProgrammingConcepts2018,@holowczakProgrammingConceptsBrief2013,@fenjvesComputerLanguageFundamentals2016,@asayBasicProgrammingConcepts2005]:

1.  **Variables**    
a symbolic name or reference to some kind of information. In the expression `a + b > a`, both `a` and `b` are variables. Variables may have a specific type (what data can be stored in the variable), scope (where the variable can be accessed), location (in memory). [Here](https://dev.to/lucpattyn/basic-programming-concepts-for-beginners-2o73) is a nice explanation of the difference between variables in programming and variables in math.

2.  **Conditional statements** (if statements)    
These statements allow the program to handle information adaptively - if a statement is true, one set of instructions will be used, and if the statement is false, a different set of instructions will be used.

3.  **Looping and iteration**    
An iteration is any time a sequence of steps is executed. Most languages have several different types of loops or iteration: `for` loops, which allow for the sequence of steps to be executed a specific number of times, `while` loops, which allow for the sequence of steps to be executed while a conditional statement is true, `recursion`, where a block of code calls itself.

4.  **Data types and data structures**    
these concepts determine what information a variable can hold. Data types are lower-level, simple objects (floating-point numbers, integers, boolean T/F, characters, strings). Data structures may include lists (sequences of many objects) and vectors (sequences of many objects of the same type), dictionaries (a list of key-value pairs), objects (data structures which may hold multiple related pieces of information).

5.  **Functions**    
self-contained modules of code that accomplish a particular task.

6.  **Syntax**    
The set of rules that define which combinations of symbols consist of correctly structured and interpretable commands in the language.

7.  **Tools**    
The set of external programs which may help with development and writing code. Some common tools are IDEs (Integrated Development Environments), which may correct syntax and typos, organize files for you, allow you to keep track of which variables you have defined, and assist you with code organization and navigation. Other tools include compilers (which take human-written code and translate it into efficient machine code), version control systems (which help you track changes to code over time), debuggers, and documentation generators. Not all of these tools are necessary for all languages - scripting languages such as python and R do not require compilers by default, for instance.

8.  **Sequence of commands**    
It's important to have the right commands in the right order. 

::: {#fig-sequence-commands}

<iframe width="560" height="315" src="https://www.youtube.com/embed/Ct-lOOUqmyY" title="YouTube video player" frameborder="0" allow="accelerometer; picture-in-picture" allowfullscreen></iframe>

It's important to get both the level of specificity and the order of the commands just right when programming.
:::


## Breaking Problems Down

The most fundamental part of programming that you will need to learn in this class is how to break down a big problem into smaller (hopefully solvable) problems. [This post](https://medium.com/@dannysmith/breaking-down-problems-its-hard-when-you-re-learning-to-code-f10269f4ccd5) is a great example of the process of breaking things down for programming, but the same concept applies outside of programming too!


::: ex

::: panel-tabset

### Scenario {- .unnumbered}

My spouse and I recently decided to replace our shower curtain with glass doors because the curtain didn't really prevent water from getting all over the floor.

We went to the store and picked out the parts, and the installation instructions broke the steps down like this:

1.  Install the base of the track

2.  Install the top of the track

3.  Hang shower doors

4.  Add hardware to shower doors

So we started in on the instructions, only to find out that when our house was built, our shower wasn't leveled properly.

### Brainstorming Solutions {- .unnumbered}

The instructions had a solution - we could send off for a \$300 custom part that would level our floor, but we'd have to wait at least 4-6 weeks for them to make and ship the part to us. At this point, we'd already taken apart the shower and bought the shower door, so having the bathroom out of commission for 4-6 weeks was not appealing.

We're both programmer-adjacent, so we started thinking through how we could deal with our problem a different way. We considered ignoring the instructions -- our shower was about 1/8" off of level, surely that couldn't be so important, right? My spouse is a bit more ... detail oriented ... than I am, so he wasn't good with that suggestion.

We considered adding a ton of caulk or plaster to try to level the shower out. But we figured that 1) probably wouldn't work, and 2) would look awful.

Finally, I suggested that my spouse 3D print sections of track-leveler using our 3D printer. Now, this isn't an option for most people, but it is for us - we have a small 3D printer, and my husband knows how to use OpenSCAD to create very accurate, custom dimension 3D printer files. He tested things out a few times, and printed up a series of 12 \~5" sections that, when assembled, were equivalent to the \$300 custom part we could have ordered. He added those sections to the shower, caulked them in, and proceeded with the rest of the installation.

### Conclusion {- .unnumbered}

Because we had a list of subproblems (steps for installation), we could focus our efforts on debugging the one problem we had (not level shower ledge) and we didn't have to get bogged down in "it's impossible to get this job done". 

We knew that if we could solve the little problem, we'd be able to get the bigger job done. Programming is just like this - if you can break your problem down into steps (and not steps with code), you can think through how to solve a single step of the problem before you worry about the next step.

:::

:::

One tool that is often used to help break a problem down is a [flowchart](https://www.programiz.com/article/flowchart-programming).
In a flowchart, each step in a process is described in sequential order, with decisions represented as forks in the "flow". 

One tool that I often use to make flowcharts and other diagrams/sketches while programming is [Excalidraw](https://excalidraw.com).


### Try it out {- .unnumbered .tryitout}

The biggest advantage to breaking problems down into smaller steps is that it allows you to focus on solving a small, approachable problem.

Let's think through an example:

::: panel-tabset

#### Problem

Print out a pyramid of stars, 10 lines high.

Yes, I remember, I haven't taught you how to write any code yet. Don't worry about code right now - let's just think about how we might create a pyramid of stars.

Start by doing the task manually on paper or in a text editor. Observe the steps you go through and think about how you might generalize those steps.

#### Manual Solution

First, we have to think about what we would need to make a pyramid of stars. So let's make a miniature one by hand (I'm using - for spaces here to make things visible):

    ---*---
    --***--
    -*****-

To make my miniature star pyramid, I started out by adding space on the first line, then a star, then more space. When I moved to the next line, I added space, but one less space than I'd added before, and then 3 stars, and then more space.

#### Analysis

Examining the manual solution, it seems we can break our problem down into two(ish) components:

-   How much space? (one side)
-   How many stars?
-   (redundant piece) How much space (the other side).

Thinking my way through how I created my manual pyramid, I realized that I was adding $n$ spaces (where $n$ is the total number of rows) on the first line, and then $n - i$ spaces on subsequent lines, if we start with i=0.

But I am an R programmer, so we start with $i=1$, which means I need to have $n - i + 1$ spaces on each row first.

Then, for $i=1$ the first row, we have $2*i - 1$ stars - i = 1, stars = 1, then i = 2, stars = 3, then i = 3, stars = 5.... you can do the regression if you want to, but it's pretty easy to see the relationship.

Finally, we have to (in theory) add the same amount of space on the other side -- strictly speaking, this is optional, but it makes the lines the same length, so it is nice.

#### Program Flow Map

![Program flow map for stars](images/intro-prog/prog-flow-pyramid-stars.svg)

#### Formal Solution

If we want a pyramid that is $n$ rows high, we might think of creating it by using the following line-by-line formula, where $i$ is our current line:

$n - i +1$ spaces, $2i - 1$ stars, $n - i + 1$ spaces

Working this out in a small example helped me come up with that formula; now, I can write a "loop":

-   line 1: i = 1, n = 10, 10 spaces, 1 star, 10 spaces
-   line 2: i = 2, n = 10, 9 spaces, 3 stars, 9 spaces
-   line 3: i = 3, n = 10, 8 spaces, 5 stars, 8 spaces
-   line 4: i = 4, n = 10, 7 spaces, 7 stars, 7 spaces
-   ...
-   line n: i = n, n = 10, 1 space, 19 stars, 1 space

:::

## Overgrown Calculators

While R, SAS, and Python are all extremely powerful statistical programming languages, the core of most programming languages is the ability to do basic calculations and matrix arithmetic. As almost every dataset is stored as a matrix-like structure (data sets and data frames both allow for multiple types, which isn't quite compatible with more canonical matrices), it is useful to know how to do matrix-level calculations in whatever language you are planning to use to work with data.

In this section, we will essentially be using our programming language as overgrown calculators.

In the next chapters we'll talk about data types and structures, so you'll get to see more about matrices and arrays, but for now, let's confine ourselves to using R and python to do basic math calculations.


| Operation                    | R      | SAS                             | Python     |
|:---------|:-------|:-------|:-------|
| Addition                     | \+     | \+                              | \+         |
| Subtraction                  | \-     | \-                              | \-         |
| Elementwise Multiplication   | \*     | \#                              | \*         |
| Division                     | \\     | \\                              | \\         |
| Elementwise Exponentiation   | \^     | \##                             | `**`       |
| Matrix/Vector Multiplication | %\*%   | \*                              |  `np.dot()`          |
| Matrix Exponentiation        | \^     | \*\*                            | `np.exp()` |
| Matrix Transpose             | `t(A)` | `A`\` | `np.transpose(A)` |            |
| Matrix Determinant | `det(A)` | `det(A)` | `np.linalg.det(A)` |
| Matrix Diagonal | `diag(A)` | `diag(A)` | `np.linalg.diag(A)` |
| Matrix Inverse | `solve(A)` | `solve(A, diag({...}))` | `np.linalg.inv(A)` |

: Table of common mathematical and matrix operations in R, SAS, and Python. {#tbl-math-ops}


### Basic Mathematical Operators 

::: panel-tabset

#### R {.unnumbered}

```{r math-operators-sas}
x <- 1:10
y <- seq(3, 30, by = 3)

x + y
x - y
x * y
x / y
x^2
t(x) %*% y
```

#### Python {.unnumbered}

```{python}
import numpy as np

x = np.array(range(1, 11))
y = np.array(range(3, 33, 3)) # python indexes are not inclusive

x + y
x - y
x * y
x / y
x ** 2
np.dot(x.T, y)
```

#### SAS {.unnumbered}

By default, SAS creates row vectors with `do(a, b, by = c)` syntax. The transpose operator (a single backtick) can be used to transform `A` into `A`\`.

    proc iml; 
      x = do(1, 10, 1);
      y = do(3, 30, 3);

      z = x + y;
      z2 = x - y;
      z3 = x # y;
      z4 = x/y;
      z5 = x##2;
      z6 = x` * y;
      print z, z2, z3, z4, z5, z6;
    quit;
:::

### Matrix Operations

Other matrix operations, such as determinants and extraction of the matrix diagonal, are similarly easy:

::: panel-tabset

#### R {.unnumbered}

```{r matrix-operations}
mat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)
mat
t(mat) # transpose
det(mat) # get the determinant
diag(mat) # get the diagonal
diag(diag(mat)) # get a square matrix with off-diag 0s
diag(1:3) # diag() also will create a diagonal matrix if given a vector
```

#### Python {.unnumbered}

```{python matrix-operations-py}
import numpy as np
mat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')

mat
mat.T
np.linalg.det(mat) # numerical precision...
np.diag(mat)
np.diag(np.diag(mat))
np.diag(range(1, 4))
```

#### SAS {.unnumbered}

    proc iml;
      mat = {1 2 3, 6 4 5, 7 8 9}; 
      tmat = mat`; /* transpose */
      determinant = det(mat); /* get the determinant */
      diagonal_vector = vecdiag(mat); /* get the diagonal as a vector */
      diagonal_mat = diag(mat); /* get the diagonal as a square matrix */
                                /* with 0 on off-diagonal entries */
      
      dm = diag({1 2 3}); /* make a square matrix with vector as the diagonal */
      
      print tmat, determinant, diagonal_vector, diagonal_mat, dm;
    quit;
:::


### Matrix Inverse

The other important matrix-related function is the inverse. In R, `A^-1` will get you the elementwise reciprocal of the matrix. Not exactly what we'd like to see... Instead, in R and SAS, we use the `solve()` function. The inverse is defined as the matrix B such that `AB = I` where `I` is the identity matrix (1's on diagonal, 0's off-diagonal). So if we `solve(A)` (in R) or `solve(A, diag(n))` in SAS (where n is a vector of 1s the size of A), we will get the inverse matrix. In Python, we use the `np.linalg.inv()` function to invert a matrix, which is a bit more linguistically familiar.

::: panel-tabset
#### R {.unnumbered}

```{r invert-matrix-example}
mat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)

minv <- solve(mat) # get the inverse

minv
mat %*% minv 
```

#### Python {.unnumbered}

```{python invert-matrix-example-py}
import numpy as np
mat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')

minv = np.linalg.inv(mat)
minv
np.dot(mat, minv)
np.round(np.dot(mat, minv), 2)
```

#### SAS {.unnumbered}

[Documentation](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_langref_sect208.htm&docsetVersion=14.2&locale=en)

```
    proc iml;
      mat = {1 2 3, 6 4 5, 7 8 9};

      mat_inv = solve(mat, diag({1 1 1})); /* get the inverse */
      mat_inv2 = inv(mat); /* less efficient and less accurate */
      print mat_inv, mat_inv2;

      id = mat * mat_inv;
      id2 = mat * mat_inv2;
      print id, id2; 
    quit;
```

:::


## Scripts and Notebooks

In this class, we'll be using quarto markdown notebooks to keep our code and notes in the same place. One of the advantages of both R and Python is that they are both scripting languages, but they can be used within notebooks as well. This means that you can have an R script file or a python script file, and you can run that file, but you can also create a document (like the one you're reading now) that has code AND text together in one place. This is called [literate programming](https://en.wikipedia.org/wiki/Literate_programming) and it is a very useful workflow both when you are learning programming and when you are working as an analyst and presenting results.

### Scripts

Before I show you how to use literate programming, let's look at what it replaces: scripts. **Scripts** are files of code that are meant to be run on their own. They may produce results, or format data and save it somewhere, or scrape data from the web -- scripts can do just about anything.

Scripts can even have documentation within the file, using `#` characters (at least, in R and python) at the beginning of a line. `#` indicates a comment -- that is, that the line does not contain code and should be ignored by the computer when the program is run. Comments are incredibly useful to help humans understand what the code does and why it does it.

::: ex
#### Plotting a [logarithmic spiral](https://mathworld.wolfram.com/LogarithmicSpiral.html)

This code will use concepts we have not yet introduced - feel free to tinker with it if you want, but know that you're not responsible for being able to **write** this code yet. You just need to read it and get a sense for what it does. I have heavily commented it to help with this process.

::: panel-tabset
##### R {.unnumbered}

```{r}
#| label: fig-polar-r
#| fig-cap: "A Cartesian Spiral in R"
# Define the angle of the spiral (polar coords)
# go around two full times (2*pi = one revolution)
theta <- seq(0, 4*pi, .01) 
# Define the distance from the origin of the spiral
# Needs to have the same length as theta
r <- seq(0, 5, length.out = length(theta))

# Now define x and y in cartesian coordinates
x <- r * cos(theta)
y <- r * sin(theta)

plot(x, y, type = "l")

```

I have saved this script [here](files/markdown-spiral-script.R). You can download it and open it up in RStudio (File -\> Open -\> Navigate to file location).

##### Python {.unnumbered}

```{python}
#| label: fig-polar-py
#| fig-cap: "A Cartesian Spiral in python"

import numpy as np
import matplotlib.pyplot as plt

# Define the angle of the spiral (polar coords)
# go around two full times (2*pi = one revolution)
theta = np.arange(0, 4 * np.pi, 0.01)
# Define the distance from the origin of the spiral
# Needs to have the same length as theta 
# (get length of theta with theta.size, 
#  and then divide 5 by that to get the increment)
r = np.arange(0, 5, 5/theta.size)

# Now define x and y in cartesian coordinates
x = r * np.cos(theta)
y = r * np.sin(theta)

# Define the axes
fig, ax = plt.subplots()
# Plot the line
ax.plot(x, y)
plt.show()
```

I have saved this script [here](files/markdown-spiral-script.py). You can download it and open it up in RStudio (File -\> Open -\> Navigate to file location).
:::
:::

Scripts can be run in Rstudio by clicking the Run button ![RStudio run button](images/intro-prog/Run-button-Rstudio.png) at the top of the editor window when the script is open.

::: tryitout
#### Try it out! 

-   Download the R and python scripts in the above example, open them in RStudio, and run each script using the Run button. What do you see?

-   (Advanced) Open a terminal in RStudio (Tools -\> Terminal -\> New Terminal) and see if you can run the R script from the terminal using `R CMD BATCH path/to/file/markdown-spiral-script.R` (You will have to modify this command to point to the file on your machine)\
    Notice that two new files appear in your working directory: `Rplots.pdf` and `markdown-spiral-script.Rout`

-   (Advanced) Open a terminal in RStudio (Tools -\> Terminal -\> New Terminal) and see if you can run the R script from the terminal using `python3 path/to/file/markdown-spiral-script.py` (You will have to modify this command to point to the file on your machine)\
    This will require you to have python3 accessible to you on the command line, which may be a challenge if it is not set up in the way that I'm assuming it is. Feel free to make an appointment to see if we can figure it out, if this does not work the first time.
:::

Most of the time, you will run scripts interactively - that is, you'll be sitting there watching the script run and seeing what the results are as you are modifying the script. However, one advantage to scripts over notebooks is that it is easy to write a script and schedule it to run without supervision to complete tasks which may be repetitive. I have a script that runs daily at midnight, 6am, noon, and 6pm to pull information off of the internet for a dataset I'm maintaining. I've set it up so that this all happens automatically and I only have to check the results when I am interested in working with that data.

### Notebooks

Notebooks are an implementation of literate programming. Both R and python have native notebooks that are cross-platform and allow you to code in R or python. This book is written using Quarto markdown, which is an extension of Rmarkdown, but it is also possible to use jupyter notebooks to write R code.

In this class, we're going to use Quarto/R markdown, because it is a much better tool for creating polished reports than Jupyter (in my opinion). This matters because the goal is that you learn something useful for your own coding and then you can easily apply it when you go to work as an analyst somewhere to produce impressive documents. Jupyter notebooks are great for interactive coding, but aren't so wonderful for producing polished results. They also don't allow you to switch between languages mid-notebook, and since I'm trying to teach this class in both R and python, I want you to have both languages available.

::: learn-more
There are some excellent opinions surrounding the use of notebooks in data analysis:

-   [Why I Don't Like Notebooks"](https://docs.google.com/presentation/d/1n2RlMdmv1p25Xy5thJUhkKGvjtV-dkAIsUXP-AL4ffI/preview#slide=id.g362da58057_0_1) by Joel Grus at JupyterCon 2018
-   [The First Notebook War](https://yihui.org/en/2018/09/notebook-war/) by Yihui Xie (response to Joel's talk).\
    Yihui Xie is the person responsible for `knitr` and `Rmarkdown`.
:::

Â 

#### Try it out {.tryitout}

::: panel-tabset
##### R markdown

Take a look at the [R markdown sample file](files/markdown-demo.Rmd) I've created to go with the R script above. You can see the HTML file it generates [here](files/markdown-demo.html).

-   Download the Rmd file and open it with RStudio.

-   Change the output to `output: word_document` and hit the Render button ![Render button in RStudio](images/intro-prog/Render-button-Rstudio.png). Can you find the markdown-demo.docx file that was generated? What does it look like?

-   Change the output to `output: pdf_document` and hit the Render button ![Render button in RStudio](images/intro-prog/Render-button-Rstudio.png). Can you find the markdown-demo.pdf file that was generated? What does it look like?

Rmarkdown tries very hard to preserve your formatted text appropriately regardless of the output document type. While things may not look exactly the same, the goal is to allow you to focus on the content and the formatting will "just work".

##### Jupyter

Take a look at the [jupyter notebook sample file](files/Jupyter-demo.ipynb) I've created to go with the R script above. You can see the HTML file it generates [here](files/Jupyter-demo.html).

-   Download the ipynb file and open it with jupyter.

-   Export the notebook as a pdf file (File -\> Save as -\> PDF via HTML). Can you find the jupyter-demo.pdf file that was generated? What does it look like?

-   Export the notebook as an html file (File -\> Save as -\> HTML). Can you find the jupyter-demo.html file that was generated? What does it look like?

##### Quarto markdown

The nice thing about quarto is that it will work with python and R seamlessly, and you can compile the document using python or R. R markdown will also allow you to use python chunks, but you must compile the document in R.

Take a look at the [Qmd notebook sample file](files/quarto-demo.qmd) I've created to go with the scripts above. You'll notice that it is basically the script portion of this textbook -- that's because I'm writing the textbook in Quarto.

-   Download the qmd file and open it with RStudio

-   Try to compile the file by hitting the Render button ![Render button in RStudio](images/intro-prog/Render-button-Rstudio.png)

-   (Advanced) In the terminal, type in `quarto render path/to/file/quarto-demo.qmd`. Does that render the HTML file? One advantage of this is that using quarto to render the file doesn't require R at the command line. As the document contains R chunks, R is still required to compile the document, but the biggest difference between qmd and rmd is that qmd files are workflow agnostic - you can generate them in e.g. MS Visual Studio Code, compile them in that workflow, and never have to use RStudio.
:::


## Cheat Sheets and Reference Guides {.unnumbered .learn-more}

I kept the classic R reference card by my computer for about 5 years, and referenced it at least once or twice a day for that entire period. There will be other cheat sheets and reference cards scattered through this book because if you can't remember something's name, you might be able to remember where it is on the reference card (or at least, that's how I learned R).

::: panel-tabset


### R {.unnumbered}

-   [R Cheatsheet](https://rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-3.pdf) - this is a simplified cheat sheet offered by RStudio.
-   [R Cheatsheet (classic)](https://cran.r-project.org/doc/contrib/Short-refcard.pdf)

### Python {.unnumbered}

-   [Data Wrangling in Pandas](https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf)
-   [NumPy Cheat Sheet](http://datacamp-community-prod.s3.amazonaws.com/ba1fe95a-8b70-4d2f-95b0-bc954e9071b0)
-   [Data Input in Python](http://datacamp-community-prod.s3.amazonaws.com/72e88aa1-b4f2-4658-9d86-15becf8263df)

### SAS {.unnumbered}

-   [SAS Cheatsheet (from another class like this)](https://sites.ualberta.ca/~ahamann/teaching/renr480/SAS-Cheat.pdf)
-   [SAS Cheatsheet (by SAS)](https://support.sas.com/content/dam/SAS/support/en/books/data/base-syntax-ref.pdf)
-   [SAS Programming for R Users (free book)](https://support.sas.com/content/dam/SAS/support/en/books/free-books/sas-programming-for-r-users.pdf)
:::

## Additional Material {.unnumbered .learn-more}

### Textbooks {- .unnumbered}

-   [R for Data Science](https://r4ds.had.co.nz/) [@grolemundDataScience2017]
-   [Advanced R](http://adv-r.had.co.nz/Introduction.html) [@wickhamAdvanced2019]
    -   In particular, the [Data structures](http://adv-r.had.co.nz/Data-structures.html) chapter

### Other Course Websites {- .unnumbered}

-   Stat 850 at UNL (Bilder): [@bilderStat850Course2019]
-   [Stat 579 at Iowa State](https://stat579-at-isu.github.io/schedule.html): [@hofmannStat579Iowa2020]
-   [Stat 545 at Univ. British Columbia](https://stat545.com/): [@bryanStat545UBC2019]
-   [Introduction to SAS](https://online.stat.psu.edu/statprogram/stat480) - Undergraduate course at Penn State
-   [Intermediate SAS](https://online.stat.psu.edu/statprogram/stat481) - Undergraduate course at Penn State
-   [Advanced SAS](https://online.stat.psu.edu/statprogram/stat482) - Undergraduate course at Penn State

## References {#intro-prog-refs}
