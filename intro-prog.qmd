
# Introduction to Statistical Programming {#intro-prog}

The only way to learn how to program effectively is to take something that works, break it, and then fix it again. There's plenty of theory and you should definitely learn that, but fundamentally, if you are not regularly breaking code, you're probably not programming.

```{r out.width = "50%", echo = F}
#| fig.cap: "This is the class in picture form"
#| fig.alt: "A parody of the O'Reilly programming books (O RLY?) called 'Changing Stuff and Seeing What Happens' with the subtitle 'How to actually learn any new programming concept'. A black-and-white kitten is featured on the cover."
knitr::include_graphics('images/intro-prog/learning_to_code_Orly.jpeg')
```

The goal for this chapter (and several chapters to come) is that you can modify example code and adapt it to the problem at hand. This is the best way to learn how to program, but it means you may break the code and not know how to fix it. If that happens, please try the following steps:

1.  Google the error and see if you can understand why it happened.
2.  Consult with a classmate to see if they can understand where things broke.
3.  Post to the discussion board and see if anyone in the class can understand where things broke.\
    (When you do this, post all of the code relevant to the problem, and the error you're getting, so that your classmates can replicate the problem)

If you do not hopelessly break code during this chapter, then please do your best to help others who may not have previously programmed (or previously programmed in these languages). While writing this chapter, I came across about 10 errors in SAS that I'd never encountered before.

If all else fails, while you're waiting for someone to help you figure out what an error message means... [try this approach](https://xkcd.com/1024/).

## Module Objectives {#module-2-objectives .unnumbered}

-   Create a program flow map by breaking a problem down into smaller steps
-   Write basic scripts to solve mathematical problems with variables, control structures, and scalar/matrix algebra

More informally, the goal is to get familiar with the basics of each programming language, and to show you where to find references for how to use each command -- because (at least) half of programming is knowing where to look something up.

## Definitions {.unnumbered}

Many programming resources talk about 3, or 5, or 10 core concepts in any programming language. In this module, we're going to discuss the generic concepts, and then how these concepts are implemented in the languages we're working with.

Interestingly, the "core concepts" aren't necessarily the same across lists. Here is a consensus list of concepts which are generic across languages and usually important[@pageBasicProgrammingConcepts2021,@mukitBasicProgrammingConcepts2018,@holowczakProgrammingConceptsBrief2013,@fenjvesComputerLanguageFundamentals2016,@asayBasicProgrammingConcepts2005]:

1.  **Variables**    
a symbolic name or reference to some kind of information. In the expression `a + b > a`, both `a` and `b` are variables. Variables may have a specific type (what data can be stored in the variable), scope (where the variable can be accessed), location (in memory). [Here](https://dev.to/lucpattyn/basic-programming-concepts-for-beginners-2o73) is a nice explanation of the difference between variables in programming and variables in math.

2.  **Conditional statements** (if statements)    
These statements allow the program to handle information adaptively - if a statement is true, one set of instructions will be used, and if the statement is false, a different set of instructions will be used.

3.  **Looping and iteration**    
An iteration is any time a sequence of steps is executed. Most languages have several different types of loops or iteration: `for` loops, which allow for the sequence of steps to be executed a specific number of times, `while` loops, which allow for the sequence of steps to be executed while a conditional statement is true, `recursion`, where a block of code calls itself.

4.  **Data types and data structures**    
these concepts determine what information a variable can hold. Data types are lower-level, simple objects (floating-point numbers, integers, boolean T/F, characters, strings). Data structures may include lists (sequences of many objects) and vectors (sequences of many objects of the same type), dictionaries (a list of key-value pairs), objects (data structures which may hold multiple related pieces of information).

5.  **Functions**    
self-contained modules of code that accomplish a particular task.

6.  **Syntax**    
The set of rules that define which combinations of symbols consist of correctly structured and interpretable commands in the language.

7.  **Tools**    
The set of external programs which may help with development and writing code. Some common tools are IDEs (Integrated Development Environments), which may correct syntax and typos, organize files for you, allow you to keep track of which variables you have defined, and assist you with code organization and navigation. Other tools include compilers (which take human-written code and translate it into efficient machine code), version control systems (which help you track changes to code over time), debuggers, and documentation generators. Not all of these tools are necessary for all languages - scripting languages such as python and R do not require compilers by default, for instance.

8.  **Sequence of commands**    
It's important to have the right commands in the right order. 

::: {#fig-sequence-commands}

<iframe width="560" height="315" src="https://www.youtube.com/embed/Ct-lOOUqmyY" title="YouTube video player" frameborder="0" allow="accelerometer; picture-in-picture" allowfullscreen></iframe>

It's important to get both the level of specificity and the order of the commands just right when programming.
:::

## Statistical Programming Languages {.unnumbered}

Having established the generic definitions of the concepts which apply to almost any programming language, we now must examine how specific programming languages implement these concepts.

R and SAS are both *statistical* programming languages - they are specifically designed to work with data, which means that they make compromises that other languages do not in order to make it easier to write code where the data (rather than the functions, classes, methods, or objects) are the primary concern.

Python is a **general purpose** programming language. It can be much more difficult to accomplish simple data-driven tasks in Python, but Python's construction will be much more familiar to anyone who has spent time in C, Java, or other general-purpose languages.

Here are a few quick facts about each of the 3 programming languages that are mentioned (even peripherally) in this book or are used in the statistics department at UNL:

::: panel-tabset
### R {#r-quick-facts .unnumbered}

-   Predecessor: S\
    R is an open-source clone of the S statistical programming language used internally at AT&T Bell Labs. S dates back to 1976; R first appeared in 1991 and was made public in 1993.

-   [History of R](https://bookdown.org/rdpeng/rprogdatascience/history-and-overview-of-r.html)

-   Language type:\
    **functional** - consists mainly of functions that manipulate objects

### Python {#python-quick-facts .unnumbered}

-   Predecessor: ABC programming language

-   [History of Python](https://en.wikipedia.org/wiki/History_of_Python)

-   Language type:\
    **interpreted** **general purpose** high level programming language. Focus on readable code using indentation to indicate grouping.

### SAS {#sas-quick-facts .unnumbered}

-   Predecessor: None\
    SAS dates back to the 1960s and has syntax which is unique because it predates C and Fortran.

-   [History of SAS](https://en.wikipedia.org/wiki/SAS_(software)#History)

-   Language type:\
    **procedural** - consists of steps/procedures that list the manipulations that will be performed on a set of data

-   Other Notes:

    -   SAS is actually several languages. Commands that work in the DATA step do not necessarily work in a PROC step. SAS also has its own general purpose programming language called IML (Interactive Matrix programming Language).
    -   The way SAS has been included in this course is different than it is usually taught, because I try to introduce SAS concepts at the same time as the corresponding R concept. If you are just needing to use SAS for e.g. your linear modeling classes, please just use the SAS documentation - it will be more than sufficient.
:::

### If you've used R/SAS/Python before... {.unnumbered .note}

If you've programmed before, the next few chapters are going to seem very ... boring. Sorry, there's no help for that. Some of your classmates haven't ever so much as written "Hello World", and we have to get them up to speed.

If you're bored, or feel like you know this material, skim through it anyways just to confirm (and if I'm doing something that's really out there, or there's an easier way to do it, tell me!). Then you can either find something in the references that you don't know already (the book Advanced R is always a great place to start if you want to be quickly confused), or help your classmates that are less experienced.


## Breaking Problems Down

The most fundamental part of programming that you will need to learn in this class is how to break down a big problem into smaller (hopefully solvable) problems. [This post](https://medium.com/@dannysmith/breaking-down-problems-its-hard-when-you-re-learning-to-code-f10269f4ccd5) is a great example of the process of breaking things down for programming, but the same concept applies outside of programming too!


::: ex

::: panel-tabset

### Scenario {- .unnumbered}

My spouse and I recently decided to replace our shower curtain with glass doors because the curtain didn't really prevent water from getting all over the floor.

We went to the store and picked out the parts, and the installation instructions broke the steps down like this:

1.  Install the base of the track

2.  Install the top of the track

3.  Hang shower doors

4.  Add hardware to shower doors

So we started in on the instructions, only to find out that when our house was built, our shower wasn't leveled properly.

### Brainstorming Solutions {- .unnumbered}

The instructions had a solution - we could send off for a \$300 custom part that would level our floor, but we'd have to wait at least 4-6 weeks for them to make and ship the part to us. At this point, we'd already taken apart the shower and bought the shower door, so having the bathroom out of commission for 4-6 weeks was not appealing.

We're both programmer-adjacent, so we started thinking through how we could deal with our problem a different way. We considered ignoring the instructions -- our shower was about 1/8" off of level, surely that couldn't be so important, right? My spouse is a bit more ... detail oriented ... than I am, so he wasn't good with that suggestion.

We considered adding a ton of caulk or plaster to try to level the shower out. But we figured that 1) probably wouldn't work, and 2) would look awful.

Finally, I suggested that my spouse 3D print sections of track-leveler using our 3D printer. Now, this isn't an option for most people, but it is for us - we have a small 3D printer, and my husband knows how to use OpenSCAD to create very accurate, custom dimension 3D printer files. He tested things out a few times, and printed up a series of 12 \~5" sections that, when assembled, were equivalent to the \$300 custom part we could have ordered. He added those sections to the shower, caulked them in, and proceeded with the rest of the installation.

### Conclusion {- .unnumbered}

Because we had a list of subproblems (steps for installation), we could focus our efforts on debugging the one problem we had (not level shower ledge) and we didn't have to get bogged down in "it's impossible to get this job done". 

We knew that if we could solve the little problem, we'd be able to get the bigger job done. Programming is just like this - if you can break your problem down into steps (and not steps with code), you can think through how to solve a single step of the problem before you worry about the next step.

:::

:::

One tool that is often used to help break a problem down is a [flowchart](https://www.programiz.com/article/flowchart-programming).
In a flowchart, each step in a process is described in sequential order, with decisions represented as forks in the "flow". 

One tool that I often use to make flowcharts and other diagrams/sketches while programming is [Excalidraw](https://excalidraw.com).


### Try it out {- .unnumbered .tryitout}

The biggest advantage to breaking problems down into smaller steps is that it allows you to focus on solving a small, approachable problem.

Let's think through an example:

::: panel-tabset

#### Problem

Print out a pyramid of stars, 10 lines high.

Yes, I remember, I haven't taught you how to write any code yet. Don't worry about code right now - let's just think about how we might create a pyramid of stars.

Start by doing the task manually on paper or in a text editor. Observe the steps you go through and think about how you might generalize those steps.

#### Manual Solution

First, we have to think about what we would need to make a pyramid of stars. So let's make a miniature one by hand (I'm using - for spaces here to make things visible):

    ---*---
    --***--
    -*****-

To make my miniature star pyramid, I started out by adding space on the first line, then a star, then more space. When I moved to the next line, I added space, but one less space than I'd added before, and then 3 stars, and then more space.

#### Analysis

Examining the manual solution, it seems we can break our problem down into two(ish) components:

-   How much space? (one side)
-   How many stars?
-   (redundant piece) How much space (the other side).

Thinking my way through how I created my manual pyramid, I realized that I was adding $n$ spaces (where $n$ is the total number of rows) on the first line, and then $n - i$ spaces on subsequent lines, if we start with i=0.

But I am an R programmer, so we start with $i=1$, which means I need to have $n - i + 1$ spaces on each row first.

Then, for $i=1$ the first row, we have $2*i - 1$ stars - i = 1, stars = 1, then i = 2, stars = 3, then i = 3, stars = 5.... you can do the regression if you want to, but it's pretty easy to see the relationship.

Finally, we have to (in theory) add the same amount of space on the other side -- strictly speaking, this is optional, but it makes the lines the same length, so it is nice.

#### Program Flow Map

![Program flow map for stars](images/intro-prog/prog-flow-pyramid-stars.svg)

#### Formal Solution

If we want a pyramid that is $n$ rows high, we might think of creating it by using the following line-by-line formula, where $i$ is our current line:

$n - i +1$ spaces, $2i - 1$ stars, $n - i + 1$ spaces

Working this out in a small example helped me come up with that formula; now, I can write a "loop":

-   line 1: i = 1, n = 10, 10 spaces, 1 star, 10 spaces
-   line 2: i = 2, n = 10, 9 spaces, 3 stars, 9 spaces
-   line 3: i = 3, n = 10, 8 spaces, 5 stars, 8 spaces
-   line 4: i = 4, n = 10, 7 spaces, 7 stars, 7 spaces
-   ...
-   line n: i = n, n = 10, 1 space, 19 stars, 1 space

:::


## Packages in R and Python

We've now officially covered the bare essentials of programming... while doing very little actual programming.

Before we start writing code, we need to address one additional thing: base Python, by default, doesn't have much of the basic functionality for working with data. Python is a multipurpose language, and as a result, we will load packages that we need to do various specific tasks. R also has these additional packages to do specific tasks, we just haven't gotten to the point where we need additional R packages yet because R is designed for working with data.

::: panel-tabset

### R {- .unnumbered}

To install the `tibble` package in R, we would use the following code:

```{r, eval = F}
install.packages("tibble")
```

Then, to use the functions within that package, we need to load the package:

```{r, eval = F}
library(tibble)
```

When you load a package, all of the functions in that package are added to your R Namespace (this is a technical term) - basically the list of all of the things R knows about. This may be problematic if you have two packages with the same function name.

If you want to use a function from a package without loading the package into your namespace, you can do that by using `pkgname::function` syntax.

For instance, this code creates a sample data frame using the `tribble` function in the `tibble` package.

```{r}
tibble::tribble(~col1, ~col2, 1, 'a', 2, 'b', 3, 'c')
```


### Python {- .unnumbered}

In Python, we install packages using the terminal (if you're only working in python), or if you're working in RStudio, you would write some R code using the `reticulate` package. You could put this R code into the R console (if you want) or into your rmarkdown/quarto markdown file (if you want). The important thing is that the package gets installed for whatever python executable you are using with R^[This can be an incredibly challenging thing to get right, and I'm intentionally glossing over it right now.].

In the terminal (NOT the R console) you might install the numpy package using `pip` (the python package manager):

```
pip install numpy
```

If you want to handle all of the python stuff from within R (or you're using a project with both and want to make sure it is all inter-operable, as I'm doing with this book), you would probably prefer to install the package by typing the following into the R console:

```{r, eval = F}
reticulate::install_py('numpy')
```

Then, when you want to use a python package, you would create a Python chunk or file and run the following code to load numpy:

```{python}
import numpy as np

```

This says we're going to refer to the numpy package as `np`, so any functions from that package will be called using `np.functionname`. This is different from how R typically handles this (and more similar to the `pkgname::functionname` syntax), but it ensures that there are not namespace collisions when you load multiple python packages. In general, this is much clearer.

If you want to use R-style package loading, you can, but this is generally discouraged because it can cause issues when you are using multiple packages.

```{python, eval = F}
from numpy import *
```

:::

## Overgrown Calculators

While R, SAS, and Python are all extremely powerful statistical programming languages, the core of most programming languages is the ability to do basic calculations and matrix arithmetic. As almost every dataset is stored as a matrix-like structure (data sets and data frames both allow for multiple types, which isn't quite compatible with more canonical matrices), it is useful to know how to do matrix-level calculations in whatever language you are planning to use to work with data.

In this section, we will essentially be using our programming language as overgrown calculators.

In the next chapters we'll talk about data types and structures, so you'll get to see more about matrices and arrays, but for now, let's confine ourselves to using R and python to do basic math calculations.


| Operation                    | R      | SAS                             | Python     |
|:---------|:-------|:-------|:-------|
| Addition                     | \+     | \+                              | \+         |
| Subtraction                  | \-     | \-                              | \-         |
| Elementwise Multiplication   | \*     | \#                              | \*         |
| Division                     | \\     | \\                              | \\         |
| Elementwise Exponentiation   | \^     | \##                             | `**`       |
| Matrix/Vector Multiplication | %\*%   | \*                              |  `np.dot()`          |
| Matrix Exponentiation        | \^     | \*\*                            | `np.exp()` |
| Matrix Transpose             | `t(A)` | `A`\` | `np.transpose(A)` |            |
| Matrix Determinant | `det(A)` | `det(A)` | `np.linalg.det(A)` |
| Matrix Diagonal | `diag(A)` | `diag(A)` | `np.linalg.diag(A)` |
| Matrix Inverse | `solve(A)` | `solve(A, diag({...}))` | `np.linalg.inv(A)` |

: Table of common mathematical and matrix operations in R, SAS, and Python. {#tbl-math-ops}


### Basic Mathematical Operators 

::: panel-tabset

#### R {.unnumbered}

```{r math-operators-sas}
x <- 1:10
y <- seq(3, 30, by = 3)

x + y
x - y
x * y
x / y
x^2
t(x) %*% y
```

#### Python {.unnumbered}

```{python}
import numpy as np

x = np.array(range(1, 11))
y = np.array(range(3, 33, 3)) # python indexes are not inclusive

x + y
x - y
x * y
x / y
x ** 2
np.dot(x.T, y)
```

#### SAS {.unnumbered}

By default, SAS creates row vectors with `do(a, b, by = c)` syntax. The transpose operator (a single backtick) can be used to transform `A` into `A`\`.

    proc iml; 
      x = do(1, 10, 1);
      y = do(3, 30, 3);

      z = x + y;
      z2 = x - y;
      z3 = x # y;
      z4 = x/y;
      z5 = x##2;
      z6 = x` * y;
      print z, z2, z3, z4, z5, z6;
    quit;
:::

### Matrix Operations

Other matrix operations, such as determinants and extraction of the matrix diagonal, are similarly easy:

::: panel-tabset

#### R {.unnumbered}

```{r matrix-operations}
mat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)
mat
t(mat) # transpose
det(mat) # get the determinant
diag(mat) # get the diagonal
diag(diag(mat)) # get a square matrix with off-diag 0s
diag(1:3) # diag() also will create a diagonal matrix if given a vector
```

#### Python {.unnumbered}

```{python matrix-operations-py}
import numpy as np
mat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')

mat
mat.T
np.linalg.det(mat) # numerical precision...
np.diag(mat)
np.diag(np.diag(mat))
np.diag(range(1, 4))
```

#### SAS {.unnumbered}

    proc iml;
      mat = {1 2 3, 6 4 5, 7 8 9}; 
      tmat = mat`; /* transpose */
      determinant = det(mat); /* get the determinant */
      diagonal_vector = vecdiag(mat); /* get the diagonal as a vector */
      diagonal_mat = diag(mat); /* get the diagonal as a square matrix */
                                /* with 0 on off-diagonal entries */
      
      dm = diag({1 2 3}); /* make a square matrix with vector as the diagonal */
      
      print tmat, determinant, diagonal_vector, diagonal_mat, dm;
    quit;
:::


### Matrix Inverse

The other important matrix-related function is the inverse. In R, `A^-1` will get you the elementwise reciprocal of the matrix. Not exactly what we'd like to see... Instead, in R and SAS, we use the `solve()` function. The inverse is defined as the matrix B such that `AB = I` where `I` is the identity matrix (1's on diagonal, 0's off-diagonal). So if we `solve(A)` (in R) or `solve(A, diag(n))` in SAS (where n is a vector of 1s the size of A), we will get the inverse matrix. In Python, we use the `np.linalg.inv()` function to invert a matrix, which is a bit more linguistically familiar.

::: panel-tabset
#### R {.unnumbered}

```{r invert-matrix-example}
mat <- matrix(c(1, 2, 3, 6, 4, 5, 7, 8, 9), nrow = 3, byrow = T)

minv <- solve(mat) # get the inverse

minv
mat %*% minv 
```

#### Python {.unnumbered}

```{python invert-matrix-example-py}
import numpy as np
mat = np.array([[1, 2, 3],[6, 4, 5],[7, 8, 9]], dtype = int, order ='C')

minv = np.linalg.inv(mat)
minv
np.dot(mat, minv)
np.round(np.dot(mat, minv), 2)
```

#### SAS {.unnumbered}

[Documentation](https://documentation.sas.com/?docsetId=imlug&docsetTarget=imlug_langref_sect208.htm&docsetVersion=14.2&locale=en)

```
    proc iml;
      mat = {1 2 3, 6 4 5, 7 8 9};

      mat_inv = solve(mat, diag({1 1 1})); /* get the inverse */
      mat_inv2 = inv(mat); /* less efficient and less accurate */
      print mat_inv, mat_inv2;

      id = mat * mat_inv;
      id2 = mat * mat_inv2;
      print id, id2; 
    quit;
```

:::

## Cheat Sheets and Reference Guides {.unnumbered .learn-more}

I kept the classic R reference card by my computer for about 5 years, and referenced it at least once or twice a day for that entire period. There will be other cheat sheets and reference cards scattered through this book because if you can't remember something's name, you might be able to remember where it is on the reference card (or at least, that's how I learned R).

::: panel-tabset


### R {.unnumbered}

-   [R Cheatsheet](https://rstudio.com/wp-content/uploads/2016/10/r-cheat-sheet-3.pdf) - this is a simplified cheat sheet offered by RStudio.
-   [R Cheatsheet (classic)](https://cran.r-project.org/doc/contrib/Short-refcard.pdf)

### Python {.unnumbered}

-   [Data Wrangling in Pandas](https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf)
-   [NumPy Cheat Sheet](http://datacamp-community-prod.s3.amazonaws.com/ba1fe95a-8b70-4d2f-95b0-bc954e9071b0)
-   [Data Input in Python](http://datacamp-community-prod.s3.amazonaws.com/72e88aa1-b4f2-4658-9d86-15becf8263df)

### SAS {.unnumbered}

-   [SAS Cheatsheet (from another class like this)](https://sites.ualberta.ca/~ahamann/teaching/renr480/SAS-Cheat.pdf)
-   [SAS Cheatsheet (by SAS)](https://support.sas.com/content/dam/SAS/support/en/books/data/base-syntax-ref.pdf)
-   [SAS Programming for R Users (free book)](https://support.sas.com/content/dam/SAS/support/en/books/free-books/sas-programming-for-r-users.pdf)
:::

## Additional Material {.unnumbered .learn-more}

### Textbooks {- .unnumbered}

-   [R for Data Science](https://r4ds.had.co.nz/) [@grolemundDataScience2017]
-   [Advanced R](http://adv-r.had.co.nz/Introduction.html) [@wickhamAdvanced2019]
    -   In particular, the [Data structures](http://adv-r.had.co.nz/Data-structures.html) chapter

### Other Course Websites {- .unnumbered}

-   Stat 850 at UNL (Bilder): [@bilderStat850Course2019]
-   [Stat 579 at Iowa State](https://stat579-at-isu.github.io/schedule.html): [@hofmannStat579Iowa2020]
-   [Stat 545 at Univ. British Columbia](https://stat545.com/): [@bryanStat545UBC2019]
-   [Introduction to SAS](https://online.stat.psu.edu/statprogram/stat480) - Undergraduate course at Penn State
-   [Intermediate SAS](https://online.stat.psu.edu/statprogram/stat481) - Undergraduate course at Penn State
-   [Advanced SAS](https://online.stat.psu.edu/statprogram/stat482) - Undergraduate course at Penn State

## References {#intro-prog-refs}
