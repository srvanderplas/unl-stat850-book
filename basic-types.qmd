
# Basic Variable Types

## Module Objectives {#module-3-objectives .unnumbered}

-   Know the basic data types and what their restrictions are
-   Know how to test to see if a variable is a given data type
-   Understand the basics of implicit and explicit type conversion
-   Write code that assigns values to variables

## Vocabulary

For a general overview, @tomscottWhyTRUETRUE2020 is an excellent introduction to data types:

<iframe width="640" height="400" src="https://www.youtube.com/embed/6otW6OXjR8c?list=PL96C35uN7xGLLeET0dOWaKHkAlPsrkcha" title="YouTube video player" frameborder="0" allow="accelerometer; picture-in-picture" allowfullscreen></iframe>


Let's start this section with some basic vocabulary.

-   a **value** is a basic unit of stuff that a program works with, like 1, 2, "Hello, World", and so on.

-   **values** have **types** - 2 is an integer, "Hello, World" is a string (it contains a "string" of letters). Strings are in quotation marks to let us know that they are not variable names.

In most languages, there are some very basic data types:

-   **logical** or **boolean** - FALSE/TRUE or 0/1 values. Sometimes, boolean is shortened to bool

-   **integer** - whole numbers (positive or negative)

-   **double** or **float** or **numeric** - decimal numbers.

    -   float is short for floating-point value.

    -   double is a floating-point value with more precision ("double precision").

    -   R uses the name **numeric** to indicate a decimal value, regardless of precision.

-   **character** or **string** - holds text, usually enclosed in quotes.

If you don't know what type a value is, there are usually functions to help you with that.

::: panel-tabset
## R {- .unnumbered}

```{r identify-var-type-r, results='hold'}
class(FALSE)
class(2L) # by default, R treats all numbers as numeric/decimal values. 
          # The L indicates that we're talking about an integer. 
class(2)
class("Hello, programmer!")
```

## Python {- .unnumbered}

```{python indentify-var-type-py, results='hold'}
type(False)
type(2)
type(3.1415)
type("This is python code")
```

:::

::: note
In R, boolean values are `TRUE` and `FALSE`, but in Python they are `True` and `False`. Capitalization matters a LOT.

Other things matter too: if we try to write a million, we would write it `1000000` instead of `1,000,000` (in both languages). Commas are used for separating numbers, not for proper spacing and punctuation of numbers. This is a hard thing to get used to but very important -- especially when we start reading in data.
:::

## Testing Types

You can use different functions to test whether a variable has a specific type as well:

::: panel-tabset
### R {- .unnumbered}

```{r test-var-type-r, results='hold'}
is.logical(FALSE)
is.integer(2L) # by default, R treats all numbers as numeric/decimal values. 
          # The L indicates that we're talking about an integer. 
is.integer(2)
is.numeric(2)
is.character("Hello, programmer!")
```

In R, you use `is.xxx` functions, where xxx is the name of the type in question.

### Python {- .unnumbered}

```{python test-var-type-py, results='hold'}
isinstance(False, bool)
isinstance(2, int)
isinstance(2, (int, float)) # Test for one of multiple types
isinstance(3.1415, float)
isinstance("This is python code", str)
```

In python, test for types using the `isinstance` function with an argument containing one or more data types in a tuple (`(int, float)` is an example of a tuple - a static set of multiple values).
:::

## Exploring Types

::: note
### Assignment {.unnumbered}

Note that `<-` is used for assigning a value to a variable. So `x <- "R is awesome"` is read "x gets 'R is awesome'" or "x is assigned the value 'R is awesome'".
:::

::: panel-tabset
### Character {.unnumbered}

```{r is-fcns-char, collapse = T, hold = T}
x <- "R is awesome"
typeof(x)
is.character(x)
is.logical(x)
is.integer(x)
is.double(x)
```

```{python is-fcns-char-py, collapse = T, hold = T}
x = "python is awesome"
type(x)
isinstance(x, str)
isinstance(x, bool)
isinstance(x, int)
isinstance(x, float)
```

### Logical {.unnumbered}

```{r is-fcns-lgl, collapse = T, hold = T}
x <- FALSE
typeof(x)
is.character(x)
is.logical(x)
is.integer(x)
is.double(x)
```

In R, is possible to use the shorthand `F` and `T`, but be careful with this, because `F` and `T` are not reserved, and other information can be stored within them. See [this discussion](https://twitter.com/tslumley/status/1279870794730893312) for pros and cons of using `F` and `T` as variables vs. shorthand for true and false. [^intro-prog-1]

```{python is-fcns-lgl-py, collapse = T, hold = T}
x = False
type(x)
isinstance(x, str)
isinstance(x, bool)
isinstance(x, int)
isinstance(x, float)
```

Note that in python, boolean variables are also integers. If your goal is to test whether something is a T/F value, you may want to e.g. test whether its value is one of 0 or 1, rather than testing whether it is a boolean variable directly, since integers can also function directly as bools in Python.

### Integer {.unnumbered}

```{r is-fcns-int, collapse = T, hold = T}
x <- 2
typeof(x)
is.character(x)
is.logical(x)
is.integer(x)
is.double(x)
```

Wait, 2 is an integer, right?

2 is an integer, but in R, values are assumed to be doubles unless specified. So if we want R to treat 2 as an integer, we need to specify that it is an integer specifically.

```{r is-fcns-int2, collapse = T, hold = T}
x <- 2L # The L immediately after the 2 indicates that it is an integer.
typeof(x)
is.character(x)
is.logical(x)
is.integer(x)
is.double(x)
is.numeric(x)
```

```{python is-fcns-int-py, collapse = T, hold = T}
x = 2
type(x)
isinstance(x, str)
isinstance(x, bool)
isinstance(x, int)
isinstance(x, float)
```

### Double {.unnumbered}

```{r is-fcns-dbl, collapse = T, hold = T}
x <- 2.45
typeof(x)
is.character(x)
is.logical(x)
is.integer(x)
is.double(x)
is.numeric(x)
```

```{python is-fcns-dbl-py, collapse = T, hold = T}
x = 2.45
type(x)
isinstance(x, str)
isinstance(x, bool)
isinstance(x, int)
isinstance(x, float)
```

### Numeric {.unnumbered}

A fifth common "type"[^intro-prog-2], `numeric` is really the union of two types: integer and double, and you may come across it when using `str()` or `mode()`, which are similar to `typeof()` but do not quite do the same thing.

The `numeric` category exists because when doing math, we can add an integer and a double, but adding an integer and a string is ... trickier. Testing for numeric variables guarantees that we'll be able to do math with those variables. `is.numeric()` and `as.numeric()` work as you would expect them to work.

The general case of this property of a language is called **implicit type conversion** - that is, R will implicitly (behind the scenes) convert your integer to a double and then add the other double, so that the result is unambiguously a double.
:::

[^intro-prog-1]: There is also an [R package dedicated to pure evil](https://purrple.cat/blog/2017/05/28/turn-r-users-insane-with-evil/) that will set F and T randomly on startup. Use this information wisely.

[^intro-prog-2]: `numeric` is not really a type, it's a mode. Run `?mode` for more information.

## Type Conversions {.unnumbered}

Programming languages will generally work hard to seamlessly convert variables to different types. So, for instance,

::: panel-tabset

### R {- .unnumbered}

```{r, error = T, collapse = T, hold = T}
TRUE + 2

2L + 3.1415

"abcd" + 3
```

### Python {- .unnumbered}

```{python, error = T, collapse = T, hold = T}
True + 2

int(2) + 3.1415

"abcd" + 3
```
:::

This conversion doesn't always work - there's no clear way to make "abcd" into a number we could use in addition. So instead, R or python will issue an error. This error pops up frequently when something went wrong with data import and all of a sudden you just tried to take the mean of a set of string/character variables. Whoops.

When you want to, you can also use `as.xxx()` to make the type conversion **explicit**. So, the analogue of the code above, with explicit conversions would be:

::: panel-tabset

### R {- .unnumbered}

```{r, error = T, collapse = T, hold = T}
as.double(TRUE) + 2

as.double(2L) + 3.1415

as.numeric("abcd") + 3
```

### Python {- .unnumbered}

```{python, error = T, collapse = T, hold = T}
int(True) + 2

float(2) + 3.1415

float("abcd") + 3

import pandas as pd # Load pandas library
pd.to_numeric("abcd", errors = 'coerce') + 3
```
:::

When we make our intent explicit (convert "abcd" to a numeric variable) we get an NA - a missing value - in R. In Python, we get a more descriptive error by default, but we can use the `pandas` library (which adds some statistical functionality) to get a similar result to the result we get in R.

There's still no easy way to figure out where "abcd" is on a number line, but our math will still have a result - `NA + 3` is `NA`.

## Determining a Variable's Type

::: panel-tabset

### R {- .unnumbered}

If you are unsure what the type of a variable is, use the `typeof()` function to find out.

```{r var-types, collapse = T, hold = T}
w <- "a string"
x <- 3L
y <- 3.1415
z <- FALSE

typeof(w)
typeof(x)
typeof(y)
typeof(z)

```

### Python {- .unnumbered}

If you are unsure what the type of a variable is, use the `type()` function to find out.

```{python var-types-py, collapse = T, hold = T}
w = "a string"
x = 3
y = 3.1415
z = False

type(w)
type(x)
type(y)
type(z)

```

:::

## Try It Out {.unnumbered .tryitout}

::: panel-tabset

### R {- .unnumbered}

1.  Create variables `string`, `integer`, `decimal`, and `logical`, with types that match the relevant variable names.

```{r tryitout-data-type, eval = F}
string <- 
integer <- 
decimal <- 
logical <- 
```

2.  Can you get rid of the error that occurs when this chunk is run?

```{r try-it-out-arithmetic, eval = F}
logical + decimal
integer + decimal
string + integer
```

3.  What happens when you add string to string? logical to logical?

### Python {- .unnumbered}

1.  Create variables `string`, `integer`, `decimal`, and `logical`, with types that match the relevant variable names.

```{python tryitout-data-type-py, eval = F}
string = 
integer = 
decimal = 
logical = 
```

2.  Can you get rid of the error that occurs when this chunk is run?

```{python try-it-out-arithmetic-py, eval = F}
logical + decimal
integer + decimal
string + integer
```

3.  What happens when you add string to string? logical to logical?

### R Solution {- .unnumbered}

```{r tryitout-data-type-answers, error = T}
string <- "hi, I'm a string"
integer <- 4L
decimal <- 5.412
logical <- TRUE

logical + decimal
integer + decimal
as.numeric(string) + integer

"abcd" + "efgh"
TRUE + TRUE
```

In R, adding a string to a string creates an error ("non-numeric argument to binary operator"). Adding a logical to a logical, e.g. TRUE + TRUE, results in `r TRUE + TRUE`, which is a numeric value.

To concatenate strings in R (like the default behavior in python), we would use the `paste0` function: `paste0("abcd", "efgh")`, which returns `r paste0("abcd", "efgh")`.

### Python Solution {- .unnumbered}

```{python tryitout-data-type-answers-py, error = T}
import pandas as pd

string = "hi, I'm a string"
integer = 4
decimal = 5.412
logical = True

logical + decimal
integer + decimal
pd.to_numeric(string, errors='coerce') + integer

"abcd" + "efgh"
True + True
```

In Python, when a string is added to another string, the two strings are **concatenated**. This differs from the result in R, which is a "non-numeric argument to binary operator" error.

:::

## References {- .unnumbered #variable-type-refs}
