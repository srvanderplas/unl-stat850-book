
# Exploring the Toolbox {#tools}


## Module Objectives {- #module-1-objectives}

- Set up necessary software for this class on personal machines

- Detect and resolve problems related to file systems, working directories, and system paths when troubleshooting software installation

- Use version control to track changes to a document (git add, commit, push, pull)

<!-- Since we'll be learning how to use a bunch of different software, the first step is to get everything set up on your machine: -->

<!-- - [git](https://help.github.com/en/github/getting-started-with-github/set-up-git) -->
<!-- - [R](https://www.r-project.org/) (4.0 or higher) -->
<!-- - [RStudio](https://rstudio.com/products/rstudio/download/#download) -->
<!-- - [LaTeX](https://www.latex-project.org/get/) -->
<!-- - [Quarto](https://quarto.org/#getting-started) -->

<!-- Optional: -->

<!-- - [SAS 9.4](https://statistics.unl.edu/how-obtain-sas-or-jmp-license) (or later) -->
<!-- - [Python 3](https://www.python.org/downloads/) -->


<!-- You will also need to sign up for a [GitHub account](https://help.github.com/en/github/getting-started-with-github/signing-up-for-a-new-github-account) -->


## Some Computer Basics

I grew up in the 1990s, and to use computers, you had to know a bit more about how computers worked than you do now. We also weren't so far away from the days of file cabinets with actual file folders. 

Many people teaching computing in the 2020s have noticed that students are lacking some essential awareness of some of the basics of how a computer works... essentials that help out a lot when it comes time to program a computer. So this section is intended to serve as a quick overview of some of those  principles. Scan it, and if you don't understand what a term means, please do some googling.

### Hardware

Here is a short 3-minute video on the basic hardware that makes up your computer. It is focused on desktops, but the same components (with the exception of the optical drive) are commonly found in cell phones, smart watches, and laptops.

::: youtube-video-container
<iframe width="100%" height="auto" src="https://www.youtube.com/embed/Rdm8E59L8Og" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>

</iframe>
:::

When programming, it is usually helpful to understand the distinction between RAM and disk storage (hard drives). We also need to know at least a little bit about processors (so that we know when we've asked our processor to do too much). Most of the other details aren't necessary (for now).

::: learn-more
-   [Chapter 1 of Python for Everybody](https://www.py4e.com/html3/01-intro) - Computer hardware architecture
:::

### Operating Systems

Operating systems, such as Windows <i class="fa-brands fa-windows"></i>, MacOS, or Linux, are a sophisticated program that allows CPUs to keep track of multiple programs and tasks and execute them at the same time.

::: youtube-video-container
<iframe width="100%" height="auto" src="https://www.youtube.com/embed/RhHMgkUdhdk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>

</iframe>
:::

### File Systems

::: warning
For this class, it will probably be important to distinguish between local file storage (C:/ drive <i class="fa-brands fa-windows"></i>, /user/your-name/ <i class="fa-brands fa-apple"></i>, or  /home/your-name/ <i class="fa-brands fa-linux"></i>) and network/virtual file systems, such as OneDrive and iCloud. Over time, it has become harder to ensure that you are working on a local machine, but working "in the cloud" can cause odd errors when programming and in particular when working with version control systems^[To disable onedrive sync for certain windows folders, use [this guide](https://support.microsoft.com/en-us/office/files-save-to-onedrive-by-default-in-windows-10-33da0077-770c-4bda-b61e-8c8e8ca70ac7)]. 

You want to save your files in this class to your **physical hard drive**. This will save you a lot of troubleshooting time.
:::

Evidently, there has been a bit of generational shift as computers have evolved: the "file system" metaphor itself is outdated because no one uses physical files anymore. [This article](https://futurism.com/the-byte/gen-z-kids-file-systems) is an interesting discussion of the problem: it makes the argument that with modern search capabilities, most people use their computers as a laundry hamper instead of as a nice, organized filing cabinet.

Regardless of how you tend to organize your personal files, it is probably helpful to understand the basics of what is meant by a computer **file system** -- a way to organize data stored on a hard drive. Since data is always stored as 0's and 1's, it's important to have some way to figure out what type of data is stored in a specific location, and how to interpret it.

::: youtube-video-container
<iframe width="560" height="315" src="https://www.youtube.com/embed/BV0-EPUYuQc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>

</iframe>
:::

That's not enough, though - we also need to know how computers remember the location of what is stored where. Specifically, we need to understand **file paths**.

::: youtube-video-container
<iframe width="560" height="315" src="https://www.youtube.com/embed/BMT3JUWmqYY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>

</iframe>
:::

When you write a program, you may have to reference external files - data stored in a .csv file, for instance, or a picture. Best practice is to create a file structure that contains everything you need to run your entire project in a single file folder (you can, and sometimes should, have sub-folders). We will practice this by working in [RStudio projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-RStudio-Projects). 

For now, it is enough to know how to find files using file paths, and how to refer to a file using a relative file path from your base folder. In this situation, your "base folder" is known as your **working directory** - the place your program thinks of as home.


### System Paths

When you install software, it is saved in a specific location on your computer, like C:/Program Files/ on <i class="fa-brands fa-windows"></i>, /Applications/ on <i class="fa-brands fa-apple"></i>, or /usr/local/bin/ on <i class="fa-brands fa-linux"></i>. For the most part, you don't need to keep track of where programs are installed, because the install process (usually) automatically creates icons on your desktop or in your start menu, and you find your programs there.

Unfortunately, that isn't sufficient when you're programming, because you may need to know where a program is in order to reference that program -- for instance, if you need to pop open a browser window as part of your program, you're (most likely) going to have to tell your computer where that browser executable file lives.

To simplify this process, operating systems have what's known as a "system path" or "user path" - a list of folders containing important places to look for executable and other important files. You may, at some point, have to edit your system path to add a new folder to it, making the executable files within that folder more easily available. 

::: learn-more

[How to set system paths (general)](https://superuser.com/a/284361/391106)

Operating-system specific instructions cobbled together from a variety of different sources:
- [<i class="fa-brands fa-windows"></i> On Windows](https://miktex.org/howto/modify-path)
- [<i class="fa-brands fa-apple"></i> On Mac](https://osxdaily.com/2014/08/14/add-new-path-to-path-command-line/)
- [<i class="fa-brands fa-linux"></i> On Linux](https://linuxize.com/post/how-to-add-directory-to-path-in-linux/)

:::

If you run across an error that says something along the lines of 

- could not locate xxx.exe
- The system cannot find the path specified
- Command Not Found

you might start thinking about whether your system path is set correctly for what you're trying to do. 

If you want to locate where an executable is found (in this example, we'll use `git`), you can run `where git` on windows, or `which git` on OSX/Linux.

Some programs, like RStudio, have places where you can set the locations of common dependencies. If you go to Tools > Global Options > Git/SVN, you can set the path to git. 


### Working Directories

When you launch a program, that program starts up with a specific directory as its "location" - the place where it will look for files. Most of the time, we don't think too much about this when using graphical programs, but it's much more important to get this right when programming things ourselves.

In RStudio, you can set your working directory in several ways:

1. Work in an RStudio Project (File > New Project), which will make it easy to access your project folder, and will set your working directory to the right folder automatically. I've created a project in `/home/susan/Projects/Class/unl-stat850/test-project`    
![Setup window for RStudio projects](images/tools/test-project-setup.png)

2. Use `setwd()` to set your working directory. If I'm not working in the RStudio project described above, I can set my working directory to that folder using:
`setwd("/home/susan/Projects/Class/unl-stat850/test-project")`

3. Use the files tab (bottom right) to navigate to your preferred folder. Then, click More > Set As Working Directory.


In this class, we're going to focus on **reproducibility** - making sure your code runs on any other computer with the right project setup. So with that in mind:

1. Work in (RStudio) projects^[None of the good practices here are dependent on RStudio, but RStudio projects do make it easier for you to e.g. keep track of where files are living and what your current working directory is. You can do the same thing in a purely python project if you want to, but think of RStudio here as training wheels for those in the class who are not familiar with file paths and reproducibility.]
2. Store the data for the project in your project folder
3. Use local paths - if you're in your project folder and trying to reference "data.xls", then you would just use "data.xls" as the path. If your data is in a "code" folder, you would use "code/data.xls" as the path.

This will ensure that your code should work on any other machine, as long as your data is in your git repository and your code uses local file paths.




## Acquiring the Tools: Setting Up Your Computer

First, lets cover the basics of setting up the software you're going to be using in this course. You don't at this point have to understand what the different software DOES, but you should at least get it installed and working -- this may be tricky, so we'll take it slow.

First, we're going to install all of the software you need for this class. The order here matters.

In the next section, I'll explain what each piece of software is, and what it is used for.

1. Install R. 
    - Download and run the R installer for your operating system from CRAN. Please make sure you are using at least R 4.1^[4.2 is the most recently released version as of May 2022, when I'm writing this.]
        -   <i class="fa-brands fa-windows"></i> Windows: https://cran.rstudio.com/bin/windows/base/
        -   <i class="fa-brands fa-apple"></i> Mac: https://cran.rstudio.com/bin/macosx/
        -   <i class="fa-brands fa-linux"></i> Linux: https://cran.rstudio.com/bin/linux/ (pick your distribution)
    - If you are on Windows, install the [Rtools4 package](https://cran.rstudio.com/bin/windows/Rtools/); this will ensure you get fewer warnings later when installing packages.    
More detailed instructions for Windows are available [here](https://owi.usgs.gov/R/training-curriculum/installr/)
    - Additional resources for help:
        - Videos (these use very OLD versions of R, but the instructions are the same.)
            - <i class="fa-brands fa-windows"></i> [R on Windows installation](https://www.youtube.com/watch?v=mfGFv-iB724)
            - <i class="fa-brands fa-apple"></i> [R on Mac installation](https://www.youtube.com/watch?v=Icawuhf0Yqo)
<details><summary>Tutorial videos and additional help</summary>
        - <i class="fa-brands fa-linux"></i> R on Linux installation (Text-based tutorial)    
On Linux, instead of a YouTube video, you get a text-based  [tutorial](https://github.com/swirldev/swirl/wiki/Installing-swirl-on-Linux). One of the Debian maintainers, Dirk Eddelbuettel, is also on R core, which means that R tends to work extremely well with Debian-based distributions, like Ubuntu and Linux Mint. R does work on RPM based distros, and you can of course also compile it from source for Arch/Gentoo, but I've stuck with Deb-based distributions for approximately 7 years because it seems to be a bit less hassle. Additional troubleshooting can be found [here](https://pages.github.nceas.ucsb.edu/NCEAS/help/installing_r_on_ubuntu.html).

2. Install RStudio (version 2022.02.2 or higher)
    - You can find RStudio [here](https://rstudio.com/products/rstudio/download/). You want the open source edition of RStudio Desktop. If you're feeling brave, you can install the [preview release](https://rstudio.com/products/rstudio/download/preview/#download) - this may have a few bugs, but tends to be relatively stable and has the latest features. 
    - If you're on Linux, go ahead and [import RStudio's public key](https://rstudio.com/code-signing/) so that software validation works. (All of the commands are provided in the linked page)

3. Install git using the instructions [here](https://happygitwithr.com/install-git.html). Consult the [troubleshooting guide](https://happygitwithr.com/troubleshooting.html) if you have issues. If that fails, then seek help in office hours.

4. Install Python 3 and Jupyter
    - [python 3](https://www.python.org/downloads/)
    - Instructions to install [Jupyter](https://jupyter.org/install) (install with pip unless you know what you're doing)
    
5. [Install Quarto](https://quarto.org/docs/get-started/). We will be using Quarto with RStudio throughout this book.

6. Install LaTeX and rmarkdown:
    - Launch R, and type the following commands into the console:
```{r tinytex-install, eval = F}
install.packages(c("tinytex", "knitr", "rmarkdown", "quarto"))
library(tinytex)
install_tinytex()
```

::: warning

To get things fully set up you will need to read the rest of this chapter, and do all of the Try it Out sections. They are essential for ensuring that you have the correct packages installed!

:::

## Explaining the Tools: What Have I Done?

### RStudio: The IDE

An IDE is an **integraged development environment** - a fancy, souped up text editor that is built to make programming easier. Back in the dark ages, people wrote programs in text editors^[Ok, in prehistory they programmed by punching holes in cards, but that was before my time... back when 🦣 roamed the earth.] and then used the command line to compile those programs and run them.


::: {.callout-note}
RStudio is not R - it's just a layer on top of R. So if you have a question about the user interface, you have an RStudio question. If you have a question about the code, you have an R question.
:::

This book is written with the idea that you will use RStudio to write, run, and debug your code (in both R and python). 

#### Navigating RStudio

![The RStudio window will look something like this.](images/tools/Rstudio_env.png)

- In the top-left pane is the text editor. This is where you'll do most of your work.

- In the top right, you'll find the environment, history, and connections tabs. The environment tab shows you the objects available in R (variables, data files, etc.), the history tab shows you what code you've run recently, and the connections tab is useful for setting up database connections.

- On the bottom left is the console. There are also other tabs to give you a terminal (command line) prompt, and a jobs tab to monitor progress of long-running jobs. In this class we'll primarily use the console tab. 

- On the bottom right, there are a set of tabs: 
  - files (to give you an idea of where you are working, and what files are present), 
  - plots (which will be self-explanatory), 
  - packages (which extensions to R are installed and loaded), 
  - the help window (where documentation will show up), and 
  - the viewer window, which is used for interactive graphics or previewing HTML documents. 

#### Try It Out {- .tryitout}

- To get started, open RStudio and find the console window.    
Type 2+2 into the console window and hit enter.

- Now, open the text editor (File -> New -> R script).    
Type 2+2 into the text editor and press the run button that is on the pane's shortcut bar (or, you can hit Ctrl-Enter/CMD-Enter to send a single line to the console). 

If both of those things worked, you're probably set up correctly!

***

- Next, try typing this into the text editor, then run the line. Look in the environment tab and see if you can see what has changed.

```{r env-var-changes}
a <- 3 # store 3 in the variable a
```

![Your environment window should now look something like this (the .Last.value entry may not be there, and that's ok)](images/tools/Rstudio_env_var.png)

You can use the environment window to preview your data, check on the status of variables, and more. Note that while R is running, the window doesn't update (so you can't check on the status of a loop while the loop is running using the window).

***

- Next, try typing this into the text editor, and then run all of the lines at the same time. You should see something change in the Plots tab.

```{r plot-tab, eval = F }
x <- seq(0, 2*pi, length.out = 50)
y <- sin(x)
plot(x = x, y = y, type = 'l')
text(x = pi*1.5, y = 0, labels = "Welcome to R!")
```

### Programming Languages {.unnumbered}

Having established the generic definitions of the concepts which apply to almost any programming language, we now must examine how specific programming languages implement these concepts.

R is a *statistical* programming languages - it is specifically designed to work with data, which means that it makes compromises that other languages do not in order to make it easier to write code where the data (rather than the functions, classes, methods, or objects) are the primary concern. (SAS is also a statistical programming language, but is only briefly covered in this book, with some additional content in an appendix).

Python is a **general purpose** programming language. It can be much more difficult to accomplish simple data-driven tasks in Python, but Python's construction will be much more familiar to anyone who has spent time in C, Java, or other general-purpose languages.

Here are a few quick facts about each of the programming languages that are mentioned (even peripherally) in this book; at least two of the three are used in most statistics departments, though which 2 tends to vary based on a number of factors including the types of applied statisticians in the department and how modern the department is.

::: panel-tabset
#### R {#r-quick-facts .unnumbered}

-   Predecessor: S\
    R is an open-source clone of the S statistical programming language used internally at AT&T Bell Labs. S dates back to 1976; R first appeared in 1991 and was made public in 1993.

-   [History of R](https://bookdown.org/rdpeng/rprogdatascience/history-and-overview-of-r.html)

-   Language type:\
    **functional** - consists mainly of functions that manipulate objects

#### Python {#python-quick-facts .unnumbered}

-   Predecessor: ABC programming language

-   [History of Python](https://en.wikipedia.org/wiki/History_of_Python)

-   Language type:\
    **interpreted** **general purpose** high level programming language. Focus on readable code using indentation to indicate grouping.

#### SAS {#sas-quick-facts .unnumbered}

-   Predecessor: None\
    SAS dates back to the 1960s and has syntax which is unique because it predates C and Fortran.

-   [History of SAS](https://en.wikipedia.org/wiki/SAS_(software)#History)

-   Language type:\
    **procedural** - consists of steps/procedures that list the manipulations that will be performed on a set of data

-   Other Notes:
    -   SAS is actually several languages. Commands that work in the DATA step do not necessarily work in a PROC step. SAS also has its own general purpose programming language called IML (Interactive Matrix programming Language).
    -   The way SAS has been included in this course is different than it is usually taught, because I try to introduce SAS concepts at the same time as the corresponding R concept. If you are just needing to use SAS for e.g. your linear modeling classes, please just use the SAS documentation - it will be more than sufficient.
    
:::

In this section, we'll talk a bit more about R and python specifically, as they are covered extensively in this book. SAS content is relegated to the appendix - I no longer teach SAS at 

::: {.callout-note}

#### If you've used R/SAS/Python before... {.unnumbered}

If you've programmed before, the next few chapters are going to be boring. Sorry, there's no help for that. Some of your classmates haven't ever so much as written "Hello World", and we have to get them up to speed.

If you're bored, or feel like you know this material, skim through it anyways just to confirm (and if I'm doing something that's really out there, or there's an easier way to do it, tell me!). You can then either find something in the references that you don't know already (@advr is always a great place to start if you want to be quickly confused), or help your classmates that are less experienced, which will help you learn new things and build relationships with other students.
:::

#### R

R is a statistical programming language. Unlike more general-purpose languages, R is optimized for working with data and doing statistics. If you want to build an independent, standalone graphical interface, or run a web server, R is probably not the ideal language to use (you might want C/python or PHP/python, respectively). 
If you want to vacuum up a bunch of data, fit several regression models, and then compare the models, R is a great option and will be faster than working in a more general-purpose language like C or base python.


![A brief illustrated history of R. R is an open-source clone of S programming language, which was invented at Bell Labs. S was inspired by Scheme and Lisp, but is ultimately compiled in Fortran and C.](images/tools/History of R.png)

R is 
- vector-based
- 1 indexed (start counting 1, 2, 3, ...) 
- a scripting language (R code does not have to be compiled before it is run)

One of R's strengths is the package repository, CRAN, that allows anyone (yes, even you!) to write an R package. This means that R generally has the latest statistical methods available, as one of the best ways to ensure someone uses your work is to write an R package to make that work accessible to the general population of statisticians/biologists/geneticists. 


To install the `tibble` package in R, we would use the following code:

```{r, eval = F}
install.packages("tibble")
```

Then, to use the functions within that package, we need to load the package:

```{r, eval = F}
library(tibble)
```

When you load a package, all of the functions in that package are added to your R Namespace (this is a technical term) - basically the list of all of the things R knows about. This may be problematic if you have two packages with the same function name.

If you want to use a function from a package without loading the package into your namespace, you can do that by using `pkgname::function` syntax.

For instance, this code creates a sample data frame using the `tribble` function in the `tibble` package.

```{r}
tibble::tribble(~col1, ~col2, 1, 'a', 2, 'b', 3, 'c')
```



##### Try it Out (R package edition) {.tryitout}

Try to run the following code, which will install (most of) the packages you need to run the code in this book. 

```{r install-req-pkgs, eval = F}
# Read in a list of all packages that are required
pkgs <- readLines("https://raw.githubusercontent.com/srvanderplas/unl-stat850/master/data/packages")

# Remove packages only available on github
pkgs <- setdiff(pkgs, c("nycsquirrels18", "emo", "tweetrmd", "classdata"))

# Remove any already installed packages from the list
pkgs <- setdiff(pkgs, installed.packages())

# The following code will not make a lot of sense... yet. Come back to it in a 
# few weeks and see how much you understand (or can decode)

# This ensures that if the installation fails, the code will keep running
try_install_pkg <- function(...) try(install.packages(..., dependencies = T))
lapply(pkgs, try_install_pkg)
pkgs <- setdiff(pkgs, installed.packages())

if (length(pkgs) > 0) {
  paste("The following packages did not install: \n", paste(pkgs, collapse = "\n"))
}

# Try installing github packages
devtools::install_github(c("mine-cetinkaya-rundel/nycsquirrels18", 
                           "hadley/emo", 
                           "gadenbuie/tweetrmd", 
                           "heike/classdata"))
```


#### Python 

Python is a general-purpose programming language. Some people like to say that Python is the [2nd best language for everything](https://www.youtube.com/watch?v=MXZ_WI6ikTo). Python by itself is a terrible language for data analysis, but when combined with a couple of critical packages, Python becomes an excellent language for data analysis, and in particular, for machine learning tasks. Python's strength is that it has access to a number of libraries for tasks like image processing, computer vision, and artificial intelligence that go outside of the domain of "traditional statistics" but are highly relevant to modern applied statistical tasks.

![A brief illustrated history of python. Python was created as an attempt to fix some problems with the ABC programming language, which focused on creating short, readable code. When python is combined with numpy and pandas, two libraries for data analysis, it is a very powerful language for statistical computing.](images/tools/History of Python.png)

As we'll be using python within RStudio, now is a good time to check and make sure that RStudio can find your python installation. 

##### Try it Out (Python + RStudio) {.tryitout}

Go to Tools -> Global Options and select Python on the left-hand side of the popup menu. Ensure that there is at least one python installation available for RStudio.

![Screenshot of global options window and toolbar to find the python menu](images/tools/Rstudio_find_python.png)



##### Python Packages

Python packages can be installed in a couple of different ways, but for now, we're going to talk about installing python packages using pip.

**Pip** is the most common python package manager. You should already have pip installed if you followed the directions to install python provided above. If you do not have pip installed, see [these instructions](https://pip.pypa.io/en/stable/installation/). 

To install packages using pip, you'll need to use the command line [@weiQuickGuideUsing2019]. 

One easy way to do that is to open RStudio and start a terminal within RStudio. 

![](images/tools/Rstudio_terminal.png)

The terminal window should appear in the bottom left pane (by default). 

In that terminal, you would type `pip install pkgname` to install the `pkgname` package.


Then, when you want to use a python package, you would use the following code to load numpy:

```{python}
import numpy as np

```

This says we're going to refer to the numpy package as `np`, so any functions from that package will be called using `np.functionname`. This is different from how R typically handles this (and more similar to the `pkgname::functionname` syntax), but it ensures that there are not namespace collisions when you load multiple python packages. In general, this is much clearer.

If you want to use R-style package loading, you can, but this is generally discouraged because it can cause issues when you are using multiple packages.

```{python, eval = F}
from numpy import *
```


##### Try it Out (Python package edition)

Use pip to install the `numpy` and `pandas` python packages. This will install many other python packages as well - these packages are known as dependencies, and are required to use numpy and pandas.

```
pip install numpy pandas
```

When I try to install numpy and pandas, I get this response:

![Pip sees that the requirements are already satisfied, so no new packages are installed](images/tools/pip_install_numpy_pandas.png)
It is helpful to read the messages in the terminal so that you can see what the computer is trying to tell you. In my case, pip is telling me I need to manually upgrade pip, and it tells me exactly what to run to do that. 


### Version Control 

::: {.callout-note}
Most of this section is either heavily inspired by @bryanHappyGitGitHub2021 or directly links to that book. 
:::

::: adv
We will be using git to track changes made to code in this class. As a bonus, this will also allow you to submit your homework via github, collaborate with group members easily, and I can even help you with your assignments and see what the problem(s) is (are) ... as long as you keep your homework repository up to date!
:::

Git is a version control system - the goal of git and other version control systems is to help groups of programmers work on large projects together. Git manages a collection of files in a structured way - rather like "track changes" in Microsoft Word or versioning in Dropbox, but much more powerful.

<img alt="You don't want to end up here. Version control is the answer to this problem." src="https://www.phdcomics.com/comics/archive/phd101212s.gif" width = "50%"/>

In data science programming, we use git for a similar, but slightly different purpose. We use it to keep track of changes not only to code files, but to data files, figures, reports, and other essential bits of information. 

If you are working alone, you will benefit from adopting version control because it will remove the need to add _final.R to the end of your file names. However, most of us work in collaboration with other people (or will have to work with others eventually), so one of the goals of this program is to teach you how to use git because it is a useful tool that will make you a better collaborator. 

Git itself is nice enough, but where git really becomes amazing is when you combine it with GitHub - an online service that makes it easy to use git across many computers, share information with collaborators, publish to the web, and more. Git is great, but GitHub is ... essential. In this class, we'll be using both git and github, and your homework will be managed with GitHub Classroom. 


#### Getting Started with Git

![If that doesn't fix it, git.txt contains the phone number of a friend of mine who understands git. Just wait through a few minutes of 'It's really pretty simple, just think of branches as...' and eventually you'll learn the commands that will fix everything.](images/tools/git.png){fig-alt:"Person 1: 'This is GIT. It tracks collaborative work on projects through a beautiful distributed graph theory tree model'. Person 2: 'Cool, How do we use it?' Person 1: 'No Idea. Just memorize these shell commands and type them to sync up. If you get errors, save your work elsewhere, delete the project, and download a fresh copy.'"}


Git is a program whose primary purpose is **version control**. Git tracks changes to each file that it is told to monitor, and as the files change, you provide short labels describing what the changes were and why they exist (called "commits"). The log of these changes (along with the file history) is called your git commit history. 

When writing papers, this means you can cut material out freely, so long as the paper is being tracked by git - you can always go back and get that paragraph you cut out if you need to. You also don't have to rename files - you can confidently overwrite your files, so long as you remember to commit frequently. 

::: go-read
The git material in this chapter is just going to link directly to the book "Happy Git with R" by Jenny Bryan. It's amazing, amusing, and generally well written. I'm not going to try to do better. 

[Go read Chapter 1, if you haven't already.](https://happygitwithr.com/big-picture.html)
:::


#### GitHub: Git on the Web {#setting-up-github}

See the instructions [here](https://happygitwithr.com/github-acct.html) to set up a GitHub account.

<details><summary>Git and Github: Slightly crude (but memorable) analogy</summary>
Git is to GitHub what Porn is to PornHub. Specifically, GitHub hosts git repositories publicly, while PornHub hosts porn publicly. But it would be silly to equate porn and PornHub, and it's similarly silly to think of GitHub as the only place you can use git repositories.
</details>

Git is a program that runs on your machine and keeps track of changes to files that you tell it to monitor. GitHub is a website that hosts people's git repositories. You can use git without GitHub, but you can't use GitHub without git. 

If you want, you can hook Git up to GitHub, and make a copy of your local git repository that lives in the cloud. Then, if you configure things correctly, your local repository will talk to GitHub without too much trouble. Using Github with Git allows you to **easily make a cloud backup of your important code**, so that even if your  computer suddenly catches on fire, all of your important code files exist somewhere else. 

Remember: any data you don't have in 3 different places is data you don't care about.^[Yes, I'm aware that this sounds paranoid. It's been a very rare occasion that I've needed to restore something from another backup. You don't want to take chances. I knew a guy who had to retype his entire masters thesis from the printed out version the night before it was due because he had stored it on a network drive that was decommissioned. You don't want to be that person.]


#### Introduce yourself to git and set up SSH authentication

You need to tell git what your name and email address are, because every "commit" you make will be signed. 

Follow the instructions [here](https://happygitwithr.com/hello-git.html), or run the lines below:

```{r, collapse = T, results = "hold", eval = F}

user_name <- readline(prompt = "Your full name: ")
user_email <- readline(prompt = "The address associated w your github account: ")

install.packages("usethis")
library(usethis)

use_git_config(user.name = user_name, user.email = user_email, scope = "user")

# Tell git to ignore all files that are OS-dependent and don't have useful data.
git_vaccinate() 

# Create a ssh key if one doesn't already exist
if (!file.exists(git2r::ssh_path("id_rsa.pub"))) {
  system("ssh-keygen -t rsa -b 4096") # Create an ssh key
  system("eval $(ssh-agent -s)")
  system("ssh-add ~/.ssh/id_rsa")
} 
```

Then, in RStudio, go to Tools > Global Options > Git/SVN. View your public key, and copy it to the clipboard. 

Then, proceed to github. Make sure you're signed into GitHub. Click on your profile pic in upper right corner and go Settings, then SSH and GPG keys. Click "New SSH key". Paste your public key in the "Key" box. Give it an informative title. For example, you might use 2022-laptop to record the year and computer. Click "Add SSH key".

#### Optional: Install a git client

[Instructions](https://happygitwithr.com/git-client.html)

I don't personally use a git client other than RStudio, but you may prefer to have a client that allows you to use a point-and-click interface. It's up to you. 

### Document Creation {#setting-up-tex}

#### LaTeX


LaTeX is a typesetting program, which makes it different from most other document creation software, such as MS Word, which is "WYSIWYG" - what you see is what you get. In LaTeX, you'll type in code to create a document, and LaTeX will compile the document into something pretty. The goal is that you have to think less about formatting and what goes on which page - LaTeX will handle that part for you - so that you can think more about the content.

<details><summary>Why use LaTeX?</summary>
<img src="images/tools/02_word_formatting.png" alt="using microsoft word: moves an image one mm to the left. all text and images shift. four new pages appear. paragraph breaks form a union. a swarm of commas buzzes at the window. In the distance, sirens." width="50%"/>

(shamelessly stolen from FB, which apparently stole it from Tumblr)

Latex is meant for you to focus on the content and not worry about the formatting - the computer optimizes figure placement according to directives you've given. 
</details>
In practice, it doesn't usually work out like that, so there are programs like markdown which aim to simplify document creation even more to free you from the formatting that LaTeX requires. 

LaTeX[@knuth84] is often used for typesetting statistical and mathematical papers because its equation editor is top notch. (It was actually written by Donald Knuth because he got so annoyed trying to write his dissertation that he took some time off to write TeX first, and then used it to write his dissertation).^[Amusingly, `knitr` [@knitr] was written in much the same manner. Yihui Xie had to substitute-teach ISU's version of 850 on the day we covered Sweave (a predecessor to knitr). He got so frustrated teaching the class that he went home and started writing `knitr`. Later, he developed Rmarkdown, bookdown, blogdown, and several other packages aimed at making writing documents + code easier to handle.    
Moral of the story - if you get frustrated with the tools you have, you're in good company. Use it as fuel to make better tools.] 


##### Try it Out: LaTeX {.tryitout}

If you want to try to make a simple LaTeX document in RStudio, [try out this LaTeX tutorial](https://latex-tutorial.com/tutorials/first-document/).



#### Markdown

We'll work with LaTeX later in the semester, but for now, we'll be primarily working with Quarto or Rmarkdown, which is much simpler. [Here's a quick cheatsheet](https://rmarkdown.rstudio.com/authoring_basics.html). 

When you use markdown within RStudio, you don't have to worry about where pandoc lives on your computer (e.g. the path). You can just click the button at the top of the file that says "Knit" or "Preview" to see what your file looks like.

If you want to try out some simple Markdown formatting, you can create a new Rmarkdown document by going to File > New File > Rmarkdown (or Quarto Markdown) and testing out the simple document it starts you out with.

[This cheat sheet is a very useful guide to Rmarkdown](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf)


## Using Version Control (with RStudio)

The first skill you need to actually practice in this class is using version control. By using version control from the very beginning, you will learn better habits for programming, but you'll also get access to a platform for collaboration, hosting your work online, keeping track of features and necessary changes, and more. 

::: adv

I will be using github classroom to run this class. When you go to do your homework assignment, you'll have to complete the following steps: 

1. Clone the template repository for the assignment.
2. Read the assignment instructions in the template repository. Complete the assignment, ensuring that you write fully reproducible code that can be run on any machine.
3. Commit your changes to the assignment to the local git repository on your computer
4. Push your changes from your local machine to GitHub
5. Submit a link to the GitHub repository so that I can grade your assignment.

GitHub Classroom is FERPA compliant, which means that your repositories from this class won't show up under your user (because class enrollment is protected information). 

This workflow means that if you push your changes to GitHub but something isn't working, I can easily see what you've done so far and help you fix any errors that show up. You don't have to email me with a vague error message and then respond to my confused emails 10x as we narrow in on the problem - I can usually just find the problem in your file directly. This saves a lot of time!

:::


So, what does your typical git/GitHub workflow look like? I'll go through this in (roughly) chronological order. This is based off of a relatively high-level understanding of git - I do not have any idea how it works under the hood, but I'm pretty comfortable with the clone/push/pull/commit/add workflows, and I've used a few of the more complicated features (branches, pull requests) on occasion. 

### Create a Repository

**Repositories** are single-project containers. You may have code, documentation, data, TODO lists, and more associated with a project. If you combine a git repository with an RStudio project, you get a very powerful combination that will make your life much easier... but you of course do not have to do that if you are ok with making things hard for yourself.

To create a repository, you can start with your local computer first, or you can start with the online repository first. 

::: .watch-out
Both methods are relatively simple, but the options you choose depend on which method you're using, so be careful not to get them confused. 
:::

#### Local repository first

Let's suppose you already have a folder on your machine named `hello-world-1` (you may want to create this folder now). You've created a starter document, say, a text file named README with "hello world" written in it. 

If you want, you can use the following R code to set this up:

```{r git-local-repository-first, eval = F}
dir <- "./hello-world-1"
if (!dir.exists(dir)) {
  dir.create(dir)
}
file <- file.path(dir, "README")
if (!file.exists(file)) {
  writeLines("hello world", con = file)
}
```

To create a local git repository, we can go to the terminal (in Mac/Linux) or the git bash shell (in Windows), navigate to our repository folder (not shown, will be different on each computer), and type in 

```
git init
```

Alternately, if you prefer a GUI (graphical user interface) approach, that will work too:

1. Open Rstudio
2. Project (upper right corner) -> New Project -> Existing Directory. Navigate to the directory.
3. (In your new project) Tools -> Project options -> Git/SVN -> select git from the dropdown, initialize new repository. RStudio will  need to restart.
4. Navigate to your new Git tab on the top right.

![Screen capture video of the steps described above to create a git repository in RStudio](images/tools/Rstudio-existing-git.gif)

The next step is to add our file to the repository. 

Using the command line, you can type in `git add README` (this tells git to track the file) and then commit your changes (enter them into the record) using `git commit -m "Add readme file"`.

Using the GUI, you navigate to the git pane, check the box next to the README file, click the Commit button, write a message ("Add readme file"), and click the commit button. 

![Screen capture video of the steps described above to add and commit a file in RStudio](images/tools/Rstudio-git-commit.gif)

The final step is to create a corresponding repository on GitHub. Navigate to your GitHub profile and make sure you're logged in. Create a new repository using the "New" button. Name your  repository whatever you want, fill in the description if you want (this can help you later, if you forget what exactly a certain repo was *for*), and DO NOT add a README, license file, or anything else (if you do, you will have a bad  time). 

You'll be taken to your empty repository, and git will provide you the lines to paste into your git shell (or terminal) -- you can access this within RStudio, as shown below. Paste those lines in, and you'll be good to  go.

![Connect your local git repository to GitHub](images/tools/Rstudio-github-remote.gif)

####  GitHub repository first

In the GitHub-first method, you'll create a repository in GitHub and then clone it to your local machine (clone = create an exact copy locally). 

GUI method:

1. Log into GitHub and create a new repository
2. Initialize your repository with a README
3. Copy the repository location by clicking on the "Code" button on the repo homepage
4. Open RStudio -> Project -> New Project -> From version control. Paste your repository URL into the box. Hit enter.
5. Make a change to the README file
6. Click commit, then push your changes
7. Check that the remote repository (Github) updated

![Video of the GUI method for creating a repository starting with GitHub](images/tools/Rstudio-github-first-method.gif)

Command line method:

1. Log into GitHub and create a new repository
2. Initialize your repository with a README
3. Copy the repository location by clicking on the "Code" button on the repo homepage
4. Navigate to the location you want your repository to live on your machine.
5. Clone the repository by using the git shell or terminal: `git clone <your repo url here>`. In my case, this looks like `git clone git@github.com:stat850-unl/hello-world-2.git`
6. Make a change to your README file and save the change
7. Commit your changes: `git commit -a -m "change readme"` (-a = all, that is, any  changed file git is already tracking).
8. Push your changes to the remote (GitHub) repository and check that the repo has updated: `git push`

### Adding files

`git add` tells git that you want it to track a particular file. 

![git add  diagram: add tells git to add the file to the index of files git monitors.](images/tools/git-add.png)

You don't need to understand exactly what git is doing on the backend, but it is important to know that the actual **contents** of the file aren't logged by `git add` - you have to **commit** your changes for the contents to change. `git add` deals solely with the index of files that git "knows about", and what it thinks belongs in each commit. 

If you use the RStudio GUI for your git interface, you generally won't have to do much with git add; it's (sort-of, kind-of) equivalent to clicking the check box.

#### What files should I add to git?

Git is built for tracking text files. It  will (begrudgingly) deal with small binary files (e.g. images, PDFs) without complaining too much, but it is NOT meant for storing large files, and GitHub will not allow you to push anything that has a file larger than 100MB^[Yes, I'm seriously pushing it with this book; several of the datasets are ~30 MB]. Larger files can be handled with git-lfs (large file storage), but storing large files online is not something you can get for free.

In general, you should **only add a file to git if you created it by hand**. If you compiled the result, that should  not be in the git repository under normal conditions (there are exceptions to this rule -- this book is hosted on GitHub, which means I've pushed the compiled book to the GitHub repository). 

You should also be  cautious about adding files like .Rprog, .directory, .DS_Store, etc. These files are used by your operating system or by RStudio, and pushing them may cause problems for your collaborators (if you're collaborating). Tracking changes to  these files also doesn't really do much good.

I **highly** recommend that you make a point to only add and commit files which you consciously want to track. 

### Staging your changes

In RStudio,  when you check a box next to the file name in the git tab, you are effectively adding the file (if it is not already added) AND staging all of the changes you've made to the file. In practice, `git add` will both add and stage all of the changes to any given file, but it is also useful in some cases to stage only certain lines from a file.

More formally, **staging** is saying "I'd like these changes to be added to the current version, I think". Before you **commit** your changes, you have to first **stage** them. You can think of this like going to the grocery store: you have items in your cart, but you can put them back at any point before checkout. Staging changes is like adding items to your cart; committing those changes is like checking out.

Individually staging lines of a file is most useful in situations where you've made changes which should be part of multiple commits. To stage individual lines of a file, you can use `git add -i` at the command line, or you can attempt to use RStudio's "stage selection" interface. Both  will work, though git can't always separate changes quite as finely as you might want (and as a result, RStudio's interface sometimes seems  unresponsive, even though the underlying issue is with what git can do).



### Committing your changes

A git **commit** is the equivalent of a log entry - it tells git to record the state of the file, along with a message about what that state means. On the back end, git will save a copy of the file in its current state to its cache. 

![Here, we commit the red line as a change to our file.](images/tools/git-commit.png)

In general, you want your commit message to be relatively short, but also informative. The best way to do this is to commit **small** blocks of changes. Work to commit  every time you've accomplished a small task. This will do two things: 

1. You'll have small, bite-sized changes that are briefly described  to serve as a record of what you've done (and what still needs doing)
2. When you mess up (or end up in a merge conflict) you will have a much easier time pinpointing the spot where things went bad, what code was there before, and (because you have nice, descriptive commit messages) how the error occurred.

### Pushing and Pulling

When you're working alone, you generally won't need to worry about having to update your local copy of the repository (unless you're using multiple machines). However, statistics  is collaborative, and one of the most powerful parts of git is that you can use it to keep track of changes when multiple people are working on the same document. 

::: .watch-out
If you are working collaboratively and you and your collaborator are working on the same file, git will be able to resolve the change you make SO LONG AS YOU'RE NOT EDITING THE SAME LINE. Git works based on lines of text - it detects when there is a change in any line of a text document.

For this reason, I find it makes my life easier to put each sentence on a separate line, so that I can tweak things with fewer merge conflicts. Merge conflicts aren't a huge deal, but they slow the workflow down, and are best avoided where possible. 
:::

**Pulling** describes the process of updating your local copy of the repository (the copy on your computer) with the files that are "in the cloud" (on GitHub). `git pull` (or using the Pull button in RStudio) will perform this update for you. If you are working with collaborators in real time, it is good practice to pull, commit, and push often, because  this vastly reduces the merge conflict potential (and the scope of any conflicts that do pop up). 

**Pushing** describes the process of updating the copy of the repository on another machine (e.g. on GitHub) so that it has the most recent changes you've made to your machine. 

<img alt="git push copies the version of the project on your computer to GitHub" src="images/tools/git_push_diagram.png" width = "45%"/> <img alt="git pull copies the version of the project on GitHub to your computer" src="images/tools/git_pull_diagram.png" width = "45%"/>

In general, your workflow will be 

1. Clone the project or create a new repository
2. Make some changes
3. Stage the changes with git add
4. Commit the changes with git commit
5. Pull any changes from the remote repository
6. Resolve any merge conflicts
7. Push the changes (and merged files) with git push

If you're working alone, steps 5 and 6 are not likely to be necessary, but it is good practice to just pull before you push anyways.

:::{.callout-note}

## Topic Sequencing {-}

In several places in this class, you'll have to use material that you haven't been formally taught yet. I will do my absolute best to provide thorough instructions, help you along as much as I can, and generally provide enough support that you can muddle through. But it's going to be hard to teach you everything you need to e.g. analyze some data, before providing you the opportunity to SEE that data using visualization packages. And it's silly to teach you plotting before you know how to read data in. But to teach you how to read data in, you need to be able to take a look at the data, and plots are the best way to do that. To do any of this stuff, you need to know about functions, but it can be easier to figure out how to run a function than to write a function. 

You see my problem.

So instead, what I'm going to do is to leave you lots of comments as to what a piece of code does when I'm using things you haven't been formally shown yet. Then, you can copy/paste/modify those pieces of code, and if they break, you can ask why and we'll dig into it (breaking code is usually a good thing, because it means you're learning how to program). For each chapter, focus on learning how to write code that accomplishes that chapter's objectives. If you understand some of the code you're modifying that covers other topics not in that chapter, so much the better. But it's not an expectation or a requirement.

If you're confused, please post on the class message boards so that those who have seen this material before can help you out.
:::

:::{.callout-important}
## Learn More {- #refs-module-1}

### Extra Resources {-}

- A different guide to using R and RStudio can be found in [Section 1 of ModernDive's book](https://moderndive.netlify.app/1-getting-started.html) [@ismayStatisticalInferenceData2019, Chapter 1]

- [R quick start guide](https://www.statmethods.net/) [@robertkabacoffQuickR2017]

- [Happy Git and GitHub for the useR](https://happygitwithr.com/index.html) - Guide to using git, R, and RStudio together. [@jennybryanHappyGitGitHub2021]

- [Git "Hello World" Tutorial on GitHub](https://guides.github.com/activities/hello-world/)

- [Crash course on git](https://www.youtube.com/watch?v=SWYqp7iY_Tc) (30 minute YouTube video) [@traversymediaGitGitHubCrash2017]

- [Git and GitHub for poets](https://www.youtube.com/watch?v=BCQHnlnPusY&list=PLRqwX-V7Uu6ZF9C0YMKuns9sLDzK6zoiV) YouTube playlist (this is supposed to be the best introduction to Git out there...) [@thecodingtrainIntroductionGitGitHub2016]

- [More advanced git concepts, in comic form](https://dev.to/erikaheidi/stage-commit-push-a-git-story-comic-a37), by Erika Heidi [@ericaheidiStageCommitPush2020]

- [A quick guide to the command line (Terminal)](https://towardsdatascience.com/a-quick-guide-to-using-command-line-terminal-96815b97b955) [@weiQuickGuideUsing2019]
:::

### References {-}


